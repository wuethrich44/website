<?php

 namespace Zend\Mvc { use Zend\EventManager\EventsCapableInterface; interface ApplicationInterface extends EventsCapableInterface { public function getServiceManager(); public function getRequest(); public function getResponse(); public function run(); } } namespace Zend\EventManager { interface EventsCapableInterface { public function getEventManager(); } } namespace Zend\EventManager { interface EventManagerAwareInterface extends EventsCapableInterface { public function setEventManager(EventManagerInterface $eventManager); } } namespace Zend\ServiceManager { interface ServiceLocatorInterface { public function get($name); public function has($name); } } namespace Zend\ServiceManager { interface ConfigInterface { public function configureServiceManager(ServiceManager $serviceManager); } } namespace Zend\ServiceManager { interface FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator); } } namespace Zend\Stdlib { interface ParameterObjectInterface { public function __set($key, $value); public function __get($key); public function __isset($key); public function __unset($key); } } namespace Zend\EventManager { interface ListenerAggregateInterface { public function attach(EventManagerInterface $events); public function detach(EventManagerInterface $events); } } namespace Zend\ModuleManager\Listener { use Zend\EventManager\ListenerAggregateInterface; use Zend\ServiceManager\ServiceManager; interface ServiceListenerInterface extends ListenerAggregateInterface { public function addServiceManager($serviceManager, $key, $moduleInterface, $method); public function setDefaultServiceConfig($configuration); } } namespace Zend\EventManager { use Traversable; use Zend\Stdlib\CallbackHandler; interface EventManagerInterface extends SharedEventManagerAwareInterface { public function trigger($event, $target = null, $argv = array(), $callback = null); public function triggerUntil($event, $target, $argv = null, $callback = null); public function attach($event, $callback = null, $priority = 1); public function detach($listener); public function getEvents(); public function getListeners($event); public function clearListeners($event); public function setEventClass($class); public function getIdentifiers(); public function setIdentifiers($identifiers); public function addIdentifiers($identifiers); public function attachAggregate(ListenerAggregateInterface $aggregate, $priority = 1); public function detachAggregate(ListenerAggregateInterface $aggregate); } } namespace Zend\EventManager { interface SharedEventManagerAwareInterface { public function setSharedManager(SharedEventManagerInterface $sharedEventManager); public function getSharedManager(); public function unsetSharedManager(); } } namespace Zend\EventManager { interface SharedEventAggregateAwareInterface { public function attachAggregate(SharedListenerAggregateInterface $aggregate, $priority = 1); public function detachAggregate(SharedListenerAggregateInterface $aggregate); } } namespace Zend\EventManager { use Zend\Stdlib\CallbackHandler; use Zend\Stdlib\PriorityQueue; interface SharedEventManagerInterface { public function getListeners($id, $event); public function attach($id, $event, $callback, $priority = 1); public function detach($id, CallbackHandler $listener); public function getEvents($id); public function clearListeners($id, $event = null); } } namespace Zend\ModuleManager\Listener { interface ConfigMergerInterface { public function getMergedConfig($returnConfigAsObject = true); public function setMergedConfig(array $config); } } namespace Zend\EventManager { use ArrayAccess; interface EventInterface { public function getName(); public function getTarget(); public function getParams(); public function getParam($name, $default = null); public function setName($name); public function setTarget($target); public function setParams($params); public function setParam($name, $value); public function stopPropagation($flag = true); public function propagationIsStopped(); } } namespace Zend\ModuleManager { use Zend\EventManager\EventManagerAwareInterface; interface ModuleManagerInterface extends EventManagerAwareInterface { public function loadModules(); public function loadModule($moduleName); public function getLoadedModules($loadModules); public function getModules(); public function setModules($modules); } } namespace Zend\ModuleManager\Feature { interface AutoloaderProviderInterface { public function getAutoloaderConfig(); } } namespace Zend\ModuleManager\Feature { interface ConfigProviderInterface { public function getConfig(); } } namespace Zend\ModuleManager\Feature { interface ServiceProviderInterface { public function getServiceConfig(); } } namespace Zend\ServiceManager { interface AbstractFactoryInterface { public function canCreateServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName); public function createServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName); } } namespace Zend\ServiceManager { interface ServiceLocatorAwareInterface { public function setServiceLocator(ServiceLocatorInterface $serviceLocator); public function getServiceLocator(); } } namespace Zend\Stdlib { interface MessageInterface { public function setMetadata($spec, $value = null); public function getMetadata($key = null); public function setContent($content); public function getContent(); } } namespace Zend\Stdlib { interface RequestInterface extends MessageInterface { } } namespace Zend\Stdlib { use ArrayAccess; use Countable; use Serializable; use Traversable; interface ParametersInterface extends ArrayAccess, Countable, Serializable, Traversable { public function __construct(array $values = null); public function fromArray(array $values); public function fromString($string); public function toArray(); public function toString(); public function get($name, $default = null); public function set($name, $value); } } namespace Zend\Http\Header { interface HeaderInterface { public static function fromString($headerLine); public function getFieldName(); public function getFieldValue(); public function toString(); } } namespace Zend\Uri { interface UriInterface { public function __construct($uri = null); public function isValid(); public function isValidRelative(); public function isAbsolute(); public function parse($uri); public function toString(); public function normalize(); public function makeRelative($baseUri); public function getScheme(); public function getUserInfo(); public function getHost(); public function getPort(); public function getPath(); public function getQuery(); public function getQueryAsArray(); public function getFragment(); public function setScheme($scheme); public function setUserInfo($userInfo); public function setHost($host); public function setPort($port); public function setPath($path); public function setQuery($query); public function setFragment($fragment); public function __toString(); } } namespace Zend\Loader { use IteratorAggregate; use Traversable; interface PluginClassLocator extends ShortNameLocator, IteratorAggregate { public function registerPlugin($shortName, $className); public function unregisterPlugin($shortName); public function getRegisteredPlugins(); } } namespace Zend\Loader { interface ShortNameLocator { public function isLoaded($name); public function getClassName($name); public function load($name); } } namespace Zend\Validator\Translator { interface TranslatorAwareInterface { public function setTranslator(TranslatorInterface $translator = null, $textDomain = null); public function getTranslator(); public function hasTranslator(); public function setTranslatorEnabled($enabled = true); public function isTranslatorEnabled(); public function setTranslatorTextDomain($textDomain = 'default'); public function getTranslatorTextDomain(); } } namespace Zend\Validator { interface ValidatorInterface { public function isValid($value); public function getMessages(); } } namespace Zend\Stdlib\StringWrapper { interface StringWrapperInterface { public static function isSupported($encoding, $convertEncoding = null); public static function getSupportedEncodings(); public function setEncoding($encoding, $convertEncoding = null); public function getEncoding(); public function getConvertEncoding(); public function strlen($str); public function substr($str, $offset = 0, $length = null); public function strpos($haystack, $needle, $offset = 0); public function convert($str, $reverse = false); public function wordWrap($str, $width = 75, $break = "\n", $cut = false); public function strPad($input, $padLength, $padString = ' ', $padType = STR_PAD_RIGHT); } } namespace Zend\Stdlib { interface ResponseInterface extends MessageInterface { } } namespace Zend\Mvc\ResponseSender { interface ResponseSenderInterface { public function __invoke(SendResponseEvent $event); } } namespace Zend\Mvc\Router { interface RouteStackInterface extends RouteInterface { public function addRoute($name, $route, $priority = null); public function addRoutes($routes); public function removeRoute($name); public function setRoutes($routes); } } namespace Zend\Mvc\Router { use Zend\Stdlib\RequestInterface as Request; interface RouteInterface { public static function factory($options = array()); public function match(Request $request); public function assemble(array $params = array(), array $options = array()); } } namespace Zend\Mvc\Router\Http { use Zend\Mvc\Router\RouteInterface as BaseRoute; interface RouteInterface extends BaseRoute { public function getAssembledParams(); } } namespace Zend\View\Renderer { use Zend\View\Model\ModelInterface; use Zend\View\Resolver\ResolverInterface; interface RendererInterface { public function getEngine(); public function setResolver(ResolverInterface $resolver); public function render($nameOrModel, $values = null); } } namespace Zend\View\Renderer { interface TreeRendererInterface { public function canRenderTrees(); } } namespace Zend\View\Resolver { use Zend\View\Renderer\RendererInterface as Renderer; interface ResolverInterface { public function resolve($name, Renderer $renderer = null); } } namespace Zend\View\Model { use Countable; use IteratorAggregate; interface ModelInterface extends Countable, IteratorAggregate { public function setOption($name, $value); public function setOptions($options); public function getOptions(); public function getVariable($name, $default = null); public function setVariable($name, $value); public function setVariables($variables); public function getVariables(); public function setTemplate($template); public function getTemplate(); public function addChild(ModelInterface $child, $captureTo = null, $append = false); public function getChildren(); public function hasChildren(); public function setCaptureTo($capture); public function captureTo(); public function setTerminal($terminate); public function terminate(); public function setAppend($append); public function isAppend(); } } namespace Zend\View\Model { interface ClearableModelInterface { public function clearChildren(); public function clearOptions(); public function clearVariables(); } } namespace Zend\View\Model { interface RetrievableChildrenInterface { public function getChildrenByCaptureTo($capture, $recursive = true); } } namespace Zend\View\Helper { use Zend\View\Renderer\RendererInterface as Renderer; interface HelperInterface { public function setView(Renderer $view); public function getView(); } } namespace Zend\I18n\Translator { interface TranslatorInterface { public function translate($message, $textDomain = 'default', $locale = null); public function translatePlural( $singular, $plural, $number, $textDomain = 'default', $locale = null ); } } namespace Zend\Validator\Translator { interface TranslatorInterface { public function translate($message, $textDomain = 'default', $locale = null); } } namespace Zend\Stdlib { interface DispatchableInterface { public function dispatch(RequestInterface $request, ResponseInterface $response = null); } } namespace Zend\Mvc { use Zend\EventManager\EventInterface as Event; interface InjectApplicationEventInterface { public function setEvent(Event $event); public function getEvent(); } } namespace Zend\Db\Adapter { interface AdapterInterface { public function getDriver(); public function getPlatform(); } } namespace Zend\Db\Adapter\Profiler { interface ProfilerAwareInterface { public function setProfiler(ProfilerInterface $profiler); } } namespace Zend\Db\Adapter\Driver { interface DriverInterface { const PARAMETERIZATION_POSITIONAL = 'positional'; const PARAMETERIZATION_NAMED = 'named'; const NAME_FORMAT_CAMELCASE = 'camelCase'; const NAME_FORMAT_NATURAL = 'natural'; public function getDatabasePlatformName($nameFormat = self::NAME_FORMAT_CAMELCASE); public function checkEnvironment(); public function getConnection(); public function createStatement($sqlOrResource = null); public function createResult($resource); public function getPrepareType(); public function formatParameterName($name, $type = null); public function getLastGeneratedValue(); } } namespace Zend\Db\Adapter\Driver\Feature { interface DriverFeatureInterface { public function setupDefaultFeatures(); public function addFeature($name, $feature); public function getFeature($name); } } namespace Zend\Db\Adapter\Driver { interface ConnectionInterface { public function getCurrentSchema(); public function getResource(); public function connect(); public function isConnected(); public function disconnect(); public function beginTransaction(); public function commit(); public function rollback(); public function execute($sql); public function getLastGeneratedValue($name = null); } } namespace Zend\Db\Adapter\Driver { use Zend\Db\Adapter\StatementContainerInterface; interface StatementInterface extends StatementContainerInterface { public function getResource(); public function prepare($sql = null); public function isPrepared(); public function execute($parameters = null); } } namespace Zend\Db\Adapter { interface StatementContainerInterface { public function setSql($sql); public function getSql(); public function setParameterContainer(ParameterContainer $parameterContainer); public function getParameterContainer(); } } namespace Zend\Db\Adapter\Driver { use Countable; use Iterator; interface ResultInterface extends Countable, Iterator { public function buffer(); public function isBuffered(); public function isQueryResult(); public function getAffectedRows(); public function getGeneratedValue(); public function getResource(); public function getFieldCount(); } } namespace Zend\Db\Adapter\Platform { interface PlatformInterface { public function getName(); public function getQuoteIdentifierSymbol(); public function quoteIdentifier($identifier); public function quoteIdentifierChain($identifierChain); public function getQuoteValueSymbol(); public function quoteValue($value); public function quoteTrustedValue($value); public function quoteValueList($valueList); public function getIdentifierSeparator(); public function quoteIdentifierInFragment($identifier, array $additionalSafeWords = array()); } } namespace Zend\Db\ResultSet { use Countable; use Traversable; interface ResultSetInterface extends Traversable, Countable { public function initialize($dataSource); public function getFieldCount(); } } namespace Zend\InputFilter { interface InputFilterAwareInterface { public function setInputFilter(InputFilterInterface $inputFilter); public function getInputFilter(); } } namespace Zend\Db\TableGateway { interface TableGatewayInterface { public function getTable(); public function select($where = null); public function insert($set); public function update($set, $where = null); public function delete($where); } } namespace Zend\Db\Sql\Platform { interface PlatformDecoratorInterface { public function setSubject($subject); } } namespace Zend\Db\Sql { use Zend\Db\Adapter\AdapterInterface; use Zend\Db\Adapter\StatementContainerInterface; interface PreparableSqlInterface { public function prepareStatement(AdapterInterface $adapter, StatementContainerInterface $statementContainer); } } namespace Zend\Db\Sql { use Zend\Db\Adapter\Platform\PlatformInterface; interface SqlInterface { public function getSqlString(PlatformInterface $adapterPlatform = null); } } namespace Zend\Db\Sql\Predicate { use Zend\Db\Sql\ExpressionInterface; interface PredicateInterface extends ExpressionInterface { } } namespace Zend\Db\Sql { interface ExpressionInterface { const TYPE_IDENTIFIER = 'identifier'; const TYPE_VALUE = 'value'; const TYPE_LITERAL = 'literal'; public function getExpressionData(); } } namespace Zend\Db\Sql\Ddl { use Zend\Db\Sql\SqlInterface as BaseSqlInterface; interface SqlInterface extends BaseSqlInterface { } } namespace Zend\Mvc\Controller\Plugin { use Zend\Stdlib\DispatchableInterface as Dispatchable; interface PluginInterface { public function setController(Dispatchable $controller); public function getController(); } } namespace Zend\Filter { interface FilterInterface { public function filter($value); } } namespace Zend\I18n\Translator { interface TranslatorAwareInterface { public function setTranslator(TranslatorInterface $translator = null, $textDomain = null); public function getTranslator(); public function hasTranslator(); public function setTranslatorEnabled($enabled = true); public function isTranslatorEnabled(); public function setTranslatorTextDomain($textDomain = 'default'); public function getTranslatorTextDomain(); } } namespace Zend\I18n\Translator\Loader { interface FileLoaderInterface { public function load($locale, $filename); } } namespace Zend\Authentication { interface AuthenticationServiceInterface { public function authenticate(); public function hasIdentity(); public function getIdentity(); public function clearIdentity(); } } namespace Zend\Authentication\Storage { interface StorageInterface { public function isEmpty(); public function read(); public function write($contents); public function clear(); } } namespace Zend\ServiceManager { interface ServiceManagerAwareInterface { public function setServiceManager(ServiceManager $serviceManager); } } namespace Zend\Authentication\Adapter { interface AdapterInterface { public function authenticate(); } } namespace Zend\Session { use Zend\EventManager\EventManagerInterface; use Zend\Session\Config\ConfigInterface as Config; use Zend\Session\SaveHandler\SaveHandlerInterface as SaveHandler; use Zend\Session\Storage\StorageInterface as Storage; interface ManagerInterface { public function setConfig(Config $config); public function getConfig(); public function setStorage(Storage $storage); public function getStorage(); public function setSaveHandler(SaveHandler $saveHandler); public function getSaveHandler(); public function sessionExists(); public function start(); public function destroy(); public function writeClose(); public function setName($name); public function getName(); public function setId($id); public function getId(); public function regenerateId(); public function rememberMe($ttl = null); public function forgetMe(); public function expireSessionCookie(); public function setValidatorChain(EventManagerInterface $chain); public function getValidatorChain(); public function isValid(); } } namespace Zend\Session\Config { interface ConfigInterface { public function setOptions($options); public function getOptions(); public function setOption($option, $value); public function getOption($option); public function hasOption($option); public function toArray(); public function setName($name); public function getName(); public function setSavePath($savePath); public function getSavePath(); public function setCookieLifetime($cookieLifetime); public function getCookieLifetime(); public function setCookiePath($cookiePath); public function getCookiePath(); public function setCookieDomain($cookieDomain); public function getCookieDomain(); public function setCookieSecure($cookieSecure); public function getCookieSecure(); public function setCookieHttpOnly($cookieHttpOnly); public function getCookieHttpOnly(); public function setUseCookies($useCookies); public function getUseCookies(); public function setRememberMeSeconds($rememberMeSeconds); public function getRememberMeSeconds(); } } namespace Zend\Session\Storage { use ArrayAccess; use Countable; use Serializable; use Traversable; interface StorageInterface extends Traversable, ArrayAccess, Serializable, Countable { public function getRequestAccessTime(); public function lock($key = null); public function isLocked($key = null); public function unlock($key = null); public function markImmutable(); public function isImmutable(); public function setMetadata($key, $value, $overwriteArray = false); public function getMetadata($key = null); public function clear($key = null); public function fromArray(array $array); public function toArray($metaData = false); } } namespace Zend\Session\Storage { interface StorageInitializationInterface { public function init($input = null); } } namespace Zend\Stdlib\Hydrator { use Zend\Stdlib\Extractor\ExtractionInterface; interface HydratorInterface extends HydrationInterface, ExtractionInterface { } } namespace Zend\Stdlib\Hydrator { interface HydrationInterface { public function hydrate(array $data, $object); } } namespace Zend\Stdlib\Extractor { interface ExtractionInterface { public function extract($object); } } namespace Zend\Stdlib\Hydrator { use Zend\Stdlib\Hydrator\Strategy\StrategyInterface; interface StrategyEnabledInterface { public function addStrategy($name, StrategyInterface $strategy); public function getStrategy($name); public function hasStrategy($name); public function removeStrategy($name); } } namespace Zend\Stdlib\Hydrator { use Zend\Stdlib\Hydrator\Filter\FilterInterface; use Zend\Stdlib\Hydrator\Filter\FilterComposite; use Zend\Stdlib\Hydrator\Filter\FilterProviderInterface; interface FilterEnabledInterface extends FilterProviderInterface { public function addFilter($name, $filter, $condition = FilterComposite::CONDITION_OR); public function hasFilter($name); public function removeFilter($name); } } namespace Zend\Stdlib\Hydrator\Filter { interface FilterProviderInterface { public function getFilter(); } } namespace Zend\Stdlib\Hydrator { use Zend\Stdlib\Hydrator\NamingStrategy\NamingStrategyInterface; interface NamingStrategyEnabledInterface { public function setNamingStrategy(NamingStrategyInterface $strategy); public function getNamingStrategy(); public function hasNamingStrategy(); public function removeNamingStrategy(); } } namespace Zend\Stdlib\Hydrator { interface HydratorOptionsInterface { public function setOptions($options); } } namespace Zend\Stdlib\Hydrator\Filter { interface FilterInterface { public function filter($property); } } namespace Zend\Stdlib\Hydrator\NamingStrategy { interface NamingStrategyInterface { public function hydrate($name); public function extract($name); } } namespace Zend\View\Helper\Navigation { use Zend\Navigation; use Zend\Permissions\Acl; use Zend\View\Helper\HelperInterface as BaseHelperInterface; interface HelperInterface extends BaseHelperInterface { public function __toString(); public function render($container = null); public function setAcl(Acl\AclInterface $acl = null); public function getAcl(); public function hasAcl(); public function setContainer($container = null); public function getContainer(); public function hasContainer(); public function setRenderInvisible($renderInvisible = true); public function getRenderInvisible(); public function setRole($role = null); public function getRole(); public function hasRole(); public function setUseAcl($useAcl = true); public function getUseAcl(); } } namespace Zend\Mvc { use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\ServiceManager\ServiceManager; use Zend\Stdlib\ResponseInterface; class Application implements ApplicationInterface, EventManagerAwareInterface { const ERROR_CONTROLLER_CANNOT_DISPATCH = 'error-controller-cannot-dispatch'; const ERROR_CONTROLLER_NOT_FOUND = 'error-controller-not-found'; const ERROR_CONTROLLER_INVALID = 'error-controller-invalid'; const ERROR_EXCEPTION = 'error-exception'; const ERROR_ROUTER_NO_MATCH = 'error-router-no-match'; protected $configuration = null; protected $defaultListeners = array( 'RouteListener', 'DispatchListener', 'ViewManager', 'SendResponseListener', ); protected $event; protected $events; protected $request; protected $response; protected $serviceManager = null; public function __construct($configuration, ServiceManager $serviceManager) { $this->configuration = $configuration; $this->serviceManager = $serviceManager; $this->setEventManager($serviceManager->get('EventManager')); $this->request = $serviceManager->get('Request'); $this->response = $serviceManager->get('Response'); } public function getConfig() { return $this->serviceManager->get('Config'); } public function bootstrap(array $listeners = array()) { $serviceManager = $this->serviceManager; $events = $this->events; $listeners = array_unique(array_merge($this->defaultListeners, $listeners)); foreach ($listeners as $listener) { $events->attach($serviceManager->get($listener)); } $this->event = $event = new MvcEvent(); $event->setTarget($this); $event->setApplication($this) ->setRequest($this->request) ->setResponse($this->response) ->setRouter($serviceManager->get('Router')); $events->trigger(MvcEvent::EVENT_BOOTSTRAP, $event); return $this; } public function getServiceManager() { return $this->serviceManager; } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } public function getMvcEvent() { return $this->event; } public function setEventManager(EventManagerInterface $eventManager) { $eventManager->setIdentifiers(array( __CLASS__, get_class($this), )); $this->events = $eventManager; return $this; } public function getEventManager() { return $this->events; } public static function init($configuration = array()) { $smConfig = isset($configuration['service_manager']) ? $configuration['service_manager'] : array(); $serviceManager = new ServiceManager(new Service\ServiceManagerConfig($smConfig)); $serviceManager->setService('ApplicationConfig', $configuration); $serviceManager->get('ModuleManager')->loadModules(); $listenersFromAppConfig = isset($configuration['listeners']) ? $configuration['listeners'] : array(); $config = $serviceManager->get('Config'); $listenersFromConfigService = isset($config['listeners']) ? $config['listeners'] : array(); $listeners = array_unique(array_merge($listenersFromConfigService, $listenersFromAppConfig)); return $serviceManager->get('Application')->bootstrap($listeners); } public function run() { $events = $this->events; $event = $this->event; $shortCircuit = function ($r) use ($event) { if ($r instanceof ResponseInterface) { return true; } if ($event->getError()) { return true; } return false; }; $result = $events->trigger(MvcEvent::EVENT_ROUTE, $event, $shortCircuit); if ($result->stopped()) { $response = $result->last(); if ($response instanceof ResponseInterface) { $event->setTarget($this); $event->setResponse($response); $events->trigger(MvcEvent::EVENT_FINISH, $event); $this->response = $response; return $this; } } if ($event->getError()) { return $this->completeRequest($event); } $result = $events->trigger(MvcEvent::EVENT_DISPATCH, $event, $shortCircuit); $response = $result->last(); if ($response instanceof ResponseInterface) { $event->setTarget($this); $event->setResponse($response); $events->trigger(MvcEvent::EVENT_FINISH, $event); $this->response = $response; return $this; } $response = $this->response; $event->setResponse($response); $this->completeRequest($event); return $this; } public function send() { } protected function completeRequest(MvcEvent $event) { $events = $this->events; $event->setTarget($this); $events->trigger(MvcEvent::EVENT_RENDER, $event); $events->trigger(MvcEvent::EVENT_FINISH, $event); return $this; } } } namespace Zend\Stdlib { use Traversable; abstract class ArrayUtils { public static function hasStringKeys($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return count(array_filter(array_keys($value), 'is_string')) > 0; } public static function hasIntegerKeys($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return count(array_filter(array_keys($value), 'is_int')) > 0; } public static function hasNumericKeys($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return count(array_filter(array_keys($value), 'is_numeric')) > 0; } public static function isList($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return (array_values($value) === $value); } public static function isHashTable($value, $allowEmpty = false) { if (!is_array($value)) { return false; } if (!$value) { return $allowEmpty; } return (array_values($value) !== $value); } public static function inArray($needle, array $haystack, $strict = false) { if (!$strict) { if (is_int($needle) || is_float($needle)) { $needle = (string) $needle; } if (is_string($needle)) { foreach ($haystack as &$h) { if (is_int($h) || is_float($h)) { $h = (string) $h; } } } } return in_array($needle, $haystack, $strict); } public static function iteratorToArray($iterator, $recursive = true) { if (!is_array($iterator) && !$iterator instanceof Traversable) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable object'); } if (!$recursive) { if (is_array($iterator)) { return $iterator; } return iterator_to_array($iterator); } if (method_exists($iterator, 'toArray')) { return $iterator->toArray(); } $array = array(); foreach ($iterator as $key => $value) { if (is_scalar($value)) { $array[$key] = $value; continue; } if ($value instanceof Traversable) { $array[$key] = static::iteratorToArray($value, $recursive); continue; } if (is_array($value)) { $array[$key] = static::iteratorToArray($value, $recursive); continue; } $array[$key] = $value; } return $array; } public static function merge(array $a, array $b, $preserveNumericKeys = false) { foreach ($b as $key => $value) { if (array_key_exists($key, $a)) { if (is_int($key) && !$preserveNumericKeys) { $a[] = $value; } elseif (is_array($value) && is_array($a[$key])) { $a[$key] = static::merge($a[$key], $value, $preserveNumericKeys); } else { $a[$key] = $value; } } else { $a[$key] = $value; } } return $a; } } } namespace Zend\ServiceManager { use ReflectionClass; class ServiceManager implements ServiceLocatorInterface { const SCOPE_PARENT = 'parent'; const SCOPE_CHILD = 'child'; protected $canonicalNames = array(); protected $allowOverride = false; protected $invokableClasses = array(); protected $factories = array(); protected $abstractFactories = array(); protected $delegators = array(); protected $pendingAbstractFactoryRequests = array(); protected $nestedContextCounter = -1; protected $nestedContext = array(); protected $shared = array(); protected $instances = array(); protected $aliases = array(); protected $initializers = array(); protected $peeringServiceManagers = array(); protected $shareByDefault = true; protected $retrieveFromPeeringManagerFirst = false; protected $throwExceptionInCreate = true; protected $canonicalNamesReplacements = array('-' => '', '_' => '', ' ' => '', '\\' => '', '/' => ''); public function __construct(ConfigInterface $config = null) { if ($config) { $config->configureServiceManager($this); } } public function setAllowOverride($allowOverride) { $this->allowOverride = (bool) $allowOverride; return $this; } public function getAllowOverride() { return $this->allowOverride; } public function setShareByDefault($shareByDefault) { if ($this->allowOverride === false) { throw new Exception\RuntimeException(sprintf( '%s: cannot alter default shared service setting; container is marked immutable (allow_override is false)', get_class($this) . '::' . __FUNCTION__ )); } $this->shareByDefault = (bool) $shareByDefault; return $this; } public function shareByDefault() { return $this->shareByDefault; } public function setThrowExceptionInCreate($throwExceptionInCreate) { $this->throwExceptionInCreate = $throwExceptionInCreate; return $this; } public function getThrowExceptionInCreate() { return $this->throwExceptionInCreate; } public function setRetrieveFromPeeringManagerFirst($retrieveFromPeeringManagerFirst = true) { $this->retrieveFromPeeringManagerFirst = (bool) $retrieveFromPeeringManagerFirst; return $this; } public function retrieveFromPeeringManagerFirst() { return $this->retrieveFromPeeringManagerFirst; } public function setInvokableClass($name, $invokableClass, $shared = null) { $cName = $this->canonicalizeName($name); if ($this->has(array($cName, $name), false)) { if ($this->allowOverride === false) { throw new Exception\InvalidServiceNameException(sprintf( 'A service by the name or alias "%s" already exists and cannot be overridden; please use an alternate name', $name )); } $this->unregisterService($cName); } if ($shared === null) { $shared = $this->shareByDefault; } $this->invokableClasses[$cName] = $invokableClass; $this->shared[$cName] = (bool) $shared; return $this; } public function setFactory($name, $factory, $shared = null) { $cName = $this->canonicalizeName($name); if (!($factory instanceof FactoryInterface || is_string($factory) || is_callable($factory))) { throw new Exception\InvalidArgumentException( 'Provided abstract factory must be the class name of an abstract factory or an instance of an AbstractFactoryInterface.' ); } if ($this->has(array($cName, $name), false)) { if ($this->allowOverride === false) { throw new Exception\InvalidServiceNameException(sprintf( 'A service by the name or alias "%s" already exists and cannot be overridden, please use an alternate name', $name )); } $this->unregisterService($cName); } if ($shared === null) { $shared = $this->shareByDefault; } $this->factories[$cName] = $factory; $this->shared[$cName] = (bool) $shared; return $this; } public function addAbstractFactory($factory, $topOfStack = true) { if (!$factory instanceof AbstractFactoryInterface && is_string($factory)) { $factory = new $factory(); } if (!$factory instanceof AbstractFactoryInterface) { throw new Exception\InvalidArgumentException( 'Provided abstract factory must be the class name of an abstract' . ' factory or an instance of an AbstractFactoryInterface.' ); } if ($topOfStack) { array_unshift($this->abstractFactories, $factory); } else { array_push($this->abstractFactories, $factory); } return $this; } public function addDelegator($serviceName, $delegatorFactoryName) { $cName = $this->canonicalizeName($serviceName); if (!isset($this->delegators[$cName])) { $this->delegators[$cName] = array(); } $this->delegators[$cName][] = $delegatorFactoryName; return $this; } public function addInitializer($initializer, $topOfStack = true) { if (!($initializer instanceof InitializerInterface || is_callable($initializer))) { if (is_string($initializer)) { $initializer = new $initializer; } if (!($initializer instanceof InitializerInterface || is_callable($initializer))) { throw new Exception\InvalidArgumentException('$initializer should be callable.'); } } if ($topOfStack) { array_unshift($this->initializers, $initializer); } else { array_push($this->initializers, $initializer); } return $this; } public function setService($name, $service) { $cName = $this->canonicalizeName($name); if ($this->has($cName, false)) { if ($this->allowOverride === false) { throw new Exception\InvalidServiceNameException(sprintf( '%s: A service by the name "%s" or alias already exists and cannot be overridden, please use an alternate name.', get_class($this) . '::' . __FUNCTION__, $name )); } $this->unregisterService($cName); } $this->instances[$cName] = $service; return $this; } public function setShared($name, $isShared) { $cName = $this->canonicalizeName($name); if ( !isset($this->invokableClasses[$cName]) && !isset($this->factories[$cName]) && !$this->canCreateFromAbstractFactory($cName, $name) ) { throw new Exception\ServiceNotFoundException(sprintf( '%s: A service by the name "%s" was not found and could not be marked as shared', get_class($this) . '::' . __FUNCTION__, $name )); } $this->shared[$cName] = (bool) $isShared; return $this; } protected function resolveAlias($cName) { $stack = array(); while ($this->hasAlias($cName)) { if (isset($stack[$cName])) { throw new Exception\CircularReferenceException(sprintf( 'Circular alias reference: %s -> %s', implode(' -> ', $stack), $cName )); } $stack[$cName] = $cName; $cName = $this->aliases[$cName]; } return $cName; } public function get($name, $usePeeringServiceManagers = true) { if (isset($this->canonicalNames[$name])) { $cName = $this->canonicalNames[$name]; } else { $cName = $this->canonicalizeName($name); } $isAlias = false; if ($this->hasAlias($cName)) { $isAlias = true; $cName = $this->resolveAlias($cName); } $instance = null; if ($usePeeringServiceManagers && $this->retrieveFromPeeringManagerFirst) { $instance = $this->retrieveFromPeeringManager($name); if (null !== $instance) { return $instance; } } if (isset($this->instances[$cName])) { return $this->instances[$cName]; } if (!$instance) { $this->checkNestedContextStart($cName); if ( isset($this->invokableClasses[$cName]) || isset($this->factories[$cName]) || isset($this->aliases[$cName]) || $this->canCreateFromAbstractFactory($cName, $name) ) { $instance = $this->create(array($cName, $name)); } elseif ($isAlias && $this->canCreateFromAbstractFactory($name, $cName)) { $instance = $this->create(array($name, $cName)); } elseif ($usePeeringServiceManagers && !$this->retrieveFromPeeringManagerFirst) { $instance = $this->retrieveFromPeeringManager($name); } $this->checkNestedContextStop(); } if ($instance === null) { $this->checkNestedContextStop(true); if ($isAlias) { throw new Exception\ServiceNotFoundException(sprintf( 'An alias "%s" was requested but no service could be found.', $name )); } throw new Exception\ServiceNotFoundException(sprintf( '%s was unable to fetch or create an instance for %s', get_class($this) . '::' . __FUNCTION__, $name )); } if ( ($this->shareByDefault && !isset($this->shared[$cName])) || (isset($this->shared[$cName]) && $this->shared[$cName] === true) ) { $this->instances[$cName] = $instance; } return $instance; } public function create($name) { if (is_array($name)) { list($cName, $rName) = $name; } else { $rName = $name; if (isset($this->canonicalNames[$rName])) { $cName = $this->canonicalNames[$name]; } else { $cName = $this->canonicalizeName($name); } } if (isset($this->delegators[$cName])) { return $this->createDelegatorFromFactory($cName, $rName); } return $this->doCreate($rName, $cName); } private function createDelegatorCallback($delegatorFactory, $rName, $cName, $creationCallback) { $serviceManager = $this; return function () use ($serviceManager, $delegatorFactory, $rName, $cName, $creationCallback) { return $delegatorFactory instanceof DelegatorFactoryInterface ? $delegatorFactory->createDelegatorWithName($serviceManager, $cName, $rName, $creationCallback) : $delegatorFactory($serviceManager, $cName, $rName, $creationCallback); }; } public function doCreate($rName, $cName) { $instance = null; if (isset($this->factories[$cName])) { $instance = $this->createFromFactory($cName, $rName); } if ($instance === null && isset($this->invokableClasses[$cName])) { $instance = $this->createFromInvokable($cName, $rName); } $this->checkNestedContextStart($cName); if ($instance === null && $this->canCreateFromAbstractFactory($cName, $rName)) { $instance = $this->createFromAbstractFactory($cName, $rName); } $this->checkNestedContextStop(); if ($instance === null && $this->throwExceptionInCreate) { $this->checkNestedContextStop(true); throw new Exception\ServiceNotFoundException(sprintf( 'No valid instance was found for %s%s', $cName, ($rName ? '(alias: ' . $rName . ')' : '') )); } if ($instance === null) { return $instance; } foreach ($this->initializers as $initializer) { if ($initializer instanceof InitializerInterface) { $initializer->initialize($instance, $this); } else { call_user_func($initializer, $instance, $this); } } return $instance; } public function canCreate($name, $checkAbstractFactories = true) { trigger_error(sprintf('%s is deprecated; please use %s::has', __METHOD__, __CLASS__), E_USER_DEPRECATED); return $this->has($name, $checkAbstractFactories, false); } public function has($name, $checkAbstractFactories = true, $usePeeringServiceManagers = true) { if (is_string($name)) { $rName = $name; if (isset($this->canonicalNames[$rName])) { $cName = $this->canonicalNames[$rName]; } else { $cName = $this->canonicalizeName($name); } } elseif (is_array($name) && count($name) >= 2) { list($cName, $rName) = $name; } else { return false; } if (isset($this->invokableClasses[$cName]) || isset($this->factories[$cName]) || isset($this->aliases[$cName]) || isset($this->instances[$cName]) || ($checkAbstractFactories && $this->canCreateFromAbstractFactory($cName, $rName)) ) { return true; } if ($usePeeringServiceManagers) { foreach ($this->peeringServiceManagers as $peeringServiceManager) { if ($peeringServiceManager->has($name)) { return true; } } } return false; } public function canCreateFromAbstractFactory($cName, $rName) { if (array_key_exists($cName, $this->nestedContext)) { $context = $this->nestedContext[$cName]; if ($context === false) { return false; } elseif (is_object($context)) { return !isset($this->pendingAbstractFactoryRequests[get_class($context).$cName]); } } $this->checkNestedContextStart($cName); $result = false; $this->nestedContext[$cName] = false; foreach ($this->abstractFactories as $abstractFactory) { $pendingKey = get_class($abstractFactory).$cName; if (isset($this->pendingAbstractFactoryRequests[$pendingKey])) { $result = false; break; } if ($abstractFactory->canCreateServiceWithName($this, $cName, $rName)) { $this->nestedContext[$cName] = $abstractFactory; $result = true; break; } } $this->checkNestedContextStop(); return $result; } protected function checkForCircularAliasReference($alias, $nameOrAlias) { $aliases = $this->aliases; $aliases[$alias] = $nameOrAlias; $stack = array(); while (isset($aliases[$alias])) { if (isset($stack[$alias])) { throw new Exception\CircularReferenceException(sprintf( 'The alias definition "%s" : "%s" results in a circular reference: "%s" -> "%s"', $alias, $nameOrAlias, implode('" -> "', $stack), $alias )); } $stack[$alias] = $alias; $alias = $aliases[$alias]; } return $this; } public function setAlias($alias, $nameOrAlias) { if (!is_string($alias) || !is_string($nameOrAlias)) { throw new Exception\InvalidServiceNameException('Service or alias names must be strings.'); } $cAlias = $this->canonicalizeName($alias); $nameOrAlias = $this->canonicalizeName($nameOrAlias); if ($alias == '' || $nameOrAlias == '') { throw new Exception\InvalidServiceNameException('Invalid service name alias'); } if ($this->allowOverride === false && $this->has(array($cAlias, $alias), false)) { throw new Exception\InvalidServiceNameException(sprintf( 'An alias by the name "%s" or "%s" already exists', $cAlias, $alias )); } if ($this->hasAlias($alias)) { $this->checkForCircularAliasReference($cAlias, $nameOrAlias); } $this->aliases[$cAlias] = $nameOrAlias; return $this; } public function hasAlias($alias) { return isset($this->aliases[$this->canonicalizeName($alias)]); } public function createScopedServiceManager($peering = self::SCOPE_PARENT) { $scopedServiceManager = new ServiceManager(); if ($peering == self::SCOPE_PARENT) { $scopedServiceManager->peeringServiceManagers[] = $this; } if ($peering == self::SCOPE_CHILD) { $this->peeringServiceManagers[] = $scopedServiceManager; } return $scopedServiceManager; } public function addPeeringServiceManager(ServiceManager $manager, $peering = self::SCOPE_PARENT) { if ($peering == self::SCOPE_PARENT) { $this->peeringServiceManagers[] = $manager; } if ($peering == self::SCOPE_CHILD) { $manager->peeringServiceManagers[] = $this; } return $this; } protected function canonicalizeName($name) { if (isset($this->canonicalNames[$name])) { return $this->canonicalNames[$name]; } return $this->canonicalNames[$name] = strtolower(strtr($name, $this->canonicalNamesReplacements)); } protected function createServiceViaCallback($callable, $cName, $rName) { static $circularDependencyResolver = array(); $depKey = spl_object_hash($this) . '-' . $cName; if (isset($circularDependencyResolver[$depKey])) { $circularDependencyResolver = array(); throw new Exception\CircularDependencyFoundException('Circular dependency for LazyServiceLoader was found for instance ' . $rName); } try { $circularDependencyResolver[$depKey] = true; $instance = call_user_func($callable, $this, $cName, $rName); unset($circularDependencyResolver[$depKey]); } catch (Exception\ServiceNotFoundException $e) { unset($circularDependencyResolver[$depKey]); throw $e; } catch (\Exception $e) { unset($circularDependencyResolver[$depKey]); throw new Exception\ServiceNotCreatedException( sprintf('An exception was raised while creating "%s"; no instance returned', $rName), $e->getCode(), $e ); } if ($instance === null) { throw new Exception\ServiceNotCreatedException('The factory was called but did not return an instance.'); } return $instance; } public function getRegisteredServices() { return array( 'invokableClasses' => array_keys($this->invokableClasses), 'factories' => array_keys($this->factories), 'aliases' => array_keys($this->aliases), 'instances' => array_keys($this->instances), ); } public function getCanonicalNames() { return $this->canonicalNames; } public function setCanonicalNames($canonicalNames) { $this->canonicalNames = $canonicalNames; return $this; } protected function retrieveFromPeeringManager($name) { foreach ($this->peeringServiceManagers as $peeringServiceManager) { if ($peeringServiceManager->has($name)) { return $peeringServiceManager->get($name); } } $name = $this->canonicalizeName($name); if ($this->hasAlias($name)) { do { $name = $this->aliases[$name]; } while ($this->hasAlias($name)); } foreach ($this->peeringServiceManagers as $peeringServiceManager) { if ($peeringServiceManager->has($name)) { return $peeringServiceManager->get($name); } } return null; } protected function createFromInvokable($canonicalName, $requestedName) { $invokable = $this->invokableClasses[$canonicalName]; if (!class_exists($invokable)) { throw new Exception\ServiceNotFoundException(sprintf( '%s: failed retrieving "%s%s" via invokable class "%s"; class does not exist', get_class($this) . '::' . __FUNCTION__, $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : ''), $invokable )); } $instance = new $invokable; return $instance; } protected function createFromFactory($canonicalName, $requestedName) { $factory = $this->factories[$canonicalName]; if (is_string($factory) && class_exists($factory, true)) { $factory = new $factory; $this->factories[$canonicalName] = $factory; } if ($factory instanceof FactoryInterface) { $instance = $this->createServiceViaCallback(array($factory, 'createService'), $canonicalName, $requestedName); } elseif (is_callable($factory)) { $instance = $this->createServiceViaCallback($factory, $canonicalName, $requestedName); } else { throw new Exception\ServiceNotCreatedException(sprintf( 'While attempting to create %s%s an invalid factory was registered for this instance type.', $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : '') )); } return $instance; } protected function createFromAbstractFactory($canonicalName, $requestedName) { if (isset($this->nestedContext[$canonicalName])) { $abstractFactory = $this->nestedContext[$canonicalName]; $pendingKey = get_class($abstractFactory).$canonicalName; try { $this->pendingAbstractFactoryRequests[$pendingKey] = true; $instance = $this->createServiceViaCallback( array($abstractFactory, 'createServiceWithName'), $canonicalName, $requestedName ); unset($this->pendingAbstractFactoryRequests[$pendingKey]); return $instance; } catch (\Exception $e) { unset($this->pendingAbstractFactoryRequests[$pendingKey]); $this->checkNestedContextStop(true); throw new Exception\ServiceNotCreatedException( sprintf( 'An abstract factory could not create an instance of %s%s.', $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : '') ), $e->getCode(), $e ); } } return null; } protected function checkNestedContextStart($cName) { if ($this->nestedContextCounter === -1 || !isset($this->nestedContext[$cName])) { $this->nestedContext[$cName] = null; } $this->nestedContextCounter++; return $this; } protected function checkNestedContextStop($force = false) { if ($force) { $this->nestedContextCounter = -1; $this->nestedContext = array(); return $this; } $this->nestedContextCounter--; if ($this->nestedContextCounter === -1) { $this->nestedContext = array(); } return $this; } protected function createDelegatorFromFactory($canonicalName, $requestedName) { $serviceManager = $this; $delegatorsCount = count($this->delegators[$canonicalName]); $creationCallback = function () use ($serviceManager, $requestedName, $canonicalName) { return $serviceManager->doCreate($requestedName, $canonicalName); }; for ($i = 0; $i < $delegatorsCount; $i += 1) { $delegatorFactory = $this->delegators[$canonicalName][$i]; if (is_string($delegatorFactory)) { $delegatorFactory = !$this->has($delegatorFactory) && class_exists($delegatorFactory, true) ? new $delegatorFactory : $this->get($delegatorFactory); $this->delegators[$canonicalName][$i] = $delegatorFactory; } if (!$delegatorFactory instanceof DelegatorFactoryInterface && !is_callable($delegatorFactory)) { throw new Exception\ServiceNotCreatedException(sprintf( 'While attempting to create %s%s an invalid factory was registered for this instance type.', $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : '') )); } $creationCallback = $this->createDelegatorCallback( $delegatorFactory, $requestedName, $canonicalName, $creationCallback ); } return $creationCallback($serviceManager, $canonicalName, $requestedName, $creationCallback); } protected static function isSubclassOf($className, $type) { if (is_subclass_of($className, $type)) { return true; } if (PHP_VERSION_ID >= 50307) { return false; } if (!interface_exists($type)) { return false; } $r = new ReflectionClass($className); return $r->implementsInterface($type); } protected function unregisterService($canonical) { $types = array('invokableClasses', 'factories', 'aliases'); foreach ($types as $type) { if (isset($this->{$type}[$canonical])) { unset($this->{$type}[$canonical]); break; } } if (isset($this->instances[$canonical])) { unset($this->instances[$canonical]); } if (isset($this->shared[$canonical])) { unset($this->shared[$canonical]); } } } } namespace Zend\ServiceManager { class Config implements ConfigInterface { protected $config = array(); public function __construct($config = array()) { $this->config = $config; } public function getAllowOverride() { return (isset($this->config['allow_override'])) ? $this->config['allow_override'] : null; } public function getFactories() { return (isset($this->config['factories'])) ? $this->config['factories'] : array(); } public function getAbstractFactories() { return (isset($this->config['abstract_factories'])) ? $this->config['abstract_factories'] : array(); } public function getInvokables() { return (isset($this->config['invokables'])) ? $this->config['invokables'] : array(); } public function getServices() { return (isset($this->config['services'])) ? $this->config['services'] : array(); } public function getAliases() { return (isset($this->config['aliases'])) ? $this->config['aliases'] : array(); } public function getInitializers() { return (isset($this->config['initializers'])) ? $this->config['initializers'] : array(); } public function getShared() { return (isset($this->config['shared'])) ? $this->config['shared'] : array(); } public function getDelegators() { return (isset($this->config['delegators'])) ? $this->config['delegators'] : array(); } public function configureServiceManager(ServiceManager $serviceManager) { if (($allowOverride = $this->getAllowOverride()) !== null) { $serviceManager->setAllowOverride($allowOverride); } foreach ($this->getFactories() as $name => $factory) { $serviceManager->setFactory($name, $factory); } foreach ($this->getAbstractFactories() as $factory) { $serviceManager->addAbstractFactory($factory); } foreach ($this->getInvokables() as $name => $invokable) { $serviceManager->setInvokableClass($name, $invokable); } foreach ($this->getServices() as $name => $service) { $serviceManager->setService($name, $service); } foreach ($this->getAliases() as $alias => $nameOrAlias) { $serviceManager->setAlias($alias, $nameOrAlias); } foreach ($this->getInitializers() as $initializer) { $serviceManager->addInitializer($initializer); } foreach ($this->getShared() as $name => $isShared) { $serviceManager->setShared($name, $isShared); } foreach ($this->getDelegators() as $originalServiceName => $delegators) { foreach ($delegators as $delegator) { $serviceManager->addDelegator($originalServiceName, $delegator); } } } } } namespace Zend\Mvc\Service { use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\ServiceManager\Config; use Zend\ServiceManager\ServiceLocatorAwareInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\ServiceManager\ServiceManager; use Zend\ServiceManager\ServiceManagerAwareInterface; use Zend\Stdlib\ArrayUtils; class ServiceManagerConfig extends Config { protected $invokables = array( 'SharedEventManager' => 'Zend\EventManager\SharedEventManager', ); protected $factories = array( 'EventManager' => 'Zend\Mvc\Service\EventManagerFactory', 'ModuleManager' => 'Zend\Mvc\Service\ModuleManagerFactory', ); protected $abstractFactories = array(); protected $aliases = array( 'Zend\EventManager\EventManagerInterface' => 'EventManager', 'Zend\ServiceManager\ServiceLocatorInterface' => 'ServiceManager', 'Zend\ServiceManager\ServiceManager' => 'ServiceManager', ); protected $shared = array( 'EventManager' => false, ); protected $delegators = array(); protected $initializers = array(); public function __construct(array $configuration = array()) { $this->initializers = array( 'EventManagerAwareInitializer' => function ($instance, ServiceLocatorInterface $serviceLocator) { if ($instance instanceof EventManagerAwareInterface) { $eventManager = $instance->getEventManager(); if ($eventManager instanceof EventManagerInterface) { $eventManager->setSharedManager($serviceLocator->get('SharedEventManager')); } else { $instance->setEventManager($serviceLocator->get('EventManager')); } } }, 'ServiceManagerAwareInitializer' => function ($instance, ServiceLocatorInterface $serviceLocator) { if ($serviceLocator instanceof ServiceManager && $instance instanceof ServiceManagerAwareInterface) { $instance->setServiceManager($serviceLocator); } }, 'ServiceLocatorAwareInitializer' => function ($instance, ServiceLocatorInterface $serviceLocator) { if ($instance instanceof ServiceLocatorAwareInterface) { $instance->setServiceLocator($serviceLocator); } }, ); $this->factories['ServiceManager'] = function (ServiceLocatorInterface $serviceLocator) { return $serviceLocator; }; parent::__construct(ArrayUtils::merge( array( 'invokables' => $this->invokables, 'factories' => $this->factories, 'abstract_factories' => $this->abstractFactories, 'aliases' => $this->aliases, 'shared' => $this->shared, 'delegators' => $this->delegators, 'initializers' => $this->initializers, ), $configuration )); } } } namespace Zend\Mvc\Service { use Zend\ModuleManager\Listener\DefaultListenerAggregate; use Zend\ModuleManager\Listener\ListenerOptions; use Zend\ModuleManager\ModuleEvent; use Zend\ModuleManager\ModuleManager; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ModuleManagerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { if (!$serviceLocator->has('ServiceListener')) { $serviceLocator->setFactory('ServiceListener', 'Zend\Mvc\Service\ServiceListenerFactory'); } $configuration = $serviceLocator->get('ApplicationConfig'); $listenerOptions = new ListenerOptions($configuration['module_listener_options']); $defaultListeners = new DefaultListenerAggregate($listenerOptions); $serviceListener = $serviceLocator->get('ServiceListener'); $serviceListener->addServiceManager( $serviceLocator, 'service_manager', 'Zend\ModuleManager\Feature\ServiceProviderInterface', 'getServiceConfig' ); $serviceListener->addServiceManager( 'ControllerLoader', 'controllers', 'Zend\ModuleManager\Feature\ControllerProviderInterface', 'getControllerConfig' ); $serviceListener->addServiceManager( 'ControllerPluginManager', 'controller_plugins', 'Zend\ModuleManager\Feature\ControllerPluginProviderInterface', 'getControllerPluginConfig' ); $serviceListener->addServiceManager( 'ViewHelperManager', 'view_helpers', 'Zend\ModuleManager\Feature\ViewHelperProviderInterface', 'getViewHelperConfig' ); $serviceListener->addServiceManager( 'ValidatorManager', 'validators', 'Zend\ModuleManager\Feature\ValidatorProviderInterface', 'getValidatorConfig' ); $serviceListener->addServiceManager( 'FilterManager', 'filters', 'Zend\ModuleManager\Feature\FilterProviderInterface', 'getFilterConfig' ); $serviceListener->addServiceManager( 'FormElementManager', 'form_elements', 'Zend\ModuleManager\Feature\FormElementProviderInterface', 'getFormElementConfig' ); $serviceListener->addServiceManager( 'RoutePluginManager', 'route_manager', 'Zend\ModuleManager\Feature\RouteProviderInterface', 'getRouteConfig' ); $serviceListener->addServiceManager( 'SerializerAdapterManager', 'serializers', 'Zend\ModuleManager\Feature\SerializerProviderInterface', 'getSerializerConfig' ); $serviceListener->addServiceManager( 'HydratorManager', 'hydrators', 'Zend\ModuleManager\Feature\HydratorProviderInterface', 'getHydratorConfig' ); $serviceListener->addServiceManager( 'InputFilterManager', 'input_filters', 'Zend\ModuleManager\Feature\InputFilterProviderInterface', 'getInputFilterConfig' ); $serviceListener->addServiceManager( 'LogProcessorManager', 'log_processors', 'Zend\ModuleManager\Feature\LogProcessorProviderInterface', 'getLogProcessorConfig' ); $serviceListener->addServiceManager( 'LogWriterManager', 'log_writers', 'Zend\ModuleManager\Feature\LogWriterProviderInterface', 'getLogWriterConfig' ); $events = $serviceLocator->get('EventManager'); $events->attach($defaultListeners); $events->attach($serviceListener); $moduleEvent = new ModuleEvent; $moduleEvent->setParam('ServiceManager', $serviceLocator); $moduleManager = new ModuleManager($configuration['modules'], $events); $moduleManager->setEvent($moduleEvent); return $moduleManager; } } } namespace Zend\Stdlib { use Traversable; abstract class AbstractOptions implements ParameterObjectInterface { protected $__strictMode__ = true; public function __construct($options = null) { if (null !== $options) { $this->setFromArray($options); } } public function setFromArray($options) { if ($options instanceof self) { $options = $options->toArray(); } if (!is_array($options) && !$options instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Parameter provided to %s must be an %s, %s or %s', __METHOD__, 'array', 'Traversable', 'Zend\Stdlib\AbstractOptions' )); } foreach ($options as $key => $value) { $this->__set($key, $value); } return $this; } public function toArray() { $array = array(); $transform = function ($letters) { $letter = array_shift($letters); return '_' . strtolower($letter); }; foreach ($this as $key => $value) { if ($key === '__strictMode__') continue; $normalizedKey = preg_replace_callback('/([A-Z])/', $transform, $key); $array[$normalizedKey] = $value; } return $array; } public function __set($key, $value) { $setter = 'set' . str_replace(' ', '', ucwords(str_replace('_', ' ', $key))); if ($this->__strictMode__ && !method_exists($this, $setter)) { throw new Exception\BadMethodCallException( 'The option "' . $key . '" does not ' . 'have a matching ' . $setter . ' setter method ' . 'which must be defined' ); } elseif (!$this->__strictMode__ && !method_exists($this, $setter)) { return; } $this->{$setter}($value); } public function __get($key) { $getter = 'get' . str_replace(' ', '', ucwords(str_replace('_', ' ', $key))); if (!method_exists($this, $getter)) { throw new Exception\BadMethodCallException( 'The option "' . $key . '" does not ' . 'have a matching ' . $getter . ' getter method ' . 'which must be defined' ); } return $this->{$getter}(); } public function __isset($key) { return null !== $this->__get($key); } public function __unset($key) { try { $this->__set($key, null); } catch (Exception\BadMethodCallException $e) { throw new Exception\InvalidArgumentException( 'The class property $' . $key . ' cannot be unset as' . ' NULL is an invalid value for it', 0, $e ); } } } } namespace Zend\ModuleManager\Listener { use Traversable; use Zend\Stdlib\AbstractOptions; class ListenerOptions extends AbstractOptions { protected $modulePaths = array(); protected $configGlobPaths = array(); protected $configStaticPaths = array(); protected $extraConfig = array(); protected $configCacheEnabled = false; protected $configCacheKey; protected $cacheDir; protected $checkDependencies = true; protected $moduleMapCacheEnabled = false; protected $moduleMapCacheKey; public function getModulePaths() { return $this->modulePaths; } public function setModulePaths($modulePaths) { if (!is_array($modulePaths) && !$modulePaths instanceof Traversable) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %s::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($modulePaths)) ); } $this->modulePaths = $modulePaths; return $this; } public function getConfigGlobPaths() { return $this->configGlobPaths; } public function getConfigStaticPaths() { return $this->configStaticPaths; } public function setConfigGlobPaths($configGlobPaths) { if (!is_array($configGlobPaths) && !$configGlobPaths instanceof Traversable) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %s::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($configGlobPaths)) ); } $this->configGlobPaths = $configGlobPaths; return $this; } public function setConfigStaticPaths($configStaticPaths) { if (!is_array($configStaticPaths) && !$configStaticPaths instanceof Traversable) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %s::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($configStaticPaths)) ); } $this->configStaticPaths = $configStaticPaths; return $this; } public function getExtraConfig() { return $this->extraConfig; } public function setExtraConfig($extraConfig) { if (!is_array($extraConfig) && !$extraConfig instanceof Traversable) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %s::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($extraConfig)) ); } $this->extraConfig = $extraConfig; return $this; } public function getConfigCacheEnabled() { return $this->configCacheEnabled; } public function setConfigCacheEnabled($enabled) { $this->configCacheEnabled = (bool) $enabled; return $this; } public function getConfigCacheKey() { return (string) $this->configCacheKey; } public function setConfigCacheKey($configCacheKey) { $this->configCacheKey = $configCacheKey; return $this; } public function getConfigCacheFile() { return $this->getCacheDir() . '/module-config-cache.' . $this->getConfigCacheKey().'.php'; } public function getCacheDir() { return $this->cacheDir; } public function setCacheDir($cacheDir) { if (null === $cacheDir) { $this->cacheDir = $cacheDir; } else { $this->cacheDir = static::normalizePath($cacheDir); } return $this; } public function getModuleMapCacheEnabled() { return $this->moduleMapCacheEnabled; } public function setModuleMapCacheEnabled($enabled) { $this->moduleMapCacheEnabled = (bool) $enabled; return $this; } public function getModuleMapCacheKey() { return (string) $this->moduleMapCacheKey; } public function setModuleMapCacheKey($moduleMapCacheKey) { $this->moduleMapCacheKey = $moduleMapCacheKey; return $this; } public function getModuleMapCacheFile() { return $this->getCacheDir() . '/module-classmap-cache.'.$this->getModuleMapCacheKey().'.php'; } public function getCheckDependencies() { return $this->checkDependencies; } public function setCheckDependencies($checkDependencies) { $this->checkDependencies = (bool) $checkDependencies; return $this; } public static function normalizePath($path) { $path = rtrim($path, '/'); $path = rtrim($path, '\\'); return $path; } } } namespace Zend\ModuleManager\Listener { abstract class AbstractListener { protected $options; public function __construct(ListenerOptions $options = null) { if (null === $options) { $this->setOptions(new ListenerOptions); } else { $this->setOptions($options); } } public function getOptions() { return $this->options; } public function setOptions(ListenerOptions $options) { $this->options = $options; return $this; } protected function writeArrayToFile($filePath, $array) { $content = "<?php\nreturn " . var_export($array, 1) . ';'; file_put_contents($filePath, $content); return $this; } } } namespace Zend\ModuleManager\Listener { use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\ModuleManager\ModuleEvent; use Zend\Stdlib\CallbackHandler; class DefaultListenerAggregate extends AbstractListener implements ListenerAggregateInterface { protected $listeners = array(); protected $configListener; public function attach(EventManagerInterface $events) { $options = $this->getOptions(); $configListener = $this->getConfigListener(); $locatorRegistrationListener = new LocatorRegistrationListener($options); $this->listeners[] = $events->attach(new ModuleLoaderListener($options)); $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE_RESOLVE, new ModuleResolverListener); $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, new AutoloaderListener($options), 9000); if ($options->getCheckDependencies()) { $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, new ModuleDependencyCheckerListener, 8000); } $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, new InitTrigger($options)); $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, new OnBootstrapListener($options)); $this->listeners[] = $events->attach($locatorRegistrationListener); $this->listeners[] = $events->attach($configListener); return $this; } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $key => $listener) { $detached = false; if ($listener === $this) { continue; } if ($listener instanceof ListenerAggregateInterface) { $detached = $listener->detach($events); } elseif ($listener instanceof CallbackHandler) { $detached = $events->detach($listener); } if ($detached) { unset($this->listeners[$key]); } } } public function getConfigListener() { if (!$this->configListener instanceof ConfigMergerInterface) { $this->setConfigListener(new ConfigListener($this->getOptions())); } return $this->configListener; } public function setConfigListener(ConfigMergerInterface $configListener) { $this->configListener = $configListener; return $this; } } } namespace Zend\Mvc\Service { use Zend\ModuleManager\Listener\ServiceListener; use Zend\ModuleManager\Listener\ServiceListenerInterface; use Zend\Mvc\Exception\InvalidArgumentException; use Zend\Mvc\Exception\RuntimeException; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ServiceListenerFactory implements FactoryInterface { const MISSING_KEY_ERROR = 'Invalid service listener options detected, %s array must contain %s key.'; const VALUE_TYPE_ERROR = 'Invalid service listener options detected, %s must be a string, %s given.'; protected $defaultServiceConfig = array( 'invokables' => array( 'DispatchListener' => 'Zend\Mvc\DispatchListener', 'RouteListener' => 'Zend\Mvc\RouteListener', 'SendResponseListener' => 'Zend\Mvc\SendResponseListener' ), 'factories' => array( 'Application' => 'Zend\Mvc\Service\ApplicationFactory', 'Config' => 'Zend\Mvc\Service\ConfigFactory', 'ControllerLoader' => 'Zend\Mvc\Service\ControllerLoaderFactory', 'ControllerPluginManager' => 'Zend\Mvc\Service\ControllerPluginManagerFactory', 'ConsoleAdapter' => 'Zend\Mvc\Service\ConsoleAdapterFactory', 'ConsoleRouter' => 'Zend\Mvc\Service\RouterFactory', 'ConsoleViewManager' => 'Zend\Mvc\Service\ConsoleViewManagerFactory', 'DependencyInjector' => 'Zend\Mvc\Service\DiFactory', 'DiAbstractServiceFactory' => 'Zend\Mvc\Service\DiAbstractServiceFactoryFactory', 'DiServiceInitializer' => 'Zend\Mvc\Service\DiServiceInitializerFactory', 'DiStrictAbstractServiceFactory' => 'Zend\Mvc\Service\DiStrictAbstractServiceFactoryFactory', 'FilterManager' => 'Zend\Mvc\Service\FilterManagerFactory', 'FormElementManager' => 'Zend\Mvc\Service\FormElementManagerFactory', 'HttpRouter' => 'Zend\Mvc\Service\RouterFactory', 'HttpViewManager' => 'Zend\Mvc\Service\HttpViewManagerFactory', 'HydratorManager' => 'Zend\Mvc\Service\HydratorManagerFactory', 'InputFilterManager' => 'Zend\Mvc\Service\InputFilterManagerFactory', 'LogProcessorManager' => 'Zend\Mvc\Service\LogProcessorManagerFactory', 'LogWriterManager' => 'Zend\Mvc\Service\LogWriterManagerFactory', 'MvcTranslator' => 'Zend\Mvc\Service\TranslatorServiceFactory', 'PaginatorPluginManager' => 'Zend\Mvc\Service\PaginatorPluginManagerFactory', 'Request' => 'Zend\Mvc\Service\RequestFactory', 'Response' => 'Zend\Mvc\Service\ResponseFactory', 'Router' => 'Zend\Mvc\Service\RouterFactory', 'RoutePluginManager' => 'Zend\Mvc\Service\RoutePluginManagerFactory', 'SerializerAdapterManager' => 'Zend\Mvc\Service\SerializerAdapterPluginManagerFactory', 'ValidatorManager' => 'Zend\Mvc\Service\ValidatorManagerFactory', 'ViewHelperManager' => 'Zend\Mvc\Service\ViewHelperManagerFactory', 'ViewFeedRenderer' => 'Zend\Mvc\Service\ViewFeedRendererFactory', 'ViewFeedStrategy' => 'Zend\Mvc\Service\ViewFeedStrategyFactory', 'ViewJsonRenderer' => 'Zend\Mvc\Service\ViewJsonRendererFactory', 'ViewJsonStrategy' => 'Zend\Mvc\Service\ViewJsonStrategyFactory', 'ViewManager' => 'Zend\Mvc\Service\ViewManagerFactory', 'ViewResolver' => 'Zend\Mvc\Service\ViewResolverFactory', 'ViewTemplateMapResolver' => 'Zend\Mvc\Service\ViewTemplateMapResolverFactory', 'ViewTemplatePathStack' => 'Zend\Mvc\Service\ViewTemplatePathStackFactory', ), 'aliases' => array( 'Configuration' => 'Config', 'Console' => 'ConsoleAdapter', 'Di' => 'DependencyInjector', 'Zend\Di\LocatorInterface' => 'DependencyInjector', 'Zend\Mvc\Controller\PluginManager' => 'ControllerPluginManager', 'Zend\View\Resolver\TemplateMapResolver' => 'ViewTemplateMapResolver', 'Zend\View\Resolver\TemplatePathStack' => 'ViewTemplatePathStack', 'Zend\View\Resolver\AggregateResolver' => 'ViewResolver', 'Zend\View\Resolver\ResolverInterface' => 'ViewResolver', 'ControllerManager' => 'ControllerLoader' ), 'abstract_factories' => array( 'Zend\Form\FormAbstractServiceFactory', ), ); public function createService(ServiceLocatorInterface $serviceLocator) { $configuration = $serviceLocator->get('ApplicationConfig'); if ($serviceLocator->has('ServiceListenerInterface')) { $serviceListener = $serviceLocator->get('ServiceListenerInterface'); if (!$serviceListener instanceof ServiceListenerInterface) { throw new RuntimeException( 'The service named ServiceListenerInterface must implement ' . 'Zend\ModuleManager\Listener\ServiceListenerInterface' ); } $serviceListener->setDefaultServiceConfig($this->defaultServiceConfig); } else { $serviceListener = new ServiceListener($serviceLocator, $this->defaultServiceConfig); } if (isset($configuration['service_listener_options'])) { if (!is_array($configuration['service_listener_options'])) { throw new InvalidArgumentException(sprintf( 'The value of service_listener_options must be an array, %s given.', gettype($configuration['service_listener_options']) )); } foreach ($configuration['service_listener_options'] as $key => $newServiceManager) { if (!isset($newServiceManager['service_manager'])) { throw new InvalidArgumentException(sprintf(self::MISSING_KEY_ERROR, $key, 'service_manager')); } elseif (!is_string($newServiceManager['service_manager'])) { throw new InvalidArgumentException(sprintf( self::VALUE_TYPE_ERROR, 'service_manager', gettype($newServiceManager['service_manager']) )); } if (!isset($newServiceManager['config_key'])) { throw new InvalidArgumentException(sprintf(self::MISSING_KEY_ERROR, $key, 'config_key')); } elseif (!is_string($newServiceManager['config_key'])) { throw new InvalidArgumentException(sprintf( self::VALUE_TYPE_ERROR, 'config_key', gettype($newServiceManager['config_key']) )); } if (!isset($newServiceManager['interface'])) { throw new InvalidArgumentException(sprintf(self::MISSING_KEY_ERROR, $key, 'interface')); } elseif (!is_string($newServiceManager['interface'])) { throw new InvalidArgumentException(sprintf( self::VALUE_TYPE_ERROR, 'interface', gettype($newServiceManager['interface']) )); } if (!isset($newServiceManager['method'])) { throw new InvalidArgumentException(sprintf(self::MISSING_KEY_ERROR, $key, 'method')); } elseif (!is_string($newServiceManager['method'])) { throw new InvalidArgumentException(sprintf( self::VALUE_TYPE_ERROR, 'method', gettype($newServiceManager['method']) )); } $serviceListener->addServiceManager( $newServiceManager['service_manager'], $newServiceManager['config_key'], $newServiceManager['interface'], $newServiceManager['method'] ); } } return $serviceListener; } } } namespace Zend\ModuleManager\Listener { use Traversable; use Zend\EventManager\EventManagerInterface; use Zend\ModuleManager\ModuleEvent; use Zend\ServiceManager\Config as ServiceConfig; use Zend\ServiceManager\ServiceManager; use Zend\Stdlib\ArrayUtils; class ServiceListener implements ServiceListenerInterface { protected $listeners = array(); protected $defaultServiceManager; protected $defaultServiceConfig; protected $serviceManagers = array(); public function __construct(ServiceManager $serviceManager, $configuration = null) { $this->defaultServiceManager = $serviceManager; if ($configuration !== null) { $this->setDefaultServiceConfig($configuration); } } public function setDefaultServiceConfig($configuration) { $this->defaultServiceConfig = $configuration; return $this; } public function addServiceManager($serviceManager, $key, $moduleInterface, $method) { if (is_string($serviceManager)) { $smKey = $serviceManager; } elseif ($serviceManager instanceof ServiceManager) { $smKey = spl_object_hash($serviceManager); } else { throw new Exception\RuntimeException(sprintf( 'Invalid service manager provided, expected ServiceManager or string, %s provided', (string) $serviceManager )); } $this->serviceManagers[$smKey] = array( 'service_manager' => $serviceManager, 'config_key' => $key, 'module_class_interface' => $moduleInterface, 'module_class_method' => $method, 'configuration' => array(), ); if ($key === 'service_manager' && $this->defaultServiceConfig) { $this->serviceManagers[$smKey]['configuration']['default_config'] = $this->defaultServiceConfig; } return $this; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, array($this, 'onLoadModule')); $this->listeners[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULES_POST, array($this, 'onLoadModulesPost')); return $this; } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $key => $listener) { if ($events->detach($listener)) { unset($this->listeners[$key]); } } } public function onLoadModule(ModuleEvent $e) { $module = $e->getModule(); foreach ($this->serviceManagers as $key => $sm) { if (!$module instanceof $sm['module_class_interface'] && !method_exists($module, $sm['module_class_method']) ) { continue; } $config = $module->{$sm['module_class_method']}(); if ($config instanceof ServiceConfig) { $config = $this->serviceConfigToArray($config); } if ($config instanceof Traversable) { $config = ArrayUtils::iteratorToArray($config); } if (!is_array($config)) { continue; } $fullname = $e->getModuleName() . '::' . $sm['module_class_method'] . '()'; $this->serviceManagers[$key]['configuration'][$fullname] = $config; } } public function onLoadModulesPost(ModuleEvent $e) { $configListener = $e->getConfigListener(); $config = $configListener->getMergedConfig(false); foreach ($this->serviceManagers as $key => $sm) { if (isset($config[$sm['config_key']]) && is_array($config[$sm['config_key']]) && !empty($config[$sm['config_key']]) ) { $this->serviceManagers[$key]['configuration']['merged_config'] = $config[$sm['config_key']]; } $smConfig = array(); foreach ($this->serviceManagers[$key]['configuration'] as $configs) { if (isset($configs['configuration_classes'])) { foreach ($configs['configuration_classes'] as $class) { $configs = ArrayUtils::merge($configs, $this->serviceConfigToArray($class)); } } $smConfig = ArrayUtils::merge($smConfig, $configs); } if (!$sm['service_manager'] instanceof ServiceManager) { $instance = $this->defaultServiceManager->get($sm['service_manager']); if (!$instance instanceof ServiceManager) { throw new Exception\RuntimeException(sprintf( 'Could not find a valid ServiceManager for %s', $sm['service_manager'] )); } $sm['service_manager'] = $instance; } $serviceConfig = new ServiceConfig($smConfig); $serviceConfig->configureServiceManager($sm['service_manager']); } } protected function serviceConfigToArray($config) { if (is_string($config) && class_exists($config)) { $class = $config; $config = new $class; } if (!$config instanceof ServiceConfig) { throw new Exception\RuntimeException(sprintf( 'Invalid service manager configuration class provided; received "%s", expected an instance of Zend\ServiceManager\Config', (is_object($config) ? get_class($config) : (is_scalar($config) ? $config : gettype($config))) )); } return array( 'abstract_factories' => $config->getAbstractFactories(), 'aliases' => $config->getAliases(), 'initializers' => $config->getInitializers(), 'factories' => $config->getFactories(), 'invokables' => $config->getInvokables(), 'services' => $config->getServices(), 'shared' => $config->getShared(), ); } } } namespace Zend\Mvc\Service { use Zend\EventManager\EventManager; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class EventManagerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $em = new EventManager(); $em->setSharedManager($serviceLocator->get('SharedEventManager')); return $em; } } } namespace Zend\EventManager { use ArrayAccess; use ArrayObject; use Traversable; use Zend\Stdlib\CallbackHandler; use Zend\Stdlib\PriorityQueue; class EventManager implements EventManagerInterface { protected $events = array(); protected $eventClass = 'Zend\EventManager\Event'; protected $identifiers = array(); protected $sharedManager = null; public function __construct($identifiers = null) { $this->setIdentifiers($identifiers); } public function setEventClass($class) { $this->eventClass = $class; return $this; } public function setSharedManager(SharedEventManagerInterface $sharedEventManager) { $this->sharedManager = $sharedEventManager; StaticEventManager::setInstance($sharedEventManager); return $this; } public function unsetSharedManager() { $this->sharedManager = false; } public function getSharedManager() { if (false === $this->sharedManager || $this->sharedManager instanceof SharedEventManagerInterface ) { return $this->sharedManager; } if (!StaticEventManager::hasInstance()) { return false; } $this->sharedManager = StaticEventManager::getInstance(); return $this->sharedManager; } public function getIdentifiers() { return $this->identifiers; } public function setIdentifiers($identifiers) { if (is_array($identifiers) || $identifiers instanceof Traversable) { $this->identifiers = array_unique((array) $identifiers); } elseif ($identifiers !== null) { $this->identifiers = array($identifiers); } return $this; } public function addIdentifiers($identifiers) { if (is_array($identifiers) || $identifiers instanceof Traversable) { $this->identifiers = array_unique(array_merge($this->identifiers, (array) $identifiers)); } elseif ($identifiers !== null) { $this->identifiers = array_unique(array_merge($this->identifiers, array($identifiers))); } return $this; } public function trigger($event, $target = null, $argv = array(), $callback = null) { if ($event instanceof EventInterface) { $e = $event; $event = $e->getName(); $callback = $target; } elseif ($target instanceof EventInterface) { $e = $target; $e->setName($event); $callback = $argv; } elseif ($argv instanceof EventInterface) { $e = $argv; $e->setName($event); $e->setTarget($target); } else { $e = new $this->eventClass(); $e->setName($event); $e->setTarget($target); $e->setParams($argv); } if ($callback && !is_callable($callback)) { throw new Exception\InvalidCallbackException('Invalid callback provided'); } $e->stopPropagation(false); return $this->triggerListeners($event, $e, $callback); } public function triggerUntil($event, $target, $argv = null, $callback = null) { if ($event instanceof EventInterface) { $e = $event; $event = $e->getName(); $callback = $target; } elseif ($target instanceof EventInterface) { $e = $target; $e->setName($event); $callback = $argv; } elseif ($argv instanceof EventInterface) { $e = $argv; $e->setName($event); $e->setTarget($target); } else { $e = new $this->eventClass(); $e->setName($event); $e->setTarget($target); $e->setParams($argv); } if (!is_callable($callback)) { throw new Exception\InvalidCallbackException('Invalid callback provided'); } $e->stopPropagation(false); return $this->triggerListeners($event, $e, $callback); } public function attach($event, $callback = null, $priority = 1) { if ($event instanceof ListenerAggregateInterface) { return $this->attachAggregate($event, $callback); } if (null === $callback) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects a callback; none provided', __METHOD__ )); } if (is_array($event)) { $listeners = array(); foreach ($event as $name) { $listeners[] = $this->attach($name, $callback, $priority); } return $listeners; } if (empty($this->events[$event])) { $this->events[$event] = new PriorityQueue(); } $listener = new CallbackHandler($callback, array('event' => $event, 'priority' => $priority)); $this->events[$event]->insert($listener, $priority); return $listener; } public function attachAggregate(ListenerAggregateInterface $aggregate, $priority = 1) { return $aggregate->attach($this, $priority); } public function detach($listener) { if ($listener instanceof ListenerAggregateInterface) { return $this->detachAggregate($listener); } if (!$listener instanceof CallbackHandler) { throw new Exception\InvalidArgumentException(sprintf( '%s: expected a ListenerAggregateInterface or CallbackHandler; received "%s"', __METHOD__, (is_object($listener) ? get_class($listener) : gettype($listener)) )); } $event = $listener->getMetadatum('event'); if (!$event || empty($this->events[$event])) { return false; } $return = $this->events[$event]->remove($listener); if (!$return) { return false; } if (!count($this->events[$event])) { unset($this->events[$event]); } return true; } public function detachAggregate(ListenerAggregateInterface $aggregate) { return $aggregate->detach($this); } public function getEvents() { return array_keys($this->events); } public function getListeners($event) { if (!array_key_exists($event, $this->events)) { return new PriorityQueue(); } return $this->events[$event]; } public function clearListeners($event) { if (!empty($this->events[$event])) { unset($this->events[$event]); } } public function prepareArgs(array $args) { return new ArrayObject($args); } protected function triggerListeners($event, EventInterface $e, $callback = null) { $responses = new ResponseCollection; $listeners = $this->getListeners($event); $sharedListeners = $this->getSharedListeners($event); $sharedWildcardListeners = $this->getSharedListeners('*'); $wildcardListeners = $this->getListeners('*'); if (count($sharedListeners) || count($sharedWildcardListeners) || count($wildcardListeners)) { $listeners = clone $listeners; $this->insertListeners($listeners, $sharedListeners); $this->insertListeners($listeners, $sharedWildcardListeners); $this->insertListeners($listeners, $wildcardListeners); } foreach ($listeners as $listener) { $listenerCallback = $listener->getCallback(); $responses->push(call_user_func($listenerCallback, $e)); if ($e->propagationIsStopped()) { $responses->setStopped(true); break; } if ($callback && call_user_func($callback, $responses->last())) { $responses->setStopped(true); break; } } return $responses; } protected function getSharedListeners($event) { if (!$sharedManager = $this->getSharedManager()) { return array(); } $identifiers = $this->getIdentifiers(); if (!in_array('*', $identifiers)) { $identifiers[] = '*'; } $sharedListeners = array(); foreach ($identifiers as $id) { if (!$listeners = $sharedManager->getListeners($id, $event)) { continue; } if (!is_array($listeners) && !($listeners instanceof Traversable)) { continue; } foreach ($listeners as $listener) { if (!$listener instanceof CallbackHandler) { continue; } $sharedListeners[] = $listener; } } return $sharedListeners; } protected function insertListeners($masterListeners, $listeners) { foreach ($listeners as $listener) { $priority = $listener->getMetadatum('priority'); if (null === $priority) { $priority = 1; } elseif (is_array($priority)) { $priority = array_shift($priority); } $masterListeners->insert($listener, $priority); } } } } namespace Zend\EventManager { use Zend\Stdlib\CallbackHandler; use Zend\Stdlib\PriorityQueue; class SharedEventManager implements SharedEventAggregateAwareInterface, SharedEventManagerInterface { protected $identifiers = array(); public function attach($id, $event, $callback, $priority = 1) { $ids = (array) $id; $listeners = array(); foreach ($ids as $id) { if (!array_key_exists($id, $this->identifiers)) { $this->identifiers[$id] = new EventManager($id); } $listeners[] = $this->identifiers[$id]->attach($event, $callback, $priority); } if (count($listeners) > 1) { return $listeners; } return $listeners[0]; } public function attachAggregate(SharedListenerAggregateInterface $aggregate, $priority = 1) { return $aggregate->attachShared($this, $priority); } public function detach($id, CallbackHandler $listener) { if (!array_key_exists($id, $this->identifiers)) { return false; } return $this->identifiers[$id]->detach($listener); } public function detachAggregate(SharedListenerAggregateInterface $aggregate) { return $aggregate->detachShared($this); } public function getEvents($id) { if (!array_key_exists($id, $this->identifiers)) { if ('*' != $id && array_key_exists('*', $this->identifiers)) { return $this->identifiers['*']->getEvents(); } return false; } return $this->identifiers[$id]->getEvents(); } public function getListeners($id, $event) { if (!array_key_exists($id, $this->identifiers)) { return false; } return $this->identifiers[$id]->getListeners($event); } public function clearListeners($id, $event = null) { if (!array_key_exists($id, $this->identifiers)) { return false; } if (null === $event) { unset($this->identifiers[$id]); return true; } return $this->identifiers[$id]->clearListeners($event); } } } namespace Zend\EventManager { class StaticEventManager extends SharedEventManager { protected static $instance; protected function __construct() { } private function __clone() { } public static function getInstance() { if (null === static::$instance) { static::setInstance(new static()); } return static::$instance; } public static function setInstance(SharedEventManagerInterface $instance) { static::$instance = $instance; } public static function hasInstance() { return (static::$instance instanceof SharedEventManagerInterface); } public static function resetInstance() { static::$instance = null; } } } namespace Zend\ModuleManager\Listener { use Traversable; use Zend\Config\Config; use Zend\Config\Factory as ConfigFactory; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\ModuleManager\Feature\ConfigProviderInterface; use Zend\ModuleManager\ModuleEvent; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\Glob; class ConfigListener extends AbstractListener implements ConfigMergerInterface, ListenerAggregateInterface { const STATIC_PATH = 'static_path'; const GLOB_PATH = 'glob_path'; protected $callbacks = array(); protected $configs = array(); protected $mergedConfig = array(); protected $mergedConfigObject; protected $skipConfig = false; protected $paths = array(); public function __construct(ListenerOptions $options = null) { parent::__construct($options); if ($this->hasCachedConfig()) { $this->skipConfig = true; $this->setMergedConfig($this->getCachedConfig()); } else { $this->addConfigGlobPaths($this->getOptions()->getConfigGlobPaths()); $this->addConfigStaticPaths($this->getOptions()->getConfigStaticPaths()); } } public function attach(EventManagerInterface $events) { $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULES, array($this, 'onloadModulesPre'), 1000); if ($this->skipConfig) { return $this; } $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, array($this, 'onLoadModule')); $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULES, array($this, 'onLoadModules'), -1000); $this->callbacks[] = $events->attach(ModuleEvent::EVENT_MERGE_CONFIG, array($this, 'onMergeConfig'), 1000); return $this; } public function onloadModulesPre(ModuleEvent $e) { $e->setConfigListener($this); return $this; } public function onLoadModule(ModuleEvent $e) { $module = $e->getModule(); if (!$module instanceof ConfigProviderInterface && !is_callable(array($module, 'getConfig')) ) { return $this; } $config = $module->getConfig(); $this->addConfig($e->getModuleName(), $config); return $this; } public function onMergeConfig(ModuleEvent $e) { foreach ($this->paths as $path) { $this->addConfigByPath($path['path'], $path['type']); } $this->mergedConfig = $this->getOptions()->getExtraConfig() ?: array(); foreach ($this->configs as $config) { $this->mergedConfig = ArrayUtils::merge($this->mergedConfig, $config); } return $this; } public function onLoadModules(ModuleEvent $e) { $e->getTarget()->getEventManager()->trigger(ModuleEvent::EVENT_MERGE_CONFIG, $e->getTarget(), $e); if ( $this->getOptions()->getConfigCacheEnabled() && false === $this->skipConfig ) { $configFile = $this->getOptions()->getConfigCacheFile(); $this->writeArrayToFile($configFile, $this->getMergedConfig(false)); } return $this; } public function detach(EventManagerInterface $events) { foreach ($this->callbacks as $index => $callback) { if ($events->detach($callback)) { unset($this->callbacks[$index]); } } } public function getMergedConfig($returnConfigAsObject = true) { if ($returnConfigAsObject === true) { if ($this->mergedConfigObject === null) { $this->mergedConfigObject = new Config($this->mergedConfig); } return $this->mergedConfigObject; } return $this->mergedConfig; } public function setMergedConfig(array $config) { $this->mergedConfig = $config; $this->mergedConfigObject = null; return $this; } public function addConfigGlobPaths($globPaths) { $this->addConfigPaths($globPaths, self::GLOB_PATH); return $this; } public function addConfigGlobPath($globPath) { $this->addConfigPath($globPath, self::GLOB_PATH); return $this; } public function addConfigStaticPaths($staticPaths) { $this->addConfigPaths($staticPaths, self::STATIC_PATH); return $this; } public function addConfigStaticPath($staticPath) { $this->addConfigPath($staticPath, self::STATIC_PATH); return $this; } protected function addConfigPaths($paths, $type) { if ($paths instanceof Traversable) { $paths = ArrayUtils::iteratorToArray($paths); } if (!is_array($paths)) { throw new Exception\InvalidArgumentException( sprintf('Argument passed to %::%s() must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', __CLASS__, __METHOD__, gettype($paths)) ); } foreach ($paths as $path) { $this->addConfigPath($path, $type); } } protected function addConfigPath($path, $type) { if (!is_string($path)) { throw new Exception\InvalidArgumentException( sprintf('Parameter to %s::%s() must be a string; %s given.', __CLASS__, __METHOD__, gettype($path)) ); } $this->paths[] = array('type' => $type, 'path' => $path); return $this; } protected function addConfig($key, $config) { if ($config instanceof Traversable) { $config = ArrayUtils::iteratorToArray($config); } if (!is_array($config)) { throw new Exception\InvalidArgumentException( sprintf('Config being merged must be an array, ' . 'implement the Traversable interface, or be an ' . 'instance of Zend\Config\Config. %s given.', gettype($config)) ); } $this->configs[$key] = $config; return $this; } protected function addConfigByPath($path, $type) { switch ($type) { case self::STATIC_PATH: $this->addConfig($path, ConfigFactory::fromFile($path)); break; case self::GLOB_PATH: foreach (Glob::glob($path, Glob::GLOB_BRACE) as $file) { $this->addConfig($file, ConfigFactory::fromFile($file)); } break; } return $this; } protected function hasCachedConfig() { if (($this->getOptions()->getConfigCacheEnabled()) && (file_exists($this->getOptions()->getConfigCacheFile())) ) { return true; } return false; } protected function getCachedConfig() { return include $this->getOptions()->getConfigCacheFile(); } } } namespace Zend\ModuleManager\Listener { use Zend\EventManager\Event; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\ModuleManager\Feature\LocatorRegisteredInterface; use Zend\ModuleManager\ModuleEvent; use Zend\Mvc\MvcEvent; class LocatorRegistrationListener extends AbstractListener implements ListenerAggregateInterface { protected $modules = array(); protected $callbacks = array(); public function onLoadModule(ModuleEvent $e) { if (!$e->getModule() instanceof LocatorRegisteredInterface) { return; } $this->modules[] = $e->getModule(); } public function onLoadModules(Event $e) { $moduleManager = $e->getTarget(); $events = $moduleManager->getEventManager()->getSharedManager(); if (!$events) { return; } $events->attach('Zend\Mvc\Application', MvcEvent::EVENT_BOOTSTRAP, function ($e) use ($moduleManager) { $moduleClassName = get_class($moduleManager); $moduleClassNameArray = explode('\\', $moduleClassName); $moduleClassNameAlias = end($moduleClassNameArray); $application = $e->getApplication(); $services = $application->getServiceManager(); if (!$services->has($moduleClassName)) { $services->setAlias($moduleClassName, $moduleClassNameAlias); } }, 1000); if (0 === count($this->modules)) { return; } $events->attach('Zend\Mvc\Application', MvcEvent::EVENT_BOOTSTRAP, array($this, 'onBootstrap'), 1000); } public function onBootstrap(Event $e) { $application = $e->getApplication(); $services = $application->getServiceManager(); foreach ($this->modules as $module) { $moduleClassName = get_class($module); if (!$services->has($moduleClassName)) { $services->setService($moduleClassName, $module); } } } public function attach(EventManagerInterface $events) { $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULE, array($this, 'onLoadModule')); $this->callbacks[] = $events->attach(ModuleEvent::EVENT_LOAD_MODULES, array($this, 'onLoadModules'), -1000); return $this; } public function detach(EventManagerInterface $events) { foreach ($this->callbacks as $index => $callback) { if ($events->detach($callback)) { unset($this->callbacks[$index]); } } } } } namespace Zend\ModuleManager\Listener { use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\Loader\ModuleAutoloader; use Zend\ModuleManager\ModuleEvent; class ModuleLoaderListener extends AbstractListener implements ListenerAggregateInterface { protected $moduleLoader; protected $generateCache; protected $callbacks = array(); public function __construct(ListenerOptions $options = null) { parent::__construct($options); $this->generateCache = $this->options->getModuleMapCacheEnabled(); $this->moduleLoader = new ModuleAutoloader($this->options->getModulePaths()); if ($this->hasCachedClassMap()) { $this->generateCache = false; $this->moduleLoader->setModuleClassMap($this->getCachedConfig()); } } public function attach(EventManagerInterface $events) { $this->callbacks[] = $events->attach( ModuleEvent::EVENT_LOAD_MODULES, array($this->moduleLoader, 'register'), 9000 ); if ($this->generateCache) { $this->callbacks[] = $events->attach( ModuleEvent::EVENT_LOAD_MODULES_POST, array($this, 'onLoadModulesPost') ); } } public function detach(EventManagerInterface $events) { foreach ($this->callbacks as $index => $callback) { if ($events->detach($callback)) { unset($this->callbacks[$index]); } } } protected function hasCachedClassMap() { if ( $this->options->getModuleMapCacheEnabled() && file_exists($this->options->getModuleMapCacheFile()) ) { return true; } return false; } protected function getCachedConfig() { return include $this->options->getModuleMapCacheFile(); } public function onLoadModulesPost(ModuleEvent $event) { $this->moduleLoader->unregister(); $this->writeArrayToFile( $this->options->getModuleMapCacheFile(), $this->moduleLoader->getModuleClassMap() ); } } } namespace Zend\EventManager { use ArrayAccess; class Event implements EventInterface { protected $name; protected $target; protected $params = array(); protected $stopPropagation = false; public function __construct($name = null, $target = null, $params = null) { if (null !== $name) { $this->setName($name); } if (null !== $target) { $this->setTarget($target); } if (null !== $params) { $this->setParams($params); } } public function getName() { return $this->name; } public function getTarget() { return $this->target; } public function setParams($params) { if (!is_array($params) && !is_object($params)) { throw new Exception\InvalidArgumentException( sprintf('Event parameters must be an array or object; received "%s"', gettype($params)) ); } $this->params = $params; return $this; } public function getParams() { return $this->params; } public function getParam($name, $default = null) { if (is_array($this->params) || $this->params instanceof ArrayAccess) { if (!isset($this->params[$name])) { return $default; } return $this->params[$name]; } if (!isset($this->params->{$name})) { return $default; } return $this->params->{$name}; } public function setName($name) { $this->name = (string) $name; return $this; } public function setTarget($target) { $this->target = $target; return $this; } public function setParam($name, $value) { if (is_array($this->params) || $this->params instanceof ArrayAccess) { $this->params[$name] = $value; } else { $this->params->{$name} = $value; } return $this; } public function stopPropagation($flag = true) { $this->stopPropagation = (bool) $flag; } public function propagationIsStopped() { return $this->stopPropagation; } } } namespace Zend\ModuleManager { use Zend\EventManager\Event; class ModuleEvent extends Event { const EVENT_MERGE_CONFIG = 'mergeConfig'; const EVENT_LOAD_MODULES = 'loadModules'; const EVENT_LOAD_MODULE_RESOLVE = 'loadModule.resolve'; const EVENT_LOAD_MODULE = 'loadModule'; const EVENT_LOAD_MODULES_POST = 'loadModules.post'; protected $module; protected $moduleName; protected $configListener; public function getModuleName() { return $this->moduleName; } public function setModuleName($moduleName) { if (!is_string($moduleName)) { throw new Exception\InvalidArgumentException(sprintf( '%s expects a string as an argument; %s provided' ,__METHOD__, gettype($moduleName) )); } $this->moduleName = $moduleName; return $this; } public function getModule() { return $this->module; } public function setModule($module) { if (!is_object($module)) { throw new Exception\InvalidArgumentException(sprintf( '%s expects a module object as an argument; %s provided' ,__METHOD__, gettype($module) )); } $this->module = $module; return $this; } public function getConfigListener() { return $this->configListener; } public function setConfigListener(Listener\ConfigMergerInterface $configListener) { $this->setParam('configListener', $configListener); $this->configListener = $configListener; return $this; } } } namespace Zend\Stdlib { use Countable; use IteratorAggregate; use Serializable; class PriorityQueue implements Countable, IteratorAggregate, Serializable { const EXTR_DATA = 0x00000001; const EXTR_PRIORITY = 0x00000002; const EXTR_BOTH = 0x00000003; protected $queueClass = 'Zend\Stdlib\SplPriorityQueue'; protected $items = array(); protected $queue; public function insert($data, $priority = 1) { $priority = (int) $priority; $this->items[] = array( 'data' => $data, 'priority' => $priority, ); $this->getQueue()->insert($data, $priority); return $this; } public function remove($datum) { $found = false; foreach ($this->items as $key => $item) { if ($item['data'] === $datum) { $found = true; break; } } if ($found) { unset($this->items[$key]); $this->queue = null; if (!$this->isEmpty()) { $queue = $this->getQueue(); foreach ($this->items as $item) { $queue->insert($item['data'], $item['priority']); } } return true; } return false; } public function isEmpty() { return (0 === $this->count()); } public function count() { return count($this->items); } public function top() { return $this->getIterator()->top(); } public function extract() { return $this->getQueue()->extract(); } public function getIterator() { $queue = $this->getQueue(); return clone $queue; } public function serialize() { return serialize($this->items); } public function unserialize($data) { foreach (unserialize($data) as $item) { $this->insert($item['data'], $item['priority']); } } public function toArray($flag = self::EXTR_DATA) { switch ($flag) { case self::EXTR_BOTH: return $this->items; break; case self::EXTR_PRIORITY: return array_map(function ($item) { return $item['priority']; }, $this->items); case self::EXTR_DATA: default: return array_map(function ($item) { return $item['data']; }, $this->items); } } public function setInternalQueueClass($class) { $this->queueClass = (string) $class; return $this; } public function contains($datum) { foreach ($this->items as $item) { if ($item['data'] === $datum) { return true; } } return false; } public function hasPriority($priority) { foreach ($this->items as $item) { if ($item['priority'] === $priority) { return true; } } return false; } protected function getQueue() { if (null === $this->queue) { $this->queue = new $this->queueClass(); if (!$this->queue instanceof \SplPriorityQueue) { throw new Exception\DomainException(sprintf( 'PriorityQueue expects an internal queue of type SplPriorityQueue; received "%s"', get_class($this->queue) )); } } return $this->queue; } public function __clone() { if (null !== $this->queue) { $this->queue = clone $this->queue; } } } } namespace Zend\Stdlib { use ReflectionClass; class CallbackHandler { protected $callback; protected $metadata; protected static $isPhp54; public function __construct($callback, array $metadata = array()) { $this->metadata = $metadata; $this->registerCallback($callback); } protected function registerCallback($callback) { if (!is_callable($callback)) { throw new Exception\InvalidCallbackException('Invalid callback provided; not callable'); } $this->callback = $callback; } public function getCallback() { return $this->callback; } public function call(array $args = array()) { $callback = $this->getCallback(); if (!isset(static::$isPhp54)) { static::$isPhp54 = version_compare(PHP_VERSION, '5.4.0rc1', '>='); } $argCount = count($args); if (static::$isPhp54 && is_string($callback)) { $result = $this->validateStringCallbackFor54($callback); if ($result !== true && $argCount <= 3) { $callback = $result; $this->callback = $result; } } switch ($argCount) { case 0: if (static::$isPhp54) { return $callback(); } return call_user_func($callback); case 1: if (static::$isPhp54) { return $callback(array_shift($args)); } return call_user_func($callback, array_shift($args)); case 2: $arg1 = array_shift($args); $arg2 = array_shift($args); if (static::$isPhp54) { return $callback($arg1, $arg2); } return call_user_func($callback, $arg1, $arg2); case 3: $arg1 = array_shift($args); $arg2 = array_shift($args); $arg3 = array_shift($args); if (static::$isPhp54) { return $callback($arg1, $arg2, $arg3); } return call_user_func($callback, $arg1, $arg2, $arg3); default: return call_user_func_array($callback, $args); } } public function __invoke() { return $this->call(func_get_args()); } public function getMetadata() { return $this->metadata; } public function getMetadatum($name) { if (array_key_exists($name, $this->metadata)) { return $this->metadata[$name]; } return null; } protected function validateStringCallbackFor54($callback) { if (!strstr($callback, '::')) { return true; } list($class, $method) = explode('::', $callback, 2); if (!class_exists($class)) { throw new Exception\InvalidCallbackException(sprintf( 'Static method call "%s" refers to a class that does not exist', $callback )); } $r = new ReflectionClass($class); if (!$r->hasMethod($method)) { throw new Exception\InvalidCallbackException(sprintf( 'Static method call "%s" refers to a method that does not exist', $callback )); } $m = $r->getMethod($method); if (!$m->isStatic()) { throw new Exception\InvalidCallbackException(sprintf( 'Static method call "%s" refers to a method that is not static', $callback )); } return array($class, $method); } } } namespace Zend\Stdlib { use Serializable; class SplPriorityQueue extends \SplPriorityQueue implements Serializable { protected $serial = PHP_INT_MAX; public function insert($datum, $priority) { if (!is_array($priority)) { $priority = array($priority, $this->serial--); } parent::insert($datum, $priority); } public function toArray() { $array = array(); foreach (clone $this as $item) { $array[] = $item; } return $array; } public function serialize() { $clone = clone $this; $clone->setExtractFlags(self::EXTR_BOTH); $data = array(); foreach ($clone as $item) { $data[] = $item; } return serialize($data); } public function unserialize($data) { foreach (unserialize($data) as $item) { $this->insert($item['data'], $item['priority']); } } } } namespace Zend\ModuleManager\Listener { use Zend\ModuleManager\ModuleEvent; class ModuleResolverListener extends AbstractListener { public function __invoke(ModuleEvent $e) { $moduleName = $e->getModuleName(); $class = $moduleName . '\Module'; if (!class_exists($class)) { return false; } $module = new $class; return $module; } } } namespace Zend\ModuleManager\Listener { use Zend\Loader\AutoloaderFactory; use Zend\ModuleManager\Feature\AutoloaderProviderInterface; use Zend\ModuleManager\ModuleEvent; class AutoloaderListener extends AbstractListener { public function __invoke(ModuleEvent $e) { $module = $e->getModule(); if (!$module instanceof AutoloaderProviderInterface && !method_exists($module, 'getAutoloaderConfig') ) { return; } $autoloaderConfig = $module->getAutoloaderConfig(); AutoloaderFactory::factory($autoloaderConfig); } } } namespace Zend\ModuleManager\Listener { use Zend\ModuleManager\Exception; use Zend\ModuleManager\Feature\DependencyIndicatorInterface; use Zend\ModuleManager\ModuleEvent; class ModuleDependencyCheckerListener { protected $loaded = array(); public function __invoke(ModuleEvent $e) { $module = $e->getModule(); if ($module instanceof DependencyIndicatorInterface || method_exists($module, 'getModuleDependencies')) { $dependencies = $module->getModuleDependencies(); foreach ($dependencies as $dependencyModule) { if (!isset($this->loaded[$dependencyModule])) { throw new Exception\MissingDependencyModuleException( sprintf( 'Module "%s" depends on module "%s", which was not initialized before it', $e->getModuleName(), $dependencyModule ) ); } } } $this->loaded[$e->getModuleName()] = true; } } } namespace Zend\ModuleManager\Listener { use Zend\ModuleManager\Feature\InitProviderInterface; use Zend\ModuleManager\ModuleEvent; class InitTrigger extends AbstractListener { public function __invoke(ModuleEvent $e) { $module = $e->getModule(); if (!$module instanceof InitProviderInterface && !method_exists($module, 'init') ) { return; } $module->init($e->getTarget()); } } } namespace Zend\ModuleManager\Listener { use Zend\ModuleManager\Feature\BootstrapListenerInterface; use Zend\ModuleManager\ModuleEvent; use Zend\Mvc\MvcEvent; class OnBootstrapListener extends AbstractListener { public function __invoke(ModuleEvent $e) { $module = $e->getModule(); if (!$module instanceof BootstrapListenerInterface && !method_exists($module, 'onBootstrap') ) { return; } $moduleManager = $e->getTarget(); $events = $moduleManager->getEventManager(); $sharedEvents = $events->getSharedManager(); $sharedEvents->attach('Zend\Mvc\Application', MvcEvent::EVENT_BOOTSTRAP, array($module, 'onBootstrap')); } } } namespace Zend\ModuleManager { use Traversable; use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerInterface; class ModuleManager implements ModuleManagerInterface { protected $loadedModules = array(); protected $events; protected $event; protected $loadFinished; protected $modules = array(); protected $modulesAreLoaded = false; public function __construct($modules, EventManagerInterface $eventManager = null) { $this->setModules($modules); if ($eventManager instanceof EventManagerInterface) { $this->setEventManager($eventManager); } } public function onLoadModules() { if (true === $this->modulesAreLoaded) { return $this; } foreach ($this->getModules() as $moduleName => $module) { if (is_object($module)) { if (!is_string($moduleName)) { throw new Exception\RuntimeException(sprintf( 'Module (%s) must have a key identifier.', get_class($module) )); } $module = array($moduleName => $module); } $this->loadModule($module); } $this->modulesAreLoaded = true; } public function loadModules() { if (true === $this->modulesAreLoaded) { return $this; } $this->getEventManager()->trigger(ModuleEvent::EVENT_LOAD_MODULES, $this, $this->getEvent()); $this->getEventManager()->trigger(ModuleEvent::EVENT_LOAD_MODULES_POST, $this, $this->getEvent()); return $this; } public function loadModule($module) { $moduleName = $module; if (is_array($module)) { $moduleName = key($module); $module = current($module); } if (isset($this->loadedModules[$moduleName])) { return $this->loadedModules[$moduleName]; } if (!isset($this->loadFinished)) { $this->loadFinished = 0; } $event = ($this->loadFinished > 0) ? clone $this->getEvent() : $this->getEvent(); $event->setModuleName($moduleName); $this->loadFinished++; if (!is_object($module)) { $module = $this->loadModuleByName($event); } $event->setModule($module); $this->loadedModules[$moduleName] = $module; $this->getEventManager()->trigger(ModuleEvent::EVENT_LOAD_MODULE, $this, $event); $this->loadFinished--; return $module; } protected function loadModuleByName($event) { $result = $this->getEventManager()->trigger(ModuleEvent::EVENT_LOAD_MODULE_RESOLVE, $this, $event, function ($r) { return (is_object($r)); }); $module = $result->last(); if (!is_object($module)) { throw new Exception\RuntimeException(sprintf( 'Module (%s) could not be initialized.', $event->getModuleName() )); } return $module; } public function getLoadedModules($loadModules = false) { if (true === $loadModules) { $this->loadModules(); } return $this->loadedModules; } public function getModule($moduleName) { if (!isset($this->loadedModules[$moduleName])) { return null; } return $this->loadedModules[$moduleName]; } public function getModules() { return $this->modules; } public function setModules($modules) { if (is_array($modules) || $modules instanceof Traversable) { $this->modules = $modules; } else { throw new Exception\InvalidArgumentException(sprintf( 'Parameter to %s\'s %s method must be an array or implement the Traversable interface', __CLASS__, __METHOD__ )); } return $this; } public function getEvent() { if (!$this->event instanceof ModuleEvent) { $this->setEvent(new ModuleEvent); } return $this->event; } public function setEvent(ModuleEvent $event) { $this->event = $event; return $this; } public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers(array( __CLASS__, get_class($this), 'module_manager', )); $this->events = $events; $this->attachDefaultListeners(); return $this; } public function getEventManager() { if (!$this->events instanceof EventManagerInterface) { $this->setEventManager(new EventManager()); } return $this->events; } protected function attachDefaultListeners() { $events = $this->getEventManager(); $events->attach(ModuleEvent::EVENT_LOAD_MODULES, array($this, 'onLoadModules')); } } } namespace Zend\EventManager { use SplStack; class ResponseCollection extends SplStack { protected $stopped = false; public function stopped() { return $this->stopped; } public function setStopped($flag) { $this->stopped = (bool) $flag; return $this; } public function first() { return parent::bottom(); } public function last() { if (count($this) === 0) { return null; } return parent::top(); } public function contains($value) { foreach ($this as $response) { if ($response === $value) { return true; } } return false; } } } namespace Zend\Mvc { use Zend\EventManager\Event; use Zend\Stdlib\RequestInterface as Request; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ModelInterface as Model; use Zend\View\Model\ViewModel; class MvcEvent extends Event { const EVENT_BOOTSTRAP = 'bootstrap'; const EVENT_DISPATCH = 'dispatch'; const EVENT_DISPATCH_ERROR = 'dispatch.error'; const EVENT_FINISH = 'finish'; const EVENT_RENDER = 'render'; const EVENT_RENDER_ERROR = 'render.error'; const EVENT_ROUTE = 'route'; protected $application; protected $request; protected $response; protected $result; protected $router; protected $routeMatch; protected $viewModel; public function setApplication(ApplicationInterface $application) { $this->setParam('application', $application); $this->application = $application; return $this; } public function getApplication() { return $this->application; } public function getRouter() { return $this->router; } public function setRouter(Router\RouteStackInterface $router) { $this->setParam('router', $router); $this->router = $router; return $this; } public function getRouteMatch() { return $this->routeMatch; } public function setRouteMatch(Router\RouteMatch $matches) { $this->setParam('route-match', $matches); $this->routeMatch = $matches; return $this; } public function getRequest() { return $this->request; } public function setRequest(Request $request) { $this->setParam('request', $request); $this->request = $request; return $this; } public function getResponse() { return $this->response; } public function setResponse(Response $response) { $this->setParam('response', $response); $this->response = $response; return $this; } public function setViewModel(Model $viewModel) { $this->viewModel = $viewModel; return $this; } public function getViewModel() { if (null === $this->viewModel) { $this->setViewModel(new ViewModel()); } return $this->viewModel; } public function getResult() { return $this->result; } public function setResult($result) { $this->setParam('__RESULT__', $result); $this->result = $result; return $this; } public function isError() { return (bool) $this->getParam('error', false); } public function setError($message) { $this->setParam('error', $message); return $this; } public function getError() { return $this->getParam('error', ''); } public function getController() { return $this->getParam('controller'); } public function setController($name) { $this->setParam('controller', $name); return $this; } public function getControllerClass() { return $this->getParam('controller-class'); } public function setControllerClass($class) { $this->setParam('controller-class', $class); return $this; } } } namespace Zend\Stdlib { abstract class Glob { const GLOB_MARK = 0x01; const GLOB_NOSORT = 0x02; const GLOB_NOCHECK = 0x04; const GLOB_NOESCAPE = 0x08; const GLOB_BRACE = 0x10; const GLOB_ONLYDIR = 0x20; const GLOB_ERR = 0x40; public static function glob($pattern, $flags = 0, $forceFallback = false) { if (!defined('GLOB_BRACE') || $forceFallback) { return static::fallbackGlob($pattern, $flags); } return static::systemGlob($pattern, $flags); } protected static function systemGlob($pattern, $flags) { if ($flags) { $flagMap = array( self::GLOB_MARK => GLOB_MARK, self::GLOB_NOSORT => GLOB_NOSORT, self::GLOB_NOCHECK => GLOB_NOCHECK, self::GLOB_NOESCAPE => GLOB_NOESCAPE, self::GLOB_BRACE => GLOB_BRACE, self::GLOB_ONLYDIR => GLOB_ONLYDIR, self::GLOB_ERR => GLOB_ERR, ); $globFlags = 0; foreach ($flagMap as $internalFlag => $globFlag) { if ($flags & $internalFlag) { $globFlags |= $globFlag; } } } else { $globFlags = 0; } ErrorHandler::start(); $res = glob($pattern, $globFlags); $err = ErrorHandler::stop(); if ($res === false) { throw new Exception\RuntimeException("glob('{$pattern}', {$globFlags}) failed", 0, $err); } return $res; } protected static function fallbackGlob($pattern, $flags) { if (!$flags & self::GLOB_BRACE) { return static::systemGlob($pattern, $flags); } $flags &= ~self::GLOB_BRACE; $length = strlen($pattern); $paths = array(); if ($flags & self::GLOB_NOESCAPE) { $begin = strpos($pattern, '{'); } else { $begin = 0; while (true) { if ($begin === $length) { $begin = false; break; } elseif ($pattern[$begin] === '\\' && ($begin + 1) < $length) { $begin++; } elseif ($pattern[$begin] === '{') { break; } $begin++; } } if ($begin === false) { return static::systemGlob($pattern, $flags); } $next = static::nextBraceSub($pattern, $begin + 1, $flags); if ($next === null) { return static::systemGlob($pattern, $flags); } $rest = $next; while ($pattern[$rest] !== '}') { $rest = static::nextBraceSub($pattern, $rest + 1, $flags); if ($rest === null) { return static::systemGlob($pattern, $flags); } } $p = $begin + 1; while (true) { $subPattern = substr($pattern, 0, $begin) . substr($pattern, $p, $next - $p) . substr($pattern, $rest + 1); $result = static::fallbackGlob($subPattern, $flags | self::GLOB_BRACE); if ($result) { $paths = array_merge($paths, $result); } if ($pattern[$next] === '}') { break; } $p = $next + 1; $next = static::nextBraceSub($pattern, $p, $flags); } return array_unique($paths); } protected static function nextBraceSub($pattern, $begin, $flags) { $length = strlen($pattern); $depth = 0; $current = $begin; while ($current < $length) { if (!$flags & self::GLOB_NOESCAPE && $pattern[$current] === '\\') { if (++$current === $length) { break; } $current++; } else { if (($pattern[$current] === '}' && $depth-- === 0) || ($pattern[$current] === ',' && $depth === 0)) { break; } elseif ($pattern[$current++] === '{') { $depth++; } } } return ($current < $length ? $current : null); } } } namespace Zend\Stdlib { use ErrorException; abstract class ErrorHandler { protected static $stack = array(); public static function started() { return (bool) static::getNestedLevel(); } public static function getNestedLevel() { return count(static::$stack); } public static function start($errorLevel = \E_WARNING) { if (!static::$stack) { set_error_handler(array(get_called_class(), 'addError'), $errorLevel); } static::$stack[] = null; } public static function stop($throw = false) { $errorException = null; if (static::$stack) { $errorException = array_pop(static::$stack); if (!static::$stack) { restore_error_handler(); } if ($errorException && $throw) { throw $errorException; } } return $errorException; } public static function clean() { if (static::$stack) { restore_error_handler(); } static::$stack = array(); } public static function addError($errno, $errstr = '', $errfile = '', $errline = 0) { $stack = & static::$stack[count(static::$stack) - 1]; $stack = new ErrorException($errstr, 0, $errno, $errfile, $errline, $stack); } } } namespace Zend\Config { use Zend\Stdlib\ArrayUtils; class Factory { public static $readers = null; public static $writers = null; protected static $extensions = array( 'ini' => 'ini', 'json' => 'json', 'xml' => 'xml', 'yaml' => 'yaml', ); protected static $writerExtensions = array( 'php' => 'php', 'ini' => 'ini', 'json' => 'json', 'xml' => 'xml', 'yaml' => 'yaml', ); public static function fromFile($filename, $returnConfigObject = false, $useIncludePath = false) { $filepath = $filename; if (!file_exists($filename)) { if (!$useIncludePath) { throw new Exception\RuntimeException(sprintf( 'Filename "%s" cannot be found relative to the working directory', $filename )); } $fromIncludePath = stream_resolve_include_path($filename); if (!$fromIncludePath) { throw new Exception\RuntimeException(sprintf( 'Filename "%s" cannot be found relative to the working directory or the include_path ("%s")', $filename, get_include_path() )); } $filepath = $fromIncludePath; } $pathinfo = pathinfo($filepath); if (!isset($pathinfo['extension'])) { throw new Exception\RuntimeException(sprintf( 'Filename "%s" is missing an extension and cannot be auto-detected', $filename )); } $extension = strtolower($pathinfo['extension']); if ($extension === 'php') { if (!is_file($filepath) || !is_readable($filepath)) { throw new Exception\RuntimeException(sprintf( "File '%s' doesn't exist or not readable", $filename )); } $config = include $filepath; } elseif (isset(static::$extensions[$extension])) { $reader = static::$extensions[$extension]; if (!$reader instanceof Reader\ReaderInterface) { $reader = static::getReaderPluginManager()->get($reader); static::$extensions[$extension] = $reader; } $config = $reader->fromFile($filepath); } else { throw new Exception\RuntimeException(sprintf( 'Unsupported config file extension: .%s', $pathinfo['extension'] )); } return ($returnConfigObject) ? new Config($config) : $config; } public static function fromFiles(array $files, $returnConfigObject = false, $useIncludePath = false) { $config = array(); foreach ($files as $file) { $config = ArrayUtils::merge($config, static::fromFile($file, false, $useIncludePath)); } return ($returnConfigObject) ? new Config($config) : $config; } public static function toFile($filename, $config) { if ( (is_object($config) && !($config instanceof Config)) || (!is_object($config) && !is_array($config)) ) { throw new Exception\InvalidArgumentException( __METHOD__." \$config should be an array or instance of Zend\\Config\\Config" ); } $extension = substr(strrchr($filename, '.'), 1); $directory = dirname($filename); if (!is_dir($directory)) { throw new Exception\RuntimeException( "Directory '{$directory}' does not exists!" ); } if (!is_writable($directory)) { throw new Exception\RuntimeException( "Cannot write in directory '{$directory}'" ); } if (!isset(static::$writerExtensions[$extension])) { throw new Exception\RuntimeException( "Unsupported config file extension: '.{$extension}' for writing." ); } $writer = static::$writerExtensions[$extension]; if (($writer instanceof Writer\AbstractWriter) === false) { $writer = self::getWriterPluginManager()->get($writer); static::$writerExtensions[$extension] = $writer; } if (is_object($config)) { $config = $config->toArray(); } $content = $writer->processConfig($config); return (bool) (file_put_contents($filename, $content) !== false); } public static function setReaderPluginManager(ReaderPluginManager $readers) { static::$readers = $readers; } public static function getReaderPluginManager() { if (static::$readers === null) { static::$readers = new ReaderPluginManager(); } return static::$readers; } public static function setWriterPluginManager(WriterPluginManager $writers) { static::$writers = $writers; } public static function getWriterPluginManager() { if (static::$writers === null) { static::$writers = new WriterPluginManager(); } return static::$writers; } public static function registerReader($extension, $reader) { $extension = strtolower($extension); if (!is_string($reader) && !$reader instanceof Reader\ReaderInterface) { throw new Exception\InvalidArgumentException(sprintf( 'Reader should be plugin name, class name or ' . 'instance of %s\Reader\ReaderInterface; received "%s"', __NAMESPACE__, (is_object($reader) ? get_class($reader) : gettype($reader)) )); } static::$extensions[$extension] = $reader; } public static function registerWriter($extension, $writer) { $extension = strtolower($extension); if (!is_string($writer) && !$writer instanceof Writer\AbstractWriter) { throw new Exception\InvalidArgumentException(sprintf( 'Writer should be plugin name, class name or ' . 'instance of %s\Writer\AbstractWriter; received "%s"', __NAMESPACE__, (is_object($writer) ? get_class($writer) : gettype($writer)) )); } static::$writerExtensions[$extension] = $writer; } } } namespace Zend\Form { use Zend\InputFilter\InputFilterInterface; use Zend\ServiceManager\AbstractFactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class FormAbstractServiceFactory implements AbstractFactoryInterface { protected $config; protected $configKey = 'forms'; protected $factory; public function canCreateServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName) { $config = $this->getConfig($serviceLocator); if (empty($config)) { return false; } return (isset($config[$requestedName]) && is_array($config[$requestedName]) && !empty($config[$requestedName])); } public function createServiceWithName(ServiceLocatorInterface $serviceLocator, $name, $requestedName) { $config = $this->getConfig($serviceLocator); $config = $config[$requestedName]; $factory = $this->getFormFactory($serviceLocator); $this->marshalInputFilter($config, $serviceLocator, $factory); return $factory->createForm($config); } protected function getConfig(ServiceLocatorInterface $services) { if ($this->config !== null) { return $this->config; } if (!$services->has('Config')) { $this->config = array(); return $this->config; } $config = $services->get('Config'); if (!isset($config[$this->configKey]) || !is_array($config[$this->configKey]) ) { $this->config = array(); return $this->config; } $this->config = $config[$this->configKey]; return $this->config; } protected function getFormFactory(ServiceLocatorInterface $services) { if ($this->factory instanceof Factory) { return $this->factory; } $elements = null; if ($services->has('FormElementManager')) { $elements = $services->get('FormElementManager'); } $this->factory = new Factory($elements); return $this->factory; } protected function marshalInputFilter(array &$config, ServiceLocatorInterface $services, Factory $formFactory) { if (!isset($config['input_filter'])) { return; } if ($config['input_filter'] instanceof InputFilterInterface) { return; } if (is_string($config['input_filter']) && $services->has('InputFilterManager') ) { $inputFilters = $services->get('InputFilterManager'); if ($inputFilters->has($config['input_filter'])) { $config['input_filter'] = $inputFilters->get($config['input_filter']); return; } } $inputFilterFactory = $formFactory->getInputFilterFactory(); $inputFilterFactory->getDefaultFilterChain()->setPluginManager($services->get('FilterManager')); $inputFilterFactory->getDefaultValidatorChain()->setPluginManager($services->get('ValidatorManager')); } } } namespace Zend\Cache\Service { use Zend\Cache\StorageFactory; use Zend\ServiceManager\AbstractFactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class StorageCacheAbstractServiceFactory implements AbstractFactoryInterface { protected $config; protected $configKey = 'caches'; public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { $config = $this->getConfig($services); if (empty($config)) { return false; } return (isset($config[$requestedName]) && is_array($config[$requestedName])); } public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { $config = $this->getConfig($services); $config = $config[$requestedName]; return StorageFactory::factory($config); } protected function getConfig(ServiceLocatorInterface $services) { if ($this->config !== null) { return $this->config; } if (!$services->has('Config')) { $this->config = array(); return $this->config; } $config = $services->get('Config'); if (!isset($config[$this->configKey])) { $this->config = array(); return $this->config; } $this->config = $config[$this->configKey]; return $this->config; } } } namespace Zend\Log { use Zend\ServiceManager\AbstractFactoryInterface; use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ServiceLocatorInterface; class LoggerAbstractServiceFactory implements AbstractFactoryInterface { protected $config; protected $configKey = 'log'; public function canCreateServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { $config = $this->getConfig($services); if (empty($config)) { return false; } return isset($config[$requestedName]); } public function createServiceWithName(ServiceLocatorInterface $services, $name, $requestedName) { $config = $this->getConfig($services); $config = $config[$requestedName]; $this->processConfig($config, $services); return new Logger($config); } protected function getConfig(ServiceLocatorInterface $services) { if ($this->config !== null) { return $this->config; } if (!$services->has('Config')) { $this->config = array(); return $this->config; } $config = $services->get('Config'); if (!isset($config[$this->configKey])) { $this->config = array(); return $this->config; } $this->config = $config[$this->configKey]; return $this->config; } protected function processConfig(&$config, ServiceLocatorInterface $services) { if (isset($config['writer_plugin_manager']) && is_string($config['writer_plugin_manager']) && $services->has($config['writer_plugin_manager']) ) { $config['writer_plugin_manager'] = $services->get($config['writer_plugin_manager']); } if ((!isset($config['writer_plugin_manager']) || ! $config['writer_plugin_manager'] instanceof AbstractPluginManager) && $services->has('LogWriterManager') ) { $config['writer_plugin_manager'] = $services->get('LogWriterManager'); } if (isset($config['processor_plugin_manager']) && is_string($config['processor_plugin_manager']) && $services->has($config['processor_plugin_manager']) ) { $config['processor_plugin_manager'] = $services->get($config['processor_plugin_manager']); } if ((!isset($config['processor_plugin_manager']) || ! $config['processor_plugin_manager'] instanceof AbstractPluginManager) && $services->has('LogProcessorManager') ) { $config['processor_plugin_manager'] = $services->get('LogProcessorManager'); } if (!isset($config['writers'])) { return; } foreach ($config['writers'] as $index => $writerConfig) { if (!isset($writerConfig['options']['db']) || !is_string($writerConfig['options']['db']) ) { continue; } if (!$services->has($writerConfig['options']['db'])) { continue; } $db = $services->get($writerConfig['options']['db']); $config['writers'][$index]['options']['db'] = $db; } } } } namespace Zend\Mvc\Service { use Zend\Mvc\Controller\ControllerManager; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ControllerLoaderFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $controllerLoader = new ControllerManager(); $controllerLoader->setServiceLocator($serviceLocator); $controllerLoader->addPeeringServiceManager($serviceLocator); $config = $serviceLocator->get('Config'); if (isset($config['di']) && isset($config['di']['allowed_controllers']) && $serviceLocator->has('Di')) { $controllerLoader->addAbstractFactory($serviceLocator->get('DiStrictAbstractServiceFactory')); } return $controllerLoader; } } } namespace Zend\ServiceManager { abstract class AbstractPluginManager extends ServiceManager implements ServiceLocatorAwareInterface { protected $allowOverride = true; protected $autoAddInvokableClass = true; protected $creationOptions = null; protected $serviceLocator; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $self = $this; $this->addInitializer(function ($instance) use ($self) { if ($instance instanceof ServiceLocatorAwareInterface) { $instance->setServiceLocator($self); } }); } abstract public function validatePlugin($plugin); public function get($name, $options = array(), $usePeeringServiceManagers = true) { if (!$this->has($name) && $this->autoAddInvokableClass && class_exists($name)) { $this->setInvokableClass($name, $name); } $this->creationOptions = $options; $instance = parent::get($name, $usePeeringServiceManagers); $this->creationOptions = null; $this->validatePlugin($instance); return $instance; } public function setService($name, $service, $shared = true) { if ($service) { $this->validatePlugin($service); } parent::setService($name, $service, $shared); return $this; } public function setServiceLocator(ServiceLocatorInterface $serviceLocator) { $this->serviceLocator = $serviceLocator; return $this; } public function getServiceLocator() { return $this->serviceLocator; } protected function createFromInvokable($canonicalName, $requestedName) { $invokable = $this->invokableClasses[$canonicalName]; if (null === $this->creationOptions || (is_array($this->creationOptions) && empty($this->creationOptions)) ) { $instance = new $invokable(); } else { $instance = new $invokable($this->creationOptions); } return $instance; } protected function createFromFactory($canonicalName, $requestedName) { $factory = $this->factories[$canonicalName]; $hasCreationOptions = !(null === $this->creationOptions || (is_array($this->creationOptions) && empty($this->creationOptions))); if (is_string($factory) && class_exists($factory, true)) { if (!$hasCreationOptions) { $factory = new $factory(); } else { $factory = new $factory($this->creationOptions); } $this->factories[$canonicalName] = $factory; } if ($factory instanceof FactoryInterface) { $instance = $this->createServiceViaCallback(array($factory, 'createService'), $canonicalName, $requestedName); } elseif (is_callable($factory)) { $instance = $this->createServiceViaCallback($factory, $canonicalName, $requestedName); } else { throw new Exception\ServiceNotCreatedException(sprintf( 'While attempting to create %s%s an invalid factory was registered for this instance type.', $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : '') )); } return $instance; } protected function createServiceViaCallback($callable, $cName, $rName) { if (is_object($callable)) { $factory = $callable; } elseif (is_array($callable)) { $factory = reset($callable); } if (isset($factory) && ($factory instanceof MutableCreationOptionsInterface) && is_array($this->creationOptions) && !empty($this->creationOptions) ) { $factory->setCreationOptions($this->creationOptions); } return parent::createServiceViaCallback($callable, $cName, $rName); } } } namespace Zend\Mvc\Controller { use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\Mvc\Exception; use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorAwareInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Stdlib\DispatchableInterface; class ControllerManager extends AbstractPluginManager { protected $autoAddInvokableClass = false; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'injectControllerDependencies'), false); } public function injectControllerDependencies($controller, ServiceLocatorInterface $serviceLocator) { if (!$controller instanceof DispatchableInterface) { return; } $parentLocator = $serviceLocator->getServiceLocator(); if ($controller instanceof ServiceLocatorAwareInterface) { $controller->setServiceLocator($parentLocator->get('Zend\ServiceManager\ServiceLocatorInterface')); } if ($controller instanceof EventManagerAwareInterface) { $events = $controller->getEventManager(); if (!$events instanceof EventManagerInterface) { $controller->setEventManager($parentLocator->get('EventManager')); } else { $events->setSharedManager($parentLocator->get('SharedEventManager')); } } if ($controller instanceof AbstractConsoleController) { $controller->setConsole($parentLocator->get('Console')); } if (method_exists($controller, 'setPluginManager')) { $controller->setPluginManager($parentLocator->get('ControllerPluginManager')); } } public function validatePlugin($plugin) { if ($plugin instanceof DispatchableInterface) { return; } throw new Exception\InvalidControllerException(sprintf( 'Controller of type %s is invalid; must implement Zend\Stdlib\DispatchableInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)) )); } public function has($name, $checkAbstractFactories = true, $usePeeringServiceManagers = false) { return parent::has($name, $checkAbstractFactories, $usePeeringServiceManagers); } public function get($name, $options = array(), $usePeeringServiceManagers = false) { return parent::get($name, $options, $usePeeringServiceManagers); } } } namespace Zend\Mvc\Service { use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ConfigFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $mm = $serviceLocator->get('ModuleManager'); $mm->loadModules(); $moduleParams = $mm->getEvent()->getParams(); $config = $moduleParams['configListener']->getMergedConfig(false); return $config; } } } namespace Zend\Mvc\Service { use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; abstract class AbstractPluginManagerFactory implements FactoryInterface { const PLUGIN_MANAGER_CLASS = 'AbstractPluginManager'; public function createService(ServiceLocatorInterface $serviceLocator) { $pluginManagerClass = static::PLUGIN_MANAGER_CLASS; $plugins = new $pluginManagerClass; $plugins->setServiceLocator($serviceLocator); $configuration = $serviceLocator->get('Config'); if (isset($configuration['di']) && $serviceLocator->has('Di')) { $plugins->addAbstractFactory($serviceLocator->get('DiAbstractServiceFactory')); } return $plugins; } } } namespace Zend\Mvc\Service { class ControllerPluginManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Mvc\Controller\PluginManager'; } } namespace Zend\Mvc\Controller { use Zend\Mvc\Exception; use Zend\ServiceManager\AbstractPluginManager; use Zend\Stdlib\DispatchableInterface; class PluginManager extends AbstractPluginManager { protected $factories = array( 'forward' => 'Zend\Mvc\Controller\Plugin\Service\ForwardFactory', 'identity' => 'Zend\Mvc\Controller\Plugin\Service\IdentityFactory', ); protected $invokableClasses = array( 'acceptableviewmodelselector' => 'Zend\Mvc\Controller\Plugin\AcceptableViewModelSelector', 'filepostredirectget' => 'Zend\Mvc\Controller\Plugin\FilePostRedirectGet', 'flashmessenger' => 'Zend\Mvc\Controller\Plugin\FlashMessenger', 'layout' => 'Zend\Mvc\Controller\Plugin\Layout', 'params' => 'Zend\Mvc\Controller\Plugin\Params', 'postredirectget' => 'Zend\Mvc\Controller\Plugin\PostRedirectGet', 'redirect' => 'Zend\Mvc\Controller\Plugin\Redirect', 'url' => 'Zend\Mvc\Controller\Plugin\Url', ); protected $aliases = array( 'prg' => 'postredirectget', 'fileprg' => 'filepostredirectget', ); protected $controller; public function get($name, $options = array(), $usePeeringServiceManagers = true) { $plugin = parent::get($name, $options, $usePeeringServiceManagers); $this->injectController($plugin); return $plugin; } public function setController(DispatchableInterface $controller) { $this->controller = $controller; return $this; } public function getController() { return $this->controller; } public function injectController($plugin) { if (!is_object($plugin)) { return; } if (!method_exists($plugin, 'setController')) { return; } $controller = $this->getController(); if (!$controller instanceof DispatchableInterface) { return; } $plugin->setController($controller); } public function validatePlugin($plugin) { if ($plugin instanceof Plugin\PluginInterface) { return; } throw new Exception\InvalidPluginException(sprintf( 'Plugin of type %s is invalid; must implement %s\Plugin\PluginInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } } namespace Zend\Mvc\Service { use Zend\Console\Console; use Zend\Mvc\Exception; use Zend\Mvc\Router\RouteMatch; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\View\Helper as ViewHelper; use Zend\View\Helper\HelperInterface as ViewHelperInterface; class ViewHelperManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\View\HelperPluginManager'; protected $defaultHelperMapClasses = array( 'Zend\Form\View\HelperConfig', 'Zend\I18n\View\HelperConfig', 'Zend\Navigation\View\HelperConfig' ); public function createService(ServiceLocatorInterface $serviceLocator) { $plugins = parent::createService($serviceLocator); foreach ($this->defaultHelperMapClasses as $configClass) { if (is_string($configClass) && class_exists($configClass)) { $config = new $configClass; if (!$config instanceof ConfigInterface) { throw new Exception\RuntimeException(sprintf( 'Invalid service manager configuration class provided; received "%s", expected class implementing %s', $configClass, 'Zend\ServiceManager\ConfigInterface' )); } $config->configureServiceManager($plugins); } } $plugins->setFactory('url', function () use ($serviceLocator) { $helper = new ViewHelper\Url; $router = Console::isConsole() ? 'HttpRouter' : 'Router'; $helper->setRouter($serviceLocator->get($router)); $match = $serviceLocator->get('application') ->getMvcEvent() ->getRouteMatch() ; if ($match instanceof RouteMatch) { $helper->setRouteMatch($match); } return $helper; }); $plugins->setFactory('basepath', function () use ($serviceLocator) { $config = $serviceLocator->has('Config') ? $serviceLocator->get('Config') : array(); $basePathHelper = new ViewHelper\BasePath; if (isset($config['view_manager']) && isset($config['view_manager']['base_path'])) { $basePathHelper->setBasePath($config['view_manager']['base_path']); } else { $request = $serviceLocator->get('Request'); if (is_callable(array($request, 'getBasePath'))) { $basePathHelper->setBasePath($request->getBasePath()); } } return $basePathHelper; }); $plugins->setFactory('doctype', function () use ($serviceLocator) { $config = $serviceLocator->has('Config') ? $serviceLocator->get('Config') : array(); $config = isset($config['view_manager']) ? $config['view_manager'] : array(); $doctypeHelper = new ViewHelper\Doctype; if (isset($config['doctype']) && $config['doctype']) { $doctypeHelper->setDoctype($config['doctype']); } return $doctypeHelper; }); return $plugins; } } } namespace Zend\View { use Zend\I18n\Translator\TranslatorAwareInterface; use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; class HelperPluginManager extends AbstractPluginManager { protected $factories = array( 'flashmessenger' => 'Zend\View\Helper\Service\FlashMessengerFactory', 'identity' => 'Zend\View\Helper\Service\IdentityFactory', ); protected $invokableClasses = array( 'basepath' => 'Zend\View\Helper\BasePath', 'cycle' => 'Zend\View\Helper\Cycle', 'declarevars' => 'Zend\View\Helper\DeclareVars', 'doctype' => 'Zend\View\Helper\Doctype', 'escapehtml' => 'Zend\View\Helper\EscapeHtml', 'escapehtmlattr' => 'Zend\View\Helper\EscapeHtmlAttr', 'escapejs' => 'Zend\View\Helper\EscapeJs', 'escapecss' => 'Zend\View\Helper\EscapeCss', 'escapeurl' => 'Zend\View\Helper\EscapeUrl', 'gravatar' => 'Zend\View\Helper\Gravatar', 'headlink' => 'Zend\View\Helper\HeadLink', 'headmeta' => 'Zend\View\Helper\HeadMeta', 'headscript' => 'Zend\View\Helper\HeadScript', 'headstyle' => 'Zend\View\Helper\HeadStyle', 'headtitle' => 'Zend\View\Helper\HeadTitle', 'htmlflash' => 'Zend\View\Helper\HtmlFlash', 'htmllist' => 'Zend\View\Helper\HtmlList', 'htmlobject' => 'Zend\View\Helper\HtmlObject', 'htmlpage' => 'Zend\View\Helper\HtmlPage', 'htmlquicktime' => 'Zend\View\Helper\HtmlQuicktime', 'inlinescript' => 'Zend\View\Helper\InlineScript', 'json' => 'Zend\View\Helper\Json', 'layout' => 'Zend\View\Helper\Layout', 'paginationcontrol' => 'Zend\View\Helper\PaginationControl', 'partialloop' => 'Zend\View\Helper\PartialLoop', 'partial' => 'Zend\View\Helper\Partial', 'placeholder' => 'Zend\View\Helper\Placeholder', 'renderchildmodel' => 'Zend\View\Helper\RenderChildModel', 'rendertoplaceholder' => 'Zend\View\Helper\RenderToPlaceholder', 'serverurl' => 'Zend\View\Helper\ServerUrl', 'url' => 'Zend\View\Helper\Url', 'viewmodel' => 'Zend\View\Helper\ViewModel', ); protected $renderer; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'injectRenderer')) ->addInitializer(array($this, 'injectTranslator')); } public function setRenderer(Renderer\RendererInterface $renderer) { $this->renderer = $renderer; return $this; } public function getRenderer() { return $this->renderer; } public function injectRenderer($helper) { $renderer = $this->getRenderer(); if (null === $renderer) { return; } $helper->setView($renderer); } public function injectTranslator($helper) { if (!$helper instanceof TranslatorAwareInterface) { return; } $locator = $this->getServiceLocator(); if (!$locator) { return; } if ($locator->has('MvcTranslator')) { $helper->setTranslator($locator->get('MvcTranslator')); return; } if ($locator->has('Zend\I18n\Translator\TranslatorInterface')) { $helper->setTranslator($locator->get('Zend\I18n\Translator\TranslatorInterface')); return; } if ($locator->has('Translator')) { $helper->setTranslator($locator->get('Translator')); return; } } public function validatePlugin($plugin) { if ($plugin instanceof Helper\HelperInterface) { return; } throw new Exception\InvalidHelperException(sprintf( 'Plugin of type %s is invalid; must implement %s\Helper\HelperInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } } namespace Zend\Form\View { use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceManager; class HelperConfig implements ConfigInterface { protected $invokables = array( 'form' => 'Zend\Form\View\Helper\Form', 'formbutton' => 'Zend\Form\View\Helper\FormButton', 'formcaptcha' => 'Zend\Form\View\Helper\FormCaptcha', 'captchadumb' => 'Zend\Form\View\Helper\Captcha\Dumb', 'formcaptchadumb' => 'Zend\Form\View\Helper\Captcha\Dumb', 'captchafiglet' => 'Zend\Form\View\Helper\Captcha\Figlet', 'formcaptchafiglet' => 'Zend\Form\View\Helper\Captcha\Figlet', 'captchaimage' => 'Zend\Form\View\Helper\Captcha\Image', 'formcaptchaimage' => 'Zend\Form\View\Helper\Captcha\Image', 'captcharecaptcha' => 'Zend\Form\View\Helper\Captcha\ReCaptcha', 'formcaptcharecaptcha' => 'Zend\Form\View\Helper\Captcha\ReCaptcha', 'formcheckbox' => 'Zend\Form\View\Helper\FormCheckbox', 'formcollection' => 'Zend\Form\View\Helper\FormCollection', 'formcolor' => 'Zend\Form\View\Helper\FormColor', 'formdate' => 'Zend\Form\View\Helper\FormDate', 'formdatetime' => 'Zend\Form\View\Helper\FormDateTime', 'formdatetimelocal' => 'Zend\Form\View\Helper\FormDateTimeLocal', 'formdatetimeselect' => 'Zend\Form\View\Helper\FormDateTimeSelect', 'formdateselect' => 'Zend\Form\View\Helper\FormDateSelect', 'formelement' => 'Zend\Form\View\Helper\FormElement', 'formelementerrors' => 'Zend\Form\View\Helper\FormElementErrors', 'formemail' => 'Zend\Form\View\Helper\FormEmail', 'formfile' => 'Zend\Form\View\Helper\FormFile', 'formfileapcprogress' => 'Zend\Form\View\Helper\File\FormFileApcProgress', 'formfilesessionprogress' => 'Zend\Form\View\Helper\File\FormFileSessionProgress', 'formfileuploadprogress' => 'Zend\Form\View\Helper\File\FormFileUploadProgress', 'formhidden' => 'Zend\Form\View\Helper\FormHidden', 'formimage' => 'Zend\Form\View\Helper\FormImage', 'forminput' => 'Zend\Form\View\Helper\FormInput', 'formlabel' => 'Zend\Form\View\Helper\FormLabel', 'formmonth' => 'Zend\Form\View\Helper\FormMonth', 'formmonthselect' => 'Zend\Form\View\Helper\FormMonthSelect', 'formmulticheckbox' => 'Zend\Form\View\Helper\FormMultiCheckbox', 'formnumber' => 'Zend\Form\View\Helper\FormNumber', 'formpassword' => 'Zend\Form\View\Helper\FormPassword', 'formradio' => 'Zend\Form\View\Helper\FormRadio', 'formrange' => 'Zend\Form\View\Helper\FormRange', 'formreset' => 'Zend\Form\View\Helper\FormReset', 'formrow' => 'Zend\Form\View\Helper\FormRow', 'formsearch' => 'Zend\Form\View\Helper\FormSearch', 'formselect' => 'Zend\Form\View\Helper\FormSelect', 'formsubmit' => 'Zend\Form\View\Helper\FormSubmit', 'formtel' => 'Zend\Form\View\Helper\FormTel', 'formtext' => 'Zend\Form\View\Helper\FormText', 'formtextarea' => 'Zend\Form\View\Helper\FormTextarea', 'formtime' => 'Zend\Form\View\Helper\FormTime', 'formurl' => 'Zend\Form\View\Helper\FormUrl', 'formweek' => 'Zend\Form\View\Helper\FormWeek', ); public function configureServiceManager(ServiceManager $serviceManager) { foreach ($this->invokables as $name => $service) { $serviceManager->setInvokableClass($name, $service); } } } } namespace Zend\I18n\View { use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceManager; class HelperConfig implements ConfigInterface { protected $invokables = array( 'currencyformat' => 'Zend\I18n\View\Helper\CurrencyFormat', 'dateformat' => 'Zend\I18n\View\Helper\DateFormat', 'numberformat' => 'Zend\I18n\View\Helper\NumberFormat', 'plural' => 'Zend\I18n\View\Helper\Plural', 'translate' => 'Zend\I18n\View\Helper\Translate', 'translateplural' => 'Zend\I18n\View\Helper\TranslatePlural', ); public function configureServiceManager(ServiceManager $serviceManager) { foreach ($this->invokables as $name => $service) { $serviceManager->setInvokableClass($name, $service); } } } } namespace Zend\Navigation\View { use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceManager; use Zend\View\HelperPluginManager; class HelperConfig implements ConfigInterface { public function configureServiceManager(ServiceManager $serviceManager) { $serviceManager->setFactory('navigation', function (HelperPluginManager $pm) { $helper = new \Zend\View\Helper\Navigation; $helper->setServiceLocator($pm->getServiceLocator()); $config = $pm->getServiceLocator()->get('config'); if (isset($config['navigation_helpers'])) { $config = new \Zend\ServiceManager\Config($config['navigation_helpers']); $config->configureServiceManager($helper->getPluginManager()); } return $helper; }); } } } namespace Zend\Mvc\Service { class ValidatorManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Validator\ValidatorPluginManager'; } } namespace Zend\Validator { use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; class ValidatorPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'alnum' => 'Zend\I18n\Validator\Alnum', 'alpha' => 'Zend\I18n\Validator\Alpha', 'barcodecode25interleaved' => 'Zend\Validator\Barcode\Code25interleaved', 'barcodecode25' => 'Zend\Validator\Barcode\Code25', 'barcodecode39ext' => 'Zend\Validator\Barcode\Code39ext', 'barcodecode39' => 'Zend\Validator\Barcode\Code39', 'barcodecode93ext' => 'Zend\Validator\Barcode\Code93ext', 'barcodecode93' => 'Zend\Validator\Barcode\Code93', 'barcodeean12' => 'Zend\Validator\Barcode\Ean12', 'barcodeean13' => 'Zend\Validator\Barcode\Ean13', 'barcodeean14' => 'Zend\Validator\Barcode\Ean14', 'barcodeean18' => 'Zend\Validator\Barcode\Ean18', 'barcodeean2' => 'Zend\Validator\Barcode\Ean2', 'barcodeean5' => 'Zend\Validator\Barcode\Ean5', 'barcodeean8' => 'Zend\Validator\Barcode\Ean8', 'barcodegtin12' => 'Zend\Validator\Barcode\Gtin12', 'barcodegtin13' => 'Zend\Validator\Barcode\Gtin13', 'barcodegtin14' => 'Zend\Validator\Barcode\Gtin14', 'barcodeidentcode' => 'Zend\Validator\Barcode\Identcode', 'barcodeintelligentmail' => 'Zend\Validator\Barcode\Intelligentmail', 'barcodeissn' => 'Zend\Validator\Barcode\Issn', 'barcodeitf14' => 'Zend\Validator\Barcode\Itf14', 'barcodeleitcode' => 'Zend\Validator\Barcode\Leitcode', 'barcodeplanet' => 'Zend\Validator\Barcode\Planet', 'barcodepostnet' => 'Zend\Validator\Barcode\Postnet', 'barcoderoyalmail' => 'Zend\Validator\Barcode\Royalmail', 'barcodesscc' => 'Zend\Validator\Barcode\Sscc', 'barcodeupca' => 'Zend\Validator\Barcode\Upca', 'barcodeupce' => 'Zend\Validator\Barcode\Upce', 'barcode' => 'Zend\Validator\Barcode', 'between' => 'Zend\Validator\Between', 'bitwise' => 'Zend\Validator\Bitwise', 'callback' => 'Zend\Validator\Callback', 'creditcard' => 'Zend\Validator\CreditCard', 'csrf' => 'Zend\Validator\Csrf', 'date' => 'Zend\Validator\Date', 'datestep' => 'Zend\Validator\DateStep', 'datetime' => 'Zend\I18n\Validator\DateTime', 'dbnorecordexists' => 'Zend\Validator\Db\NoRecordExists', 'dbrecordexists' => 'Zend\Validator\Db\RecordExists', 'digits' => 'Zend\Validator\Digits', 'emailaddress' => 'Zend\Validator\EmailAddress', 'explode' => 'Zend\Validator\Explode', 'filecount' => 'Zend\Validator\File\Count', 'filecrc32' => 'Zend\Validator\File\Crc32', 'fileexcludeextension' => 'Zend\Validator\File\ExcludeExtension', 'fileexcludemimetype' => 'Zend\Validator\File\ExcludeMimeType', 'fileexists' => 'Zend\Validator\File\Exists', 'fileextension' => 'Zend\Validator\File\Extension', 'filefilessize' => 'Zend\Validator\File\FilesSize', 'filehash' => 'Zend\Validator\File\Hash', 'fileimagesize' => 'Zend\Validator\File\ImageSize', 'fileiscompressed' => 'Zend\Validator\File\IsCompressed', 'fileisimage' => 'Zend\Validator\File\IsImage', 'filemd5' => 'Zend\Validator\File\Md5', 'filemimetype' => 'Zend\Validator\File\MimeType', 'filenotexists' => 'Zend\Validator\File\NotExists', 'filesha1' => 'Zend\Validator\File\Sha1', 'filesize' => 'Zend\Validator\File\Size', 'fileupload' => 'Zend\Validator\File\Upload', 'fileuploadfile' => 'Zend\Validator\File\UploadFile', 'filewordcount' => 'Zend\Validator\File\WordCount', 'float' => 'Zend\I18n\Validator\Float', 'greaterthan' => 'Zend\Validator\GreaterThan', 'hex' => 'Zend\Validator\Hex', 'hostname' => 'Zend\Validator\Hostname', 'iban' => 'Zend\Validator\Iban', 'identical' => 'Zend\Validator\Identical', 'inarray' => 'Zend\Validator\InArray', 'int' => 'Zend\I18n\Validator\Int', 'ip' => 'Zend\Validator\Ip', 'isbn' => 'Zend\Validator\Isbn', 'isinstanceof' => 'Zend\Validator\IsInstanceOf', 'lessthan' => 'Zend\Validator\LessThan', 'notempty' => 'Zend\Validator\NotEmpty', 'phonenumber' => 'Zend\I18n\Validator\PhoneNumber', 'postcode' => 'Zend\I18n\Validator\PostCode', 'regex' => 'Zend\Validator\Regex', 'sitemapchangefreq' => 'Zend\Validator\Sitemap\Changefreq', 'sitemaplastmod' => 'Zend\Validator\Sitemap\Lastmod', 'sitemaploc' => 'Zend\Validator\Sitemap\Loc', 'sitemappriority' => 'Zend\Validator\Sitemap\Priority', 'stringlength' => 'Zend\Validator\StringLength', 'step' => 'Zend\Validator\Step', 'uri' => 'Zend\Validator\Uri', ); protected $shareByDefault = false; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'injectTranslator')); $this->addInitializer(array($this, 'injectValidatorPluginManager')); } public function injectTranslator($validator) { if ($validator instanceof Translator\TranslatorAwareInterface) { $locator = $this->getServiceLocator(); if ($locator && $locator->has('MvcTranslator')) { $validator->setTranslator($locator->get('MvcTranslator')); } } } public function injectValidatorPluginManager($validator) { if ($validator instanceof ValidatorPluginManagerAwareInterface) { $validator->setValidatorPluginManager($this); } } public function validatePlugin($plugin) { if ($plugin instanceof ValidatorInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\ValidatorInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } } namespace Zend\Mvc\Service { class FilterManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Filter\FilterPluginManager'; } } namespace Zend\Filter { use Zend\ServiceManager\AbstractPluginManager; class FilterPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'alnum' => 'Zend\I18n\Filter\Alnum', 'alpha' => 'Zend\I18n\Filter\Alpha', 'basename' => 'Zend\Filter\BaseName', 'boolean' => 'Zend\Filter\Boolean', 'callback' => 'Zend\Filter\Callback', 'compress' => 'Zend\Filter\Compress', 'compressbz2' => 'Zend\Filter\Compress\Bz2', 'compressgz' => 'Zend\Filter\Compress\Gz', 'compresslzf' => 'Zend\Filter\Compress\Lzf', 'compressrar' => 'Zend\Filter\Compress\Rar', 'compresssnappy' => 'Zend\Filter\Compress\Snappy', 'compresstar' => 'Zend\Filter\Compress\Tar', 'compresszip' => 'Zend\Filter\Compress\Zip', 'datetimeformatter' => 'Zend\Filter\DateTimeFormatter', 'decompress' => 'Zend\Filter\Decompress', 'decrypt' => 'Zend\Filter\Decrypt', 'digits' => 'Zend\Filter\Digits', 'dir' => 'Zend\Filter\Dir', 'encrypt' => 'Zend\Filter\Encrypt', 'encryptblockcipher' => 'Zend\Filter\Encrypt\BlockCipher', 'encryptopenssl' => 'Zend\Filter\Encrypt\Openssl', 'filedecrypt' => 'Zend\Filter\File\Decrypt', 'fileencrypt' => 'Zend\Filter\File\Encrypt', 'filelowercase' => 'Zend\Filter\File\LowerCase', 'filerename' => 'Zend\Filter\File\Rename', 'filerenameupload' => 'Zend\Filter\File\RenameUpload', 'fileuppercase' => 'Zend\Filter\File\UpperCase', 'htmlentities' => 'Zend\Filter\HtmlEntities', 'inflector' => 'Zend\Filter\Inflector', 'int' => 'Zend\Filter\Int', 'null' => 'Zend\Filter\Null', 'numberformat' => 'Zend\I18n\Filter\NumberFormat', 'numberparse' => 'Zend\I18n\Filter\NumberParse', 'pregreplace' => 'Zend\Filter\PregReplace', 'realpath' => 'Zend\Filter\RealPath', 'stringtolower' => 'Zend\Filter\StringToLower', 'stringtoupper' => 'Zend\Filter\StringToUpper', 'stringtrim' => 'Zend\Filter\StringTrim', 'stripnewlines' => 'Zend\Filter\StripNewlines', 'striptags' => 'Zend\Filter\StripTags', 'urinormalize' => 'Zend\Filter\UriNormalize', 'wordcamelcasetodash' => 'Zend\Filter\Word\CamelCaseToDash', 'wordcamelcasetoseparator' => 'Zend\Filter\Word\CamelCaseToSeparator', 'wordcamelcasetounderscore' => 'Zend\Filter\Word\CamelCaseToUnderscore', 'worddashtocamelcase' => 'Zend\Filter\Word\DashToCamelCase', 'worddashtoseparator' => 'Zend\Filter\Word\DashToSeparator', 'worddashtounderscore' => 'Zend\Filter\Word\DashToUnderscore', 'wordseparatortocamelcase' => 'Zend\Filter\Word\SeparatorToCamelCase', 'wordseparatortodash' => 'Zend\Filter\Word\SeparatorToDash', 'wordseparatortoseparator' => 'Zend\Filter\Word\SeparatorToSeparator', 'wordunderscoretocamelcase' => 'Zend\Filter\Word\UnderscoreToCamelCase', 'wordunderscoretodash' => 'Zend\Filter\Word\UnderscoreToDash', 'wordunderscoretoseparator' => 'Zend\Filter\Word\UnderscoreToSeparator', ); protected $shareByDefault = false; public function validatePlugin($plugin) { if ($plugin instanceof FilterInterface) { return; } if (is_callable($plugin)) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\FilterInterface or be callable', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } } namespace Zend\Mvc\Service { use Zend\Form\FormElementManager; use Zend\ServiceManager\ServiceLocatorInterface; class FormElementManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Form\FormElementManager'; public function createService(ServiceLocatorInterface $serviceLocator) { $plugins = parent::createService($serviceLocator); $plugins->addPeeringServiceManager($serviceLocator); $plugins->setRetrieveFromPeeringManagerFirst(true); return $plugins; } } } namespace Zend\Form { use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\Exception\ServiceNotCreatedException; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Stdlib\InitializableInterface; class FormElementManager extends AbstractPluginManager { protected $invokableClasses = array( 'button' => 'Zend\Form\Element\Button', 'captcha' => 'Zend\Form\Element\Captcha', 'checkbox' => 'Zend\Form\Element\Checkbox', 'collection' => 'Zend\Form\Element\Collection', 'color' => 'Zend\Form\Element\Color', 'csrf' => 'Zend\Form\Element\Csrf', 'date' => 'Zend\Form\Element\Date', 'dateselect' => 'Zend\Form\Element\DateSelect', 'datetime' => 'Zend\Form\Element\DateTime', 'datetimelocal' => 'Zend\Form\Element\DateTimeLocal', 'datetimeselect' => 'Zend\Form\Element\DateTimeSelect', 'element' => 'Zend\Form\Element', 'email' => 'Zend\Form\Element\Email', 'fieldset' => 'Zend\Form\Fieldset', 'file' => 'Zend\Form\Element\File', 'form' => 'Zend\Form\Form', 'hidden' => 'Zend\Form\Element\Hidden', 'image' => 'Zend\Form\Element\Image', 'month' => 'Zend\Form\Element\Month', 'monthselect' => 'Zend\Form\Element\MonthSelect', 'multicheckbox' => 'Zend\Form\Element\MultiCheckbox', 'number' => 'Zend\Form\Element\Number', 'password' => 'Zend\Form\Element\Password', 'radio' => 'Zend\Form\Element\Radio', 'range' => 'Zend\Form\Element\Range', 'select' => 'Zend\Form\Element\Select', 'submit' => 'Zend\Form\Element\Submit', 'text' => 'Zend\Form\Element\Text', 'textarea' => 'Zend\Form\Element\Textarea', 'time' => 'Zend\Form\Element\Time', 'url' => 'Zend\Form\Element\Url', 'week' => 'Zend\Form\Element\Week', ); protected $shareByDefault = false; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'injectFactory')); $this->addInitializer(array($this, 'callElementInit'), false); } public function injectFactory($element) { if ($element instanceof FormFactoryAwareInterface) { $factory = $element->getFormFactory(); $factory->setFormElementManager($this); if ($this->serviceLocator instanceof ServiceLocatorInterface && $this->serviceLocator->has('InputFilterManager') ) { $inputFilters = $this->serviceLocator->get('InputFilterManager'); $factory->getInputFilterFactory()->setInputFilterManager($inputFilters); } } } public function callElementInit($element) { if ($element instanceof InitializableInterface) { $element->init(); } } public function validatePlugin($plugin) { if ($plugin instanceof ElementInterface) { return; } throw new Exception\InvalidElementException(sprintf( 'Plugin of type %s is invalid; must implement Zend\Form\ElementInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)) )); } public function get($name, $options = array(), $usePeeringServiceManagers = true) { if (is_string($options)) { $options = array('name' => $options); } return parent::get($name, $options, $usePeeringServiceManagers); } protected function createFromInvokable($canonicalName, $requestedName) { $invokable = $this->invokableClasses[$canonicalName]; if (null === $this->creationOptions || (is_array($this->creationOptions) && empty($this->creationOptions)) ) { $instance = new $invokable(); } else { if (isset($this->creationOptions['name'])) { $name = $this->creationOptions['name']; } else { $name = $requestedName; } if (isset($this->creationOptions['options'])) { $options = $this->creationOptions['options']; } else { $options = $this->creationOptions; } $instance = new $invokable($name, $options); } return $instance; } } } namespace Zend\Mvc\Service { class RoutePluginManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Mvc\Router\RoutePluginManager'; } } namespace Zend\Mvc\Router { use Zend\ServiceManager\AbstractPluginManager; class RoutePluginManager extends AbstractPluginManager { protected $shareByDefault = false; public function setInvokableClass($name, $invokableClass, $shared = null) { parent::setInvokableClass($name, $invokableClass, $shared); if ($name != $invokableClass) { $this->setAlias($invokableClass, $name); } return $this; } public function validatePlugin($plugin) { if ($plugin instanceof RouteInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\RouteInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } protected function createFromInvokable($canonicalName, $requestedName) { $invokable = $this->invokableClasses[$canonicalName]; if (!class_exists($invokable)) { throw new Exception\RuntimeException(sprintf( '%s: failed retrieving "%s%s" via invokable class "%s"; class does not exist', __METHOD__, $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : ''), $invokable )); } if (!static::isSubclassOf($invokable, __NAMESPACE__ . '\RouteInterface')) { throw new Exception\RuntimeException(sprintf( '%s: failed retrieving "%s%s" via invokable class "%s"; class does not implement %s\RouteInterface', __METHOD__, $canonicalName, ($requestedName ? '(alias: ' . $requestedName . ')' : ''), $invokable, __NAMESPACE__ )); } return $invokable::factory($this->creationOptions); } } } namespace Zend\Mvc\Service { class SerializerAdapterPluginManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Serializer\AdapterPluginManager'; } } namespace Zend\Serializer { use Zend\ServiceManager\AbstractPluginManager; class AdapterPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'igbinary' => 'Zend\Serializer\Adapter\IgBinary', 'json' => 'Zend\Serializer\Adapter\Json', 'msgpack' => 'Zend\Serializer\Adapter\MsgPack', 'phpcode' => 'Zend\Serializer\Adapter\PhpCode', 'phpserialize' => 'Zend\Serializer\Adapter\PhpSerialize', 'pythonpickle' => 'Zend\Serializer\Adapter\PythonPickle', 'wddx' => 'Zend\Serializer\Adapter\Wddx', ); public function validatePlugin($plugin) { if ($plugin instanceof Adapter\AdapterInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\Adapter\AdapterInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } } namespace Zend\Mvc\Service { class HydratorManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Stdlib\Hydrator\HydratorPluginManager'; } } namespace Zend\Stdlib\Hydrator { use Zend\ServiceManager\AbstractPluginManager; use Zend\Stdlib\Exception; class HydratorPluginManager extends AbstractPluginManager { protected $shareByDefault = false; protected $invokableClasses = array( 'arrayserializable' => 'Zend\Stdlib\Hydrator\ArraySerializable', 'classmethods' => 'Zend\Stdlib\Hydrator\ClassMethods', 'objectproperty' => 'Zend\Stdlib\Hydrator\ObjectProperty', 'reflection' => 'Zend\Stdlib\Hydrator\Reflection' ); public function validatePlugin($plugin) { if ($plugin instanceof HydratorInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement Zend\Stdlib\Hydrator\HydratorInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)) )); } } } namespace Zend\Mvc\Service { class InputFilterManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\InputFilter\InputFilterPluginManager'; } } namespace Zend\InputFilter { use Zend\ServiceManager\AbstractPluginManager; use Zend\ServiceManager\ConfigInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Stdlib\InitializableInterface; class InputFilterPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'inputfilter' => 'Zend\InputFilter\InputFilter', 'collection' => 'Zend\InputFilter\CollectionInputFilter', ); protected $shareByDefault = false; public function __construct(ConfigInterface $configuration = null) { parent::__construct($configuration); $this->addInitializer(array($this, 'populateFactory')); } public function populateFactory($inputfilter) { if ($inputfilter instanceof InputFilter) { $factory = $inputfilter->getFactory(); $factory->setInputFilterManager($this); if ($this->serviceLocator instanceof ServiceLocatorInterface) { $factory->getDefaultFilterChain()->setPluginManager($this->serviceLocator->get('FilterManager')); $factory->getDefaultValidatorChain()->setPluginManager($this->serviceLocator->get('ValidatorManager')); } } } public function validatePlugin($plugin) { if ($plugin instanceof InputFilterInterface || $plugin instanceof InputInterface) { if ($plugin instanceof InitializableInterface) { $plugin->init(); } return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement Zend\InputFilter\InputFilterInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)) )); } } } namespace Zend\Mvc\Service { class LogProcessorManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Log\ProcessorPluginManager'; } } namespace Zend\Log { use Zend\ServiceManager\AbstractPluginManager; class ProcessorPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'backtrace' => 'Zend\Log\Processor\Backtrace', 'requestid' => 'Zend\Log\Processor\RequestId', ); protected $shareByDefault = false; public function validatePlugin($plugin) { if ($plugin instanceof Processor\ProcessorInterface) { return; } throw new Exception\InvalidArgumentException(sprintf( 'Plugin of type %s is invalid; must implement %s\Processor\ProcessorInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } } namespace Zend\Mvc\Service { class LogWriterManagerFactory extends AbstractPluginManagerFactory { const PLUGIN_MANAGER_CLASS = 'Zend\Log\WriterPluginManager'; } } namespace Zend\Log { use Zend\ServiceManager\AbstractPluginManager; class WriterPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'chromephp' => 'Zend\Log\Writer\ChromePhp', 'db' => 'Zend\Log\Writer\Db', 'fingerscrossed' => 'Zend\Log\Writer\FingersCrossed', 'firephp' => 'Zend\Log\Writer\FirePhp', 'mail' => 'Zend\Log\Writer\Mail', 'mock' => 'Zend\Log\Writer\Mock', 'null' => 'Zend\Log\Writer\Null', 'stream' => 'Zend\Log\Writer\Stream', 'syslog' => 'Zend\Log\Writer\Syslog', 'zendmonitor' => 'Zend\Log\Writer\ZendMonitor', ); protected $shareByDefault = false; public function validatePlugin($plugin) { if ($plugin instanceof Writer\WriterInterface) { return; } throw new Exception\InvalidArgumentException(sprintf( 'Plugin of type %s is invalid; must implement %s\Writer\WriterInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } } namespace Zend\Mvc\Service { use Zend\Mvc\Application; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ApplicationFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { return new Application($serviceLocator->get('Config'), $serviceLocator); } } } namespace Zend\Mvc\Service { use Zend\Console\Console; use Zend\Console\Request as ConsoleRequest; use Zend\Http\PhpEnvironment\Request as HttpRequest; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class RequestFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { if (Console::isConsole()) { return new ConsoleRequest(); } return new HttpRequest(); } } } namespace Zend\Console { abstract class Console { protected static $instance; protected static $isConsole; public static function getInstance($forceAdapter = null, $forceCharset = null) { if (static::$instance instanceof Adapter\AdapterInterface) { return static::$instance; } if ($forceAdapter !== null) { if (substr($forceAdapter, 0, 1) == '\\') { $className = $forceAdapter; } elseif (stristr($forceAdapter, '\\')) { $className = __NAMESPACE__ . '\\' . ltrim($forceAdapter, '\\'); } else { $className = __NAMESPACE__ . '\\Adapter\\' . $forceAdapter; } if (!class_exists($className)) { throw new Exception\InvalidArgumentException(sprintf( 'Cannot find Console adapter class "%s"', $className )); } } else { $className = static::detectBestAdapter(); if (!$className) { throw new Exception\RuntimeException('Cannot create Console adapter - am I running in a console?'); } } static::$instance = new $className(); if ($forceCharset !== null) { if (substr($forceCharset, 0, 1) == '\\') { $className = $forceCharset; } elseif (stristr($forceAdapter, '\\')) { $className = __NAMESPACE__ . '\\' . ltrim($forceCharset, '\\'); } else { $className = __NAMESPACE__ . '\\Charset\\' . $forceCharset; } if (!class_exists($className)) { throw new Exception\InvalidArgumentException(sprintf( 'Cannot find Charset class "%s"', $className )); } static::$instance->setCharset(new $className()); } return static::$instance; } public static function resetInstance() { static::$instance = null; } public static function isWindows() { return (defined('PHP_OS') && (substr_compare(PHP_OS, 'win', 0, 3, true) === 0)) || (getenv('OS') != false && substr_compare(getenv('OS'), 'windows', 0, 7, true)) ; } public static function isAnsicon() { return getenv('ANSICON') !== false; } public static function isConsole() { if (null === static::$isConsole) { static::$isConsole = (PHP_SAPI == 'cli'); } return static::$isConsole; } public static function overrideIsConsole($flag) { if (null != $flag) { $flag = (bool) $flag; } static::$isConsole = $flag; } public static function detectBestAdapter() { if (!static::isConsole()) { return null; } if (static::isWindows()) { if (static::isAnsicon()) { $className = __NAMESPACE__ . '\Adapter\WindowsAnsicon'; } else { $className = __NAMESPACE__ . '\Adapter\Windows'; } return $className; } $className = __NAMESPACE__ . '\Adapter\Posix'; return $className; } public static function __callStatic($funcName, $arguments) { $instance = static::getInstance(); return call_user_func_array(array($instance, $funcName), $arguments); } } } namespace Zend\Stdlib { use Traversable; class Message implements MessageInterface { protected $metadata = array(); protected $content = ''; public function setMetadata($spec, $value = null) { if (is_scalar($spec)) { $this->metadata[$spec] = $value; return $this; } if (!is_array($spec) && !$spec instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Expected a string, array, or Traversable argument in first position; received "%s"', (is_object($spec) ? get_class($spec) : gettype($spec)) )); } foreach ($spec as $key => $value) { $this->metadata[$key] = $value; } return $this; } public function getMetadata($key = null, $default = null) { if (null === $key) { return $this->metadata; } if (!is_scalar($key)) { throw new Exception\InvalidArgumentException('Non-scalar argument provided for key'); } if (array_key_exists($key, $this->metadata)) { return $this->metadata[$key]; } return $default; } public function setContent($value) { $this->content = $value; return $this; } public function getContent() { return $this->content; } public function toString() { $request = ''; foreach ($this->getMetadata() as $key => $value) { $request .= sprintf( "%s: %s\r\n", (string) $key, (string) $value ); } $request .= "\r\n" . $this->getContent(); return $request; } } } namespace Zend\Http { use Zend\Stdlib\Message; abstract class AbstractMessage extends Message { const VERSION_10 = '1.0'; const VERSION_11 = '1.1'; protected $version = self::VERSION_11; protected $headers = null; public function setVersion($version) { if ($version != self::VERSION_10 && $version != self::VERSION_11) { throw new Exception\InvalidArgumentException( 'Not valid or not supported HTTP version: ' . $version ); } $this->version = $version; return $this; } public function getVersion() { return $this->version; } public function setHeaders(Headers $headers) { $this->headers = $headers; return $this; } public function getHeaders() { if ($this->headers === null || is_string($this->headers)) { $this->headers = (is_string($this->headers)) ? Headers::fromString($this->headers) : new Headers(); } return $this->headers; } public function __toString() { return $this->toString(); } } } namespace Zend\Http { use Zend\Stdlib\Parameters; use Zend\Stdlib\ParametersInterface; use Zend\Stdlib\RequestInterface; use Zend\Uri\Exception as UriException; use Zend\Uri\Http as HttpUri; class Request extends AbstractMessage implements RequestInterface { const METHOD_OPTIONS = 'OPTIONS'; const METHOD_GET = 'GET'; const METHOD_HEAD = 'HEAD'; const METHOD_POST = 'POST'; const METHOD_PUT = 'PUT'; const METHOD_DELETE = 'DELETE'; const METHOD_TRACE = 'TRACE'; const METHOD_CONNECT = 'CONNECT'; const METHOD_PATCH = 'PATCH'; const METHOD_PROPFIND = 'PROPFIND'; protected $method = self::METHOD_GET; protected $uri = null; protected $queryParams = null; protected $postParams = null; protected $fileParams = null; public static function fromString($string) { $request = new static(); $lines = explode("\r\n", $string); $matches = null; $methods = implode('|', array( self::METHOD_OPTIONS, self::METHOD_GET, self::METHOD_HEAD, self::METHOD_POST, self::METHOD_PUT, self::METHOD_DELETE, self::METHOD_TRACE, self::METHOD_CONNECT, self::METHOD_PATCH )); $regex = '#^(?P<method>' . $methods . ')\s(?P<uri>[^ ]*)(?:\sHTTP\/(?P<version>\d+\.\d+)){0,1}#'; $firstLine = array_shift($lines); if (!preg_match($regex, $firstLine, $matches)) { throw new Exception\InvalidArgumentException( 'A valid request line was not found in the provided string' ); } $request->setMethod($matches['method']); $request->setUri($matches['uri']); if (isset($matches['version'])) { $request->setVersion($matches['version']); } if (count($lines) == 0) { return $request; } $isHeader = true; $headers = $rawBody = array(); while ($lines) { $nextLine = array_shift($lines); if ($nextLine == '') { $isHeader = false; continue; } if ($isHeader) { $headers[] = $nextLine; } else { $rawBody[] = $nextLine; } } if ($headers) { $request->headers = implode("\r\n", $headers); } if ($rawBody) { $request->setContent(implode("\r\n", $rawBody)); } return $request; } public function setMethod($method) { $method = strtoupper($method); if (!defined('static::METHOD_' . $method)) { throw new Exception\InvalidArgumentException('Invalid HTTP method passed'); } $this->method = $method; return $this; } public function getMethod() { return $this->method; } public function setUri($uri) { if (is_string($uri)) { try { $uri = new HttpUri($uri); } catch (UriException\InvalidUriPartException $e) { throw new Exception\InvalidArgumentException( sprintf('Invalid URI passed as string (%s)', (string) $uri), $e->getCode(), $e ); } } elseif (!($uri instanceof HttpUri)) { throw new Exception\InvalidArgumentException( 'URI must be an instance of Zend\Uri\Http or a string' ); } $this->uri = $uri; return $this; } public function getUri() { if ($this->uri === null || is_string($this->uri)) { $this->uri = new HttpUri($this->uri); } return $this->uri; } public function getUriString() { if ($this->uri instanceof HttpUri) { return $this->uri->toString(); } return $this->uri; } public function setQuery(ParametersInterface $query) { $this->queryParams = $query; return $this; } public function getQuery($name = null, $default = null) { if ($this->queryParams === null) { $this->queryParams = new Parameters(); } if ($name === null) { return $this->queryParams; } return $this->queryParams->get($name, $default); } public function setPost(ParametersInterface $post) { $this->postParams = $post; return $this; } public function getPost($name = null, $default = null) { if ($this->postParams === null) { $this->postParams = new Parameters(); } if ($name === null) { return $this->postParams; } return $this->postParams->get($name, $default); } public function getCookie() { return $this->getHeaders()->get('Cookie'); } public function setFiles(ParametersInterface $files) { $this->fileParams = $files; return $this; } public function getFiles($name = null, $default = null) { if ($this->fileParams === null) { $this->fileParams = new Parameters(); } if ($name === null) { return $this->fileParams; } return $this->fileParams->get($name, $default); } public function getHeaders($name = null, $default = false) { if ($this->headers === null || is_string($this->headers)) { $this->headers = (is_string($this->headers)) ? Headers::fromString($this->headers) : new Headers(); } if ($name === null) { return $this->headers; } if ($this->headers->has($name)) { return $this->headers->get($name); } return $default; } public function getHeader($name, $default = false) { return $this->getHeaders($name, $default); } public function isOptions() { return ($this->method === self::METHOD_OPTIONS); } public function isPropFind() { return ($this->method === self::METHOD_PROPFIND); } public function isGet() { return ($this->method === self::METHOD_GET); } public function isHead() { return ($this->method === self::METHOD_HEAD); } public function isPost() { return ($this->method === self::METHOD_POST); } public function isPut() { return ($this->method === self::METHOD_PUT); } public function isDelete() { return ($this->method === self::METHOD_DELETE); } public function isTrace() { return ($this->method === self::METHOD_TRACE); } public function isConnect() { return ($this->method === self::METHOD_CONNECT); } public function isPatch() { return ($this->method === self::METHOD_PATCH); } public function isXmlHttpRequest() { $header = $this->getHeaders()->get('X_REQUESTED_WITH'); return false !== $header && $header->getFieldValue() == 'XMLHttpRequest'; } public function isFlashRequest() { $header = $this->getHeaders()->get('USER_AGENT'); return false !== $header && stristr($header->getFieldValue(), ' flash'); } public function renderRequestLine() { return $this->method . ' ' . (string) $this->uri . ' HTTP/' . $this->version; } public function toString() { $str = $this->renderRequestLine() . "\r\n"; $str .= $this->getHeaders()->toString(); $str .= "\r\n"; $str .= $this->getContent(); return $str; } } } namespace Zend\Http\PhpEnvironment { use Zend\Http\Header\Cookie; use Zend\Http\Request as HttpRequest; use Zend\Stdlib\Parameters; use Zend\Stdlib\ParametersInterface; use Zend\Uri\Http as HttpUri; use Zend\Validator\Hostname as HostnameValidator; class Request extends HttpRequest { protected $baseUrl; protected $basePath; protected $requestUri; protected $serverParams = null; protected $envParams = null; public function __construct() { $this->setEnv(new Parameters($_ENV)); if ($_GET) { $this->setQuery(new Parameters($_GET)); } if ($_POST) { $this->setPost(new Parameters($_POST)); } if ($_COOKIE) { $this->setCookies(new Parameters($_COOKIE)); } if ($_FILES) { $files = $this->mapPhpFiles(); $this->setFiles(new Parameters($files)); } $this->setServer(new Parameters($_SERVER)); } public function getContent() { if (empty($this->content)) { $requestBody = file_get_contents('php://input'); if (strlen($requestBody) > 0) { $this->content = $requestBody; } } return $this->content; } public function setCookies($cookie) { $this->getHeaders()->addHeader(new Cookie((array) $cookie)); return $this; } public function setRequestUri($requestUri) { $this->requestUri = $requestUri; return $this; } public function getRequestUri() { if ($this->requestUri === null) { $this->requestUri = $this->detectRequestUri(); } return $this->requestUri; } public function setBaseUrl($baseUrl) { $this->baseUrl = rtrim($baseUrl, '/'); return $this; } public function getBaseUrl() { if ($this->baseUrl === null) { $this->setBaseUrl($this->detectBaseUrl()); } return $this->baseUrl; } public function setBasePath($basePath) { $this->basePath = rtrim($basePath, '/'); return $this; } public function getBasePath() { if ($this->basePath === null) { $this->setBasePath($this->detectBasePath()); } return $this->basePath; } public function setServer(ParametersInterface $server) { $this->serverParams = $server; if (function_exists('apache_request_headers')) { $apacheRequestHeaders = apache_request_headers(); if (!isset($this->serverParams['HTTP_AUTHORIZATION'])) { if (isset($apacheRequestHeaders['Authorization'])) { $this->serverParams->set('HTTP_AUTHORIZATION', $apacheRequestHeaders['Authorization']); } elseif (isset($apacheRequestHeaders['authorization'])) { $this->serverParams->set('HTTP_AUTHORIZATION', $apacheRequestHeaders['authorization']); } } } $headers = array(); foreach ($server as $key => $value) { if ($value && strpos($key, 'HTTP_') === 0) { if (strpos($key, 'HTTP_COOKIE') === 0) { continue; } $name = strtr(substr($key, 5), '_', ' '); $name = strtr(ucwords(strtolower($name)), ' ', '-'); } elseif ($value && strpos($key, 'CONTENT_') === 0) { $name = substr($key, 8); $name = 'Content-' . (($name == 'MD5') ? $name : ucfirst(strtolower($name))); } else { continue; } $headers[$name] = $value; } $this->getHeaders()->addHeaders($headers); if (isset($this->serverParams['REQUEST_METHOD'])) { $this->setMethod($this->serverParams['REQUEST_METHOD']); } if (isset($this->serverParams['SERVER_PROTOCOL']) && strpos($this->serverParams['SERVER_PROTOCOL'], self::VERSION_10) !== false ) { $this->setVersion(self::VERSION_10); } $uri = new HttpUri(); if ((!empty($this->serverParams['HTTPS']) && $this->serverParams['HTTPS'] !== 'off') || (!empty($this->serverParams['HTTP_X_FORWARDED_PROTO']) && $this->serverParams['HTTP_X_FORWARDED_PROTO'] == 'https') ) { $scheme = 'https'; } else { $scheme = 'http'; } $uri->setScheme($scheme); $host = null; $port = null; if ($this->getHeaders()->get('host')) { $host = $this->getHeaders()->get('host')->getFieldValue(); if (preg_match('|\:(\d+)$|', $host, $matches)) { $host = substr($host, 0, -1 * (strlen($matches[1]) + 1)); $port = (int) $matches[1]; } $hostnameValidator = new HostnameValidator(array( 'allow' => HostnameValidator::ALLOW_ALL, 'useIdnCheck' => false, 'useTldCheck' => false, )); if (!$hostnameValidator->isValid($host)) { $host = null; $port = null; } } if (!$host && isset($this->serverParams['SERVER_NAME'])) { $host = $this->serverParams['SERVER_NAME']; if (isset($this->serverParams['SERVER_PORT'])) { $port = (int) $this->serverParams['SERVER_PORT']; } if (isset($this->serverParams['SERVER_ADDR']) && preg_match('/^\[[0-9a-fA-F\:]+\]$/', $host)) { $host = '[' . $this->serverParams['SERVER_ADDR'] . ']'; if ($port . ']' == substr($host, strrpos($host, ':')+1)) { $port = null; } } } $uri->setHost($host); $uri->setPort($port); $requestUri = $this->getRequestUri(); if (($qpos = strpos($requestUri, '?')) !== false) { $requestUri = substr($requestUri, 0, $qpos); } $uri->setPath($requestUri); if (isset($this->serverParams['QUERY_STRING'])) { $uri->setQuery($this->serverParams['QUERY_STRING']); } $this->setUri($uri); return $this; } public function getServer($name = null, $default = null) { if ($this->serverParams === null) { $this->serverParams = new Parameters(); } if ($name === null) { return $this->serverParams; } return $this->serverParams->get($name, $default); } public function setEnv(ParametersInterface $env) { $this->envParams = $env; return $this; } public function getEnv($name = null, $default = null) { if ($this->envParams === null) { $this->envParams = new Parameters(); } if ($name === null) { return $this->envParams; } return $this->envParams->get($name, $default); } protected function mapPhpFiles() { $files = array(); foreach ($_FILES as $fileName => $fileParams) { $files[$fileName] = array(); foreach ($fileParams as $param => $data) { if (!is_array($data)) { $files[$fileName][$param] = $data; } else { foreach ($data as $i => $v) { $this->mapPhpFileParam($files[$fileName], $param, $i, $v); } } } } return $files; } protected function mapPhpFileParam(&$array, $paramName, $index, $value) { if (!is_array($value)) { $array[$index][$paramName] = $value; } else { foreach ($value as $i => $v) { $this->mapPhpFileParam($array[$index], $paramName, $i, $v); } } } protected function detectRequestUri() { $requestUri = null; $server = $this->getServer(); $httpXRewriteUrl = $server->get('HTTP_X_REWRITE_URL'); if ($httpXRewriteUrl !== null) { $requestUri = $httpXRewriteUrl; } $httpXOriginalUrl = $server->get('HTTP_X_ORIGINAL_URL'); if ($httpXOriginalUrl !== null) { $requestUri = $httpXOriginalUrl; } $iisUrlRewritten = $server->get('IIS_WasUrlRewritten'); $unencodedUrl = $server->get('UNENCODED_URL', ''); if ('1' == $iisUrlRewritten && '' !== $unencodedUrl) { return $unencodedUrl; } if (!$httpXRewriteUrl) { $requestUri = $server->get('REQUEST_URI'); } if ($requestUri !== null) { return preg_replace('#^[^/:]+://[^/]+#', '', $requestUri); } $origPathInfo = $server->get('ORIG_PATH_INFO'); if ($origPathInfo !== null) { $queryString = $server->get('QUERY_STRING', ''); if ($queryString !== '') { $origPathInfo .= '?' . $queryString; } return $origPathInfo; } return '/'; } protected function detectBaseUrl() { $filename = $this->getServer()->get('SCRIPT_FILENAME', ''); $scriptName = $this->getServer()->get('SCRIPT_NAME'); $phpSelf = $this->getServer()->get('PHP_SELF'); $origScriptName = $this->getServer()->get('ORIG_SCRIPT_NAME'); if ($scriptName !== null && basename($scriptName) === $filename) { $baseUrl = $scriptName; } elseif ($phpSelf !== null && basename($phpSelf) === $filename) { $baseUrl = $phpSelf; } elseif ($origScriptName !== null && basename($origScriptName) === $filename) { $baseUrl = $origScriptName; } else { $baseUrl = '/'; $basename = basename($filename); if ($basename) { $path = ($phpSelf ? trim($phpSelf, '/') : ''); $baseUrl .= substr($path, 0, strpos($path, $basename)) . $basename; } } $requestUri = $this->getRequestUri(); if (0 === strpos($requestUri, $baseUrl)) { return $baseUrl; } $baseDir = str_replace('\\', '/', dirname($baseUrl)); if (0 === strpos($requestUri, $baseDir)) { return $baseDir; } $truncatedRequestUri = $requestUri; if (false !== ($pos = strpos($requestUri, '?'))) { $truncatedRequestUri = substr($requestUri, 0, $pos); } $basename = basename($baseUrl); if (empty($basename) || false === strpos($truncatedRequestUri, $basename)) { return ''; } if (strlen($requestUri) >= strlen($baseUrl) && (false !== ($pos = strpos($requestUri, $baseUrl)) && $pos !== 0) ) { $baseUrl = substr($requestUri, 0, $pos + strlen($baseUrl)); } return $baseUrl; } protected function detectBasePath() { $filename = basename($this->getServer()->get('SCRIPT_FILENAME', '')); $baseUrl = $this->getBaseUrl(); if ($baseUrl === '') { return ''; } if (basename($baseUrl) === $filename) { return str_replace('\\', '/', dirname($baseUrl)); } return $baseUrl; } } } namespace Zend\Stdlib { use ArrayObject as PhpArrayObject; class Parameters extends PhpArrayObject implements ParametersInterface { public function __construct(array $values = null) { if (null === $values) { $values = array(); } parent::__construct($values, ArrayObject::ARRAY_AS_PROPS); } public function fromArray(array $values) { $this->exchangeArray($values); } public function fromString($string) { $array = array(); parse_str($string, $array); $this->fromArray($array); } public function toArray() { return $this->getArrayCopy(); } public function toString() { return http_build_query($this); } public function offsetGet($name) { if ($this->offsetExists($name)) { return parent::offsetGet($name); } return null; } public function get($name, $default = null) { if ($this->offsetExists($name)) { return parent::offsetGet($name); } return $default; } public function set($name, $value) { $this[$name] = $value; return $this; } } } namespace Zend\Stdlib { use ArrayAccess; use Countable; use IteratorAggregate; use Serializable; class ArrayObject implements IteratorAggregate, ArrayAccess, Serializable, Countable { const STD_PROP_LIST = 1; const ARRAY_AS_PROPS = 2; protected $storage; protected $flag; protected $iteratorClass; protected $protectedProperties; public function __construct($input = array(), $flags = self::STD_PROP_LIST, $iteratorClass = 'ArrayIterator') { $this->setFlags($flags); $this->storage = $input; $this->setIteratorClass($iteratorClass); $this->protectedProperties = array_keys(get_object_vars($this)); } public function __isset($key) { if ($this->flag == self::ARRAY_AS_PROPS) { return $this->offsetExists($key); } if (in_array($key, $this->protectedProperties)) { throw new Exception\InvalidArgumentException('$key is a protected property, use a different key'); } return isset($this->$key); } public function __set($key, $value) { if ($this->flag == self::ARRAY_AS_PROPS) { return $this->offsetSet($key, $value); } if (in_array($key, $this->protectedProperties)) { throw new Exception\InvalidArgumentException('$key is a protected property, use a different key'); } $this->$key = $value; } public function __unset($key) { if ($this->flag == self::ARRAY_AS_PROPS) { return $this->offsetUnset($key); } if (in_array($key, $this->protectedProperties)) { throw new Exception\InvalidArgumentException('$key is a protected property, use a different key'); } unset($this->$key); } public function &__get($key) { $ret = null; if ($this->flag == self::ARRAY_AS_PROPS) { $ret =& $this->offsetGet($key); return $ret; } if (in_array($key, $this->protectedProperties)) { throw new Exception\InvalidArgumentException('$key is a protected property, use a different key'); } return $this->$key; } public function append($value) { $this->storage[] = $value; } public function asort() { asort($this->storage); } public function count() { return count($this->storage); } public function exchangeArray($data) { if (!is_array($data) && !is_object($data)) { throw new Exception\InvalidArgumentException('Passed variable is not an array or object, using empty array instead'); } if (is_object($data) && ($data instanceof self || $data instanceof \ArrayObject)) { $data = $data->getArrayCopy(); } if (!is_array($data)) { $data = (array) $data; } $storage = $this->storage; $this->storage = $data; return $storage; } public function getArrayCopy() { return $this->storage; } public function getFlags() { return $this->flag; } public function getIterator() { $class = $this->iteratorClass; return new $class($this->storage); } public function getIteratorClass() { return $this->iteratorClass; } public function ksort() { ksort($this->storage); } public function natcasesort() { natcasesort($this->storage); } public function natsort() { natsort($this->storage); } public function offsetExists($key) { return isset($this->storage[$key]); } public function &offsetGet($key) { $ret = null; if (!$this->offsetExists($key)) { return $ret; } $ret =& $this->storage[$key]; return $ret; } public function offsetSet($key, $value) { $this->storage[$key] = $value; } public function offsetUnset($key) { if ($this->offsetExists($key)) { unset($this->storage[$key]); } } public function serialize() { return serialize(get_object_vars($this)); } public function setFlags($flags) { $this->flag = $flags; } public function setIteratorClass($class) { if (class_exists($class)) { $this->iteratorClass = $class; return ; } if (strpos($class, '\\') === 0) { $class = '\\' . $class; if (class_exists($class)) { $this->iteratorClass = $class; return ; } } throw new Exception\InvalidArgumentException('The iterator class does not exist'); } public function uasort($function) { if (is_callable($function)) { uasort($this->storage, $function); } } public function uksort($function) { if (is_callable($function)) { uksort($this->storage, $function); } } public function unserialize($data) { $ar = unserialize($data); $this->protectedProperties = array_keys(get_object_vars($this)); $this->setFlags($ar['flag']); $this->exchangeArray($ar['storage']); $this->setIteratorClass($ar['iteratorClass']); foreach ($ar as $k => $v) { switch ($k) { case 'flag': $this->setFlags($v); break; case 'storage': $this->exchangeArray($v); break; case 'iteratorClass': $this->setIteratorClass($v); break; case 'protectedProperties': continue; default: $this->__set($k, $v); } } } } } namespace Zend\Http { use ArrayIterator; use Countable; use Iterator; use Traversable; use Zend\Loader\PluginClassLocator; class Headers implements Countable, Iterator { protected $pluginClassLoader = null; protected $headersKeys = array(); protected $headers = array(); public static function fromString($string) { $headers = new static(); $current = array(); foreach (explode("\r\n", $string) as $line) { if (preg_match('/^(?P<name>[^()><@,;:\"\\/\[\]?=}{ \t]+):.*$/', $line, $matches)) { if ($current) { $headers->headersKeys[] = static::createKey($current['name']); $headers->headers[] = $current; } $current = array( 'name' => $matches['name'], 'line' => trim($line) ); } elseif (preg_match('/^(?P<ws>\s+).*$/', $line, $matches)) { $current['line'] .= "\r\n" . $matches['ws'] . trim($line); } elseif (preg_match('/^\s*$/', $line)) { break; } else { throw new Exception\RuntimeException(sprintf( 'Line "%s" does not match header format!', $line )); } } if ($current) { $headers->headersKeys[] = static::createKey($current['name']); $headers->headers[] = $current; } return $headers; } public function setPluginClassLoader(PluginClassLocator $pluginClassLoader) { $this->pluginClassLoader = $pluginClassLoader; return $this; } public function getPluginClassLoader() { if ($this->pluginClassLoader === null) { $this->pluginClassLoader = new HeaderLoader(); } return $this->pluginClassLoader; } public function addHeaders($headers) { if (!is_array($headers) && !$headers instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Expected array or Traversable; received "%s"', (is_object($headers) ? get_class($headers) : gettype($headers)) )); } foreach ($headers as $name => $value) { if (is_int($name)) { if (is_string($value)) { $this->addHeaderLine($value); } elseif (is_array($value) && count($value) == 1) { $this->addHeaderLine(key($value), current($value)); } elseif (is_array($value) && count($value) == 2) { $this->addHeaderLine($value[0], $value[1]); } elseif ($value instanceof Header\HeaderInterface) { $this->addHeader($value); } } elseif (is_string($name)) { $this->addHeaderLine($name, $value); } } return $this; } public function addHeaderLine($headerFieldNameOrLine, $fieldValue = null) { $matches = null; if (preg_match('/^(?P<name>[^()><@,;:\"\\/\[\]?=}{ \t]+):.*$/', $headerFieldNameOrLine, $matches) && $fieldValue === null) { $headerName = $matches['name']; $headerKey = static::createKey($matches['name']); $line = $headerFieldNameOrLine; } elseif ($fieldValue === null) { throw new Exception\InvalidArgumentException('A field name was provided without a field value'); } else { $headerName = $headerFieldNameOrLine; $headerKey = static::createKey($headerFieldNameOrLine); if (is_array($fieldValue)) { $fieldValue = implode(', ', $fieldValue); } $line = $headerFieldNameOrLine . ': ' . $fieldValue; } $this->headersKeys[] = $headerKey; $this->headers[] = array('name' => $headerName, 'line' => $line); return $this; } public function addHeader(Header\HeaderInterface $header) { $this->headersKeys[] = static::createKey($header->getFieldName()); $this->headers[] = $header; return $this; } public function removeHeader(Header\HeaderInterface $header) { $index = array_search($header, $this->headers, true); if ($index !== false) { unset($this->headersKeys[$index]); unset($this->headers[$index]); return true; } return false; } public function clearHeaders() { $this->headers = $this->headersKeys = array(); return $this; } public function get($name) { $key = static::createKey($name); if (!in_array($key, $this->headersKeys)) { return false; } $class = ($this->getPluginClassLoader()->load($key)) ?: 'Zend\Http\Header\GenericHeader'; if (in_array('Zend\Http\Header\MultipleHeaderInterface', class_implements($class, true))) { $headers = array(); foreach (array_keys($this->headersKeys, $key) as $index) { if (is_array($this->headers[$index])) { $this->lazyLoadHeader($index); } } foreach (array_keys($this->headersKeys, $key) as $index) { $headers[] = $this->headers[$index]; } return new ArrayIterator($headers); } $index = array_search($key, $this->headersKeys); if ($index === false) { return false; } if (is_array($this->headers[$index])) { return $this->lazyLoadHeader($index); } return $this->headers[$index]; } public function has($name) { return (in_array(static::createKey($name), $this->headersKeys)); } public function next() { next($this->headers); } public function key() { return (key($this->headers)); } public function valid() { return (current($this->headers) !== false); } public function rewind() { reset($this->headers); } public function current() { $current = current($this->headers); if (is_array($current)) { $current = $this->lazyLoadHeader(key($this->headers)); } return $current; } public function count() { return count($this->headers); } public function toString() { $headers = ''; foreach ($this->toArray() as $fieldName => $fieldValue) { if (is_array($fieldValue)) { foreach ($fieldValue as $value) { $headers .= $fieldName . ': ' . $value . "\r\n"; } continue; } $headers .= $fieldName . ': ' . $fieldValue . "\r\n"; } return $headers; } public function toArray() { $headers = array(); foreach ($this->headers as $header) { if ($header instanceof Header\MultipleHeaderInterface) { $name = $header->getFieldName(); if (!isset($headers[$name])) { $headers[$name] = array(); } $headers[$name][] = $header->getFieldValue(); } elseif ($header instanceof Header\HeaderInterface) { $headers[$header->getFieldName()] = $header->getFieldValue(); } else { $matches = null; preg_match('/^(?P<name>[^()><@,;:\"\\/\[\]?=}{ \t]+):\s*(?P<value>.*)$/', $header['line'], $matches); if ($matches) { $headers[$matches['name']] = $matches['value']; } } } return $headers; } public function forceLoading() { foreach ($this as $item) { } return true; } protected function lazyLoadHeader($index) { $current = $this->headers[$index]; $key = $this->headersKeys[$index]; $class = ($this->getPluginClassLoader()->load($key)) ?: 'Zend\Http\Header\GenericHeader'; $headers = $class::fromString($current['line']); if (is_array($headers)) { $this->headers[$index] = $current = array_shift($headers); foreach ($headers as $header) { $this->headersKeys[] = $key; $this->headers[] = $header; } return $current; } $this->headers[$index] = $current = $headers; return $current; } protected static function createKey($name) { return str_replace(array('-', '_', ' ', '.'), '', strtolower($name)); } } } namespace Zend\Http\Header { use ArrayObject; class Cookie extends ArrayObject implements HeaderInterface { protected $encodeValue = true; public static function fromSetCookieArray(array $setCookies) { $nvPairs = array(); foreach ($setCookies as $setCookie) { if (!$setCookie instanceof SetCookie) { throw new Exception\InvalidArgumentException(__CLASS__ . '::' . __METHOD__ . ' requires an array of SetCookie objects'); } if (array_key_exists($setCookie->getName(), $nvPairs)) { throw new Exception\InvalidArgumentException('Two cookies with the same name were provided to ' . __CLASS__ . '::' . __METHOD__); } $nvPairs[$setCookie->getName()] = $setCookie->getValue(); } return new static($nvPairs); } public static function fromString($headerLine) { $header = new static(); list($name, $value) = GenericHeader::splitHeaderLine($headerLine); if (strtolower($name) !== 'cookie') { throw new Exception\InvalidArgumentException('Invalid header line for Server string: "' . $name . '"'); } $nvPairs = preg_split('#;\s*#', $value); $arrayInfo = array(); foreach ($nvPairs as $nvPair) { $parts = explode('=', $nvPair, 2); if (count($parts) != 2) { throw new Exception\RuntimeException('Malformed Cookie header found'); } list($name, $value) = $parts; $arrayInfo[$name] = urldecode($value); } $header->exchangeArray($arrayInfo); return $header; } public function __construct(array $array = array()) { parent::__construct($array, ArrayObject::ARRAY_AS_PROPS); } public function setEncodeValue($encodeValue) { $this->encodeValue = (bool) $encodeValue; return $this; } public function getEncodeValue() { return $this->encodeValue; } public function getFieldName() { return 'Cookie'; } public function getFieldValue() { $nvPairs = array(); foreach ($this as $name => $value) { $nvPairs[] = $name . '=' . (($this->encodeValue) ? urlencode($value) : $value); } return implode('; ', $nvPairs); } public function toString() { return 'Cookie: ' . $this->getFieldValue(); } public function __toString() { return $this->toString(); } } } namespace Zend\Uri { use Zend\Escaper\Escaper; use Zend\Validator; class Uri implements UriInterface { const CHAR_UNRESERVED = 'a-zA-Z0-9_\-\.~'; const CHAR_GEN_DELIMS = ':\/\?#\[\]@'; const CHAR_SUB_DELIMS = '!\$&\'\(\)\*\+,;='; const CHAR_RESERVED = ':\/\?#\[\]@!\$&\'\(\)\*\+,;='; const CHAR_QUERY_DELIMS = '!\$\'\(\)\*\,'; const HOST_IPV4 = 0x01; const HOST_IPV6 = 0x02; const HOST_IPVFUTURE = 0x04; const HOST_IPVANY = 0x07; const HOST_DNS = 0x08; const HOST_DNS_OR_IPV4 = 0x09; const HOST_DNS_OR_IPV6 = 0x0A; const HOST_DNS_OR_IPV4_OR_IPV6 = 0x0B; const HOST_DNS_OR_IPVANY = 0x0F; const HOST_REGNAME = 0x10; const HOST_DNS_OR_IPV4_OR_IPV6_OR_REGNAME = 0x13; const HOST_ALL = 0x1F; protected $scheme; protected $userInfo; protected $host; protected $port; protected $path; protected $query; protected $fragment; protected $validHostTypes = self::HOST_ALL; protected static $validSchemes = array(); protected static $defaultPorts = array(); protected static $escaper; public function __construct($uri = null) { if (is_string($uri)) { $this->parse($uri); } elseif ($uri instanceof UriInterface) { $this->setScheme($uri->getScheme()); $this->setUserInfo($uri->getUserInfo()); $this->setHost($uri->getHost()); $this->setPort($uri->getPort()); $this->setPath($uri->getPath()); $this->setQuery($uri->getQuery()); $this->setFragment($uri->getFragment()); } elseif ($uri !== null) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string or a URI object, received "%s"', (is_object($uri) ? get_class($uri) : gettype($uri)) )); } } public static function setEscaper(Escaper $escaper) { static::$escaper = $escaper; } public static function getEscaper() { if (null === static::$escaper) { static::setEscaper(new Escaper()); } return static::$escaper; } public function isValid() { if ($this->host) { if (strlen($this->path) > 0 && substr($this->path, 0, 1) != '/') { return false; } return true; } if ($this->userInfo || $this->port) { return false; } if ($this->path) { if (substr($this->path, 0, 2) == '//') { return false; } return true; } if (! ($this->query || $this->fragment)) { return false; } return true; } public function isValidRelative() { if ($this->scheme || $this->host || $this->userInfo || $this->port) { return false; } if ($this->path) { if (substr($this->path, 0, 2) == '//') { return false; } return true; } if (! ($this->query || $this->fragment)) { return false; } return true; } public function isAbsolute() { return ($this->scheme !== null); } protected function reset() { $this->setScheme(null); $this->setPort(null); $this->setUserInfo(null); $this->setHost(null); $this->setPath(null); $this->setFragment(null); $this->setQuery(null); } public function parse($uri) { $this->reset(); if (($scheme = self::parseScheme($uri)) !== null) { $this->setScheme($scheme); $uri = substr($uri, strlen($scheme) + 1); } if (preg_match('|^//([^/\?#]*)|', $uri, $match)) { $authority = $match[1]; $uri = substr($uri, strlen($match[0])); if (strpos($authority, '@') !== false) { $segments = explode('@', $authority); $authority = array_pop($segments); $userInfo = implode('@', $segments); unset($segments); $this->setUserInfo($userInfo); } $nMatches = preg_match('/:[\d]{1,5}$/', $authority, $matches); if ($nMatches === 1) { $portLength = strlen($matches[0]); $port = substr($matches[0], 1); $this->setPort((int) $port); $authority = substr($authority, 0, -$portLength); } $this->setHost($authority); } if (!$uri) { return $this; } if (preg_match('|^[^\?#]*|', $uri, $match)) { $this->setPath($match[0]); $uri = substr($uri, strlen($match[0])); } if (!$uri) { return $this; } if (preg_match('|^\?([^#]*)|', $uri, $match)) { $this->setQuery($match[1]); $uri = substr($uri, strlen($match[0])); } if (!$uri) { return $this; } if ($uri && substr($uri, 0, 1) == '#') { $this->setFragment(substr($uri, 1)); } return $this; } public function toString() { if (!$this->isValid()) { if ($this->isAbsolute() || !$this->isValidRelative()) { throw new Exception\InvalidUriException( 'URI is not valid and cannot be converted into a string' ); } } $uri = ''; if ($this->scheme) { $uri .= $this->scheme . ':'; } if ($this->host !== null) { $uri .= '//'; if ($this->userInfo) { $uri .= $this->userInfo . '@'; } $uri .= $this->host; if ($this->port) { $uri .= ':' . $this->port; } } if ($this->path) { $uri .= static::encodePath($this->path); } elseif ($this->host && ($this->query || $this->fragment)) { $uri .= '/'; } if ($this->query) { $uri .= "?" . static::encodeQueryFragment($this->query); } if ($this->fragment) { $uri .= "#" . static::encodeQueryFragment($this->fragment); } return $uri; } public function normalize() { if ($this->scheme) { $this->scheme = static::normalizeScheme($this->scheme); } if ($this->host) { $this->host = static::normalizeHost($this->host); } if ($this->port) { $this->port = static::normalizePort($this->port, $this->scheme); } if ($this->path) { $this->path = static::normalizePath($this->path); } if ($this->query) { $this->query = static::normalizeQuery($this->query); } if ($this->fragment) { $this->fragment = static::normalizeFragment($this->fragment); } if ($this->host && empty($this->path)) { $this->path = '/'; } return $this; } public function resolve($baseUri) { if ($this->isAbsolute()) { return $this; } if (is_string($baseUri)) { $baseUri = new static($baseUri); } elseif (!$baseUri instanceof Uri) { throw new Exception\InvalidArgumentException( 'Provided base URI must be a string or a Uri object' ); } if ($this->getHost()) { $this->setPath(static::removePathDotSegments($this->getPath())); } else { $basePath = $baseUri->getPath(); $relPath = $this->getPath(); if (!$relPath) { $this->setPath($basePath); if (!$this->getQuery()) { $this->setQuery($baseUri->getQuery()); } } else { if (substr($relPath, 0, 1) == '/') { $this->setPath(static::removePathDotSegments($relPath)); } else { if ($baseUri->getHost() && !$basePath) { $mergedPath = '/'; } else { $mergedPath = substr($basePath, 0, strrpos($basePath, '/') + 1); } $this->setPath(static::removePathDotSegments($mergedPath . $relPath)); } } $this->setUserInfo($baseUri->getUserInfo()); $this->setHost($baseUri->getHost()); $this->setPort($baseUri->getPort()); } $this->setScheme($baseUri->getScheme()); return $this; } public function makeRelative($baseUri) { $baseUri = new static($baseUri); $this->normalize(); $baseUri->normalize(); $host = $this->getHost(); $baseHost = $baseUri->getHost(); if ($host && $baseHost && ($host != $baseHost)) { return $this; } $port = $this->getPort(); $basePort = $baseUri->getPort(); if ($port && $basePort && ($port != $basePort)) { return $this; } $scheme = $this->getScheme(); $baseScheme = $baseUri->getScheme(); if ($scheme && $baseScheme && ($scheme != $baseScheme)) { return $this; } $this->setHost(null) ->setPort(null) ->setScheme(null); if ($this->getPath() == $baseUri->getPath()) { $this->setPath(''); return $this; } $pathParts = preg_split('|(/)|', $this->getPath(), null, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY); $baseParts = preg_split('|(/)|', $baseUri->getPath(), null, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY); $matchingParts = array_intersect_assoc($pathParts, $baseParts); foreach ($matchingParts as $index => $segment) { if ($index && !isset($matchingParts[$index - 1])) { array_unshift($pathParts, '../'); continue; } unset($pathParts[$index]); } $this->setPath(implode($pathParts)); return $this; } public function getScheme() { return $this->scheme; } public function getUserInfo() { return $this->userInfo; } public function getHost() { return $this->host; } public function getPort() { return $this->port; } public function getPath() { return $this->path; } public function getQuery() { return $this->query; } public function getQueryAsArray() { $query = array(); if ($this->query) { parse_str($this->query, $query); } return $query; } public function getFragment() { return $this->fragment; } public function setScheme($scheme) { if (($scheme !== null) && (!self::validateScheme($scheme))) { throw new Exception\InvalidUriPartException(sprintf( 'Scheme "%s" is not valid or is not accepted by %s', $scheme, get_class($this) ), Exception\InvalidUriPartException::INVALID_SCHEME); } $this->scheme = $scheme; return $this; } public function setUserInfo($userInfo) { $this->userInfo = $userInfo; return $this; } public function setHost($host) { if (($host !== '') && ($host !== null) && !self::validateHost($host, $this->validHostTypes) ) { throw new Exception\InvalidUriPartException(sprintf( 'Host "%s" is not valid or is not accepted by %s', $host, get_class($this) ), Exception\InvalidUriPartException::INVALID_HOSTNAME); } $this->host = $host; return $this; } public function setPort($port) { $this->port = $port; return $this; } public function setPath($path) { $this->path = $path; return $this; } public function setQuery($query) { if (is_array($query)) { $query = str_replace('+', '%20', http_build_query($query)); } $this->query = $query; return $this; } public function setFragment($fragment) { $this->fragment = $fragment; return $this; } public function __toString() { try { return $this->toString(); } catch (\Exception $e) { return ''; } } public static function validateScheme($scheme) { if (!empty(static::$validSchemes) && !in_array(strtolower($scheme), static::$validSchemes) ) { return false; } return (bool) preg_match('/^[A-Za-z][A-Za-z0-9\-\.+]*$/', $scheme); } public static function validateUserInfo($userInfo) { $regex = '/^(?:[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . ':]+|%[A-Fa-f0-9]{2})*$/'; return (bool) preg_match($regex, $userInfo); } public static function validateHost($host, $allowed = self::HOST_ALL) { if ($allowed & self::HOST_IPVANY) { if (static::isValidIpAddress($host, $allowed)) { return true; } } if ($allowed & self::HOST_REGNAME) { if (static::isValidRegName($host)) { return true; } } if ($allowed & self::HOST_DNS) { if (static::isValidDnsHostname($host)) { return true; } } return false; } public static function validatePort($port) { if ($port === 0) { return false; } if ($port) { $port = (int) $port; if ($port < 1 || $port > 0xffff) { return false; } } return true; } public static function validatePath($path) { $pchar = '(?:[' . self::CHAR_UNRESERVED . ':@&=\+\$,]+|%[A-Fa-f0-9]{2})*'; $segment = $pchar . "(?:;{$pchar})*"; $regex = "/^{$segment}(?:\/{$segment})*$/"; return (bool) preg_match($regex, $path); } public static function validateQueryFragment($input) { $regex = '/^(?:[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . ':@\/\?]+|%[A-Fa-f0-9]{2})*$/'; return (bool) preg_match($regex, $input); } public static function encodeUserInfo($userInfo) { if (!is_string($userInfo)) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string, got %s', (is_object($userInfo) ? get_class($userInfo) : gettype($userInfo)) )); } $regex = '/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:]|%(?![A-Fa-f0-9]{2}))/'; $escaper = static::getEscaper(); $replace = function ($match) use ($escaper) { return $escaper->escapeUrl($match[0]); }; return preg_replace_callback($regex, $replace, $userInfo); } public static function encodePath($path) { if (!is_string($path)) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string, got %s', (is_object($path) ? get_class($path) : gettype($path)) )); } $regex = '/(?:[^' . self::CHAR_UNRESERVED . ':@&=\+\$,\/;%]+|%(?![A-Fa-f0-9]{2}))/'; $escaper = static::getEscaper(); $replace = function ($match) use ($escaper) { return $escaper->escapeUrl($match[0]); }; return preg_replace_callback($regex, $replace, $path); } public static function encodeQueryFragment($input) { if (!is_string($input)) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string, got %s', (is_object($input) ? get_class($input) : gettype($input)) )); } $regex = '/(?:[^' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\/\?]+|%(?![A-Fa-f0-9]{2}))/'; $escaper = static::getEscaper(); $replace = function ($match) use ($escaper) { return $escaper->escapeUrl($match[0]); }; return preg_replace_callback($regex, $replace, $input); } public static function parseScheme($uriString) { if (! is_string($uriString)) { throw new Exception\InvalidArgumentException(sprintf( 'Expecting a string, got %s', (is_object($uriString) ? get_class($uriString) : gettype($uriString)) )); } if (preg_match('/^([A-Za-z][A-Za-z0-9\.\+\-]*):/', $uriString, $match)) { return $match[1]; } return null; } public static function removePathDotSegments($path) { $output = ''; while ($path) { if ($path == '..' || $path == '.') { break; } switch (true) { case ($path == '/.'): $path = '/'; break; case ($path == '/..'): $path = '/'; $output = substr($output, 0, strrpos($output, '/', -1)); break; case (substr($path, 0, 4) == '/../'): $path = '/' . substr($path, 4); $output = substr($output, 0, strrpos($output, '/', -1)); break; case (substr($path, 0, 3) == '/./'): $path = substr($path, 2); break; case (substr($path, 0, 2) == './'): $path = substr($path, 2); break; case (substr($path, 0, 3) == '../'): $path = substr($path, 3); break; default: $slash = strpos($path, '/', 1); if ($slash === false) { $seg = $path; } else { $seg = substr($path, 0, $slash); } $output .= $seg; $path = substr($path, strlen($seg)); break; } } return $output; } public static function merge($baseUri, $relativeUri) { $uri = new static($relativeUri); return $uri->resolve($baseUri); } protected static function isValidIpAddress($host, $allowed) { $validatorParams = array( 'allowipv4' => (bool) ($allowed & self::HOST_IPV4), 'allowipv6' => false, 'allowipvfuture' => false, 'allowliteral' => false, ); $validator = new Validator\Ip($validatorParams); $return = $validator->isValid($host); if ($return) { return true; } $validatorParams = array( 'allowipv4' => false, 'allowipv6' => (bool) ($allowed & self::HOST_IPV6), 'allowipvfuture' => (bool) ($allowed & self::HOST_IPVFUTURE), 'allowliteral' => true, ); static $regex = '/^\[.*\]$/'; $validator->setOptions($validatorParams); return (preg_match($regex, $host) && $validator->isValid($host)); } protected static function isValidDnsHostname($host) { $validator = new Validator\Hostname(array( 'allow' => Validator\Hostname::ALLOW_DNS | Validator\Hostname::ALLOW_LOCAL, )); return $validator->isValid($host); } protected static function isValidRegName($host) { $regex = '/^(?:[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . ':@\/\?]+|%[A-Fa-f0-9]{2})+$/'; return (bool) preg_match($regex, $host); } protected static function normalizeScheme($scheme) { return strtolower($scheme); } protected static function normalizeHost($host) { return strtolower($host); } protected static function normalizePort($port, $scheme = null) { if ($scheme && isset(static::$defaultPorts[$scheme]) && ($port == static::$defaultPorts[$scheme]) ) { return null; } return $port; } protected static function normalizePath($path) { $path = self::encodePath( self::decodeUrlEncodedChars( self::removePathDotSegments($path), '/[' . self::CHAR_UNRESERVED . ':@&=\+\$,\/;%]/' ) ); return $path; } protected static function normalizeQuery($query) { $query = self::encodeQueryFragment( self::decodeUrlEncodedChars( $query, '/[' . self::CHAR_UNRESERVED . self::CHAR_QUERY_DELIMS . ':@\/\?]/' ) ); return $query; } protected static function normalizeFragment($fragment) { $fragment = self::encodeQueryFragment( self::decodeUrlEncodedChars( $fragment, '/[' . self::CHAR_UNRESERVED . self::CHAR_SUB_DELIMS . '%:@\/\?]/' ) ); return $fragment; } protected static function decodeUrlEncodedChars($input, $allowed = '') { $decodeCb = function ($match) use ($allowed) { $char = rawurldecode($match[0]); if (preg_match($allowed, $char)) { return $char; } return strtoupper($match[0]); }; return preg_replace_callback('/%[A-Fa-f0-9]{2}/', $decodeCb, $input); } } } namespace Zend\Uri { class Http extends Uri { protected static $validSchemes = array( 'http', 'https' ); protected static $defaultPorts = array( 'http' => 80, 'https' => 443, ); protected $validHostTypes = self::HOST_DNS_OR_IPV4_OR_IPV6_OR_REGNAME; protected $user; protected $password; public function isValid() { return parent::isValid(); } public function getUser() { if (null !== $this->user) { return $this->user; } $this->parseUserInfo(); return $this->user; } public function getPassword() { if (null !== $this->password) { return $this->password; } $this->parseUserInfo(); return $this->password; } public function setUser($user) { $this->user = $user; return $this; } public function setPassword($password) { $this->password = $password; return $this; } public static function validateHost($host, $allowed = self::HOST_DNS_OR_IPV4_OR_IPV6) { return parent::validateHost($host, $allowed); } protected function parseUserInfo() { if (null === $this->userInfo) { return; } if (false === strpos($this->userInfo, ':')) { $this->setUser($this->userInfo); return; } list($user, $password) = explode(':', $this->userInfo, 2); $this->setUser($user); $this->setPassword($password); } public function getPort() { if (empty($this->port)) { if (array_key_exists($this->scheme, static::$defaultPorts)) { return static::$defaultPorts[$this->scheme]; } } return $this->port; } public function parse($uri) { parent::parse($uri); if (empty($this->path)) { $this->path = '/'; } return $this; } } } namespace Zend\Loader { use ArrayIterator; use IteratorAggregate; use Traversable; class PluginClassLoader implements PluginClassLocator { protected $plugins = array(); protected static $staticMap = array(); public function __construct($map = null) { if (!empty(static::$staticMap)) { $this->registerPlugins(static::$staticMap); } if ($map !== null) { $this->registerPlugins($map); } } public static function addStaticMap($map) { if (null === $map) { static::$staticMap = array(); return; } if (!is_array($map) && !$map instanceof Traversable) { throw new Exception\InvalidArgumentException('Expects an array or Traversable object'); } foreach ($map as $key => $value) { static::$staticMap[$key] = $value; } } public function registerPlugin($shortName, $className) { $this->plugins[strtolower($shortName)] = $className; return $this; } public function registerPlugins($map) { if (is_string($map)) { if (!class_exists($map)) { throw new Exception\InvalidArgumentException('Map class provided is invalid'); } $map = new $map; } if (is_array($map)) { $map = new ArrayIterator($map); } if (!$map instanceof Traversable) { throw new Exception\InvalidArgumentException('Map provided is invalid; must be traversable'); } if ($map instanceof IteratorAggregate) { $map = $map->getIterator(); } foreach ($map as $name => $class) { if (is_int($name) || is_numeric($name)) { if (!is_object($class) && class_exists($class)) { $class = new $class(); } if ($class instanceof Traversable) { $this->registerPlugins($class); continue; } } $this->registerPlugin($name, $class); } return $this; } public function unregisterPlugin($shortName) { $lookup = strtolower($shortName); if (array_key_exists($lookup, $this->plugins)) { unset($this->plugins[$lookup]); } return $this; } public function getRegisteredPlugins() { return $this->plugins; } public function isLoaded($name) { $lookup = strtolower($name); return isset($this->plugins[$lookup]); } public function getClassName($name) { return $this->load($name); } public function load($name) { if (!$this->isLoaded($name)) { return false; } return $this->plugins[strtolower($name)]; } public function getIterator() { return new ArrayIterator($this->plugins); } } } namespace Zend\Http { use Zend\Loader\PluginClassLoader; class HeaderLoader extends PluginClassLoader { protected $plugins = array( 'accept' => 'Zend\Http\Header\Accept', 'acceptcharset' => 'Zend\Http\Header\AcceptCharset', 'acceptencoding' => 'Zend\Http\Header\AcceptEncoding', 'acceptlanguage' => 'Zend\Http\Header\AcceptLanguage', 'acceptranges' => 'Zend\Http\Header\AcceptRanges', 'age' => 'Zend\Http\Header\Age', 'allow' => 'Zend\Http\Header\Allow', 'authenticationinfo' => 'Zend\Http\Header\AuthenticationInfo', 'authorization' => 'Zend\Http\Header\Authorization', 'cachecontrol' => 'Zend\Http\Header\CacheControl', 'connection' => 'Zend\Http\Header\Connection', 'contentdisposition' => 'Zend\Http\Header\ContentDisposition', 'contentencoding' => 'Zend\Http\Header\ContentEncoding', 'contentlanguage' => 'Zend\Http\Header\ContentLanguage', 'contentlength' => 'Zend\Http\Header\ContentLength', 'contentlocation' => 'Zend\Http\Header\ContentLocation', 'contentmd5' => 'Zend\Http\Header\ContentMD5', 'contentrange' => 'Zend\Http\Header\ContentRange', 'contenttransferencoding' => 'Zend\Http\Header\ContentTransferEncoding', 'contenttype' => 'Zend\Http\Header\ContentType', 'cookie' => 'Zend\Http\Header\Cookie', 'date' => 'Zend\Http\Header\Date', 'etag' => 'Zend\Http\Header\Etag', 'expect' => 'Zend\Http\Header\Expect', 'expires' => 'Zend\Http\Header\Expires', 'from' => 'Zend\Http\Header\From', 'host' => 'Zend\Http\Header\Host', 'ifmatch' => 'Zend\Http\Header\IfMatch', 'ifmodifiedsince' => 'Zend\Http\Header\IfModifiedSince', 'ifnonematch' => 'Zend\Http\Header\IfNoneMatch', 'ifrange' => 'Zend\Http\Header\IfRange', 'ifunmodifiedsince' => 'Zend\Http\Header\IfUnmodifiedSince', 'keepalive' => 'Zend\Http\Header\KeepAlive', 'lastmodified' => 'Zend\Http\Header\LastModified', 'location' => 'Zend\Http\Header\Location', 'maxforwards' => 'Zend\Http\Header\MaxForwards', 'origin' => 'Zend\Http\Header\Origin', 'pragma' => 'Zend\Http\Header\Pragma', 'proxyauthenticate' => 'Zend\Http\Header\ProxyAuthenticate', 'proxyauthorization' => 'Zend\Http\Header\ProxyAuthorization', 'range' => 'Zend\Http\Header\Range', 'referer' => 'Zend\Http\Header\Referer', 'refresh' => 'Zend\Http\Header\Refresh', 'retryafter' => 'Zend\Http\Header\RetryAfter', 'server' => 'Zend\Http\Header\Server', 'setcookie' => 'Zend\Http\Header\SetCookie', 'te' => 'Zend\Http\Header\TE', 'trailer' => 'Zend\Http\Header\Trailer', 'transferencoding' => 'Zend\Http\Header\TransferEncoding', 'upgrade' => 'Zend\Http\Header\Upgrade', 'useragent' => 'Zend\Http\Header\UserAgent', 'vary' => 'Zend\Http\Header\Vary', 'via' => 'Zend\Http\Header\Via', 'warning' => 'Zend\Http\Header\Warning', 'wwwauthenticate' => 'Zend\Http\Header\WWWAuthenticate' ); } } namespace Zend\Http\Header { class Host implements HeaderInterface { protected $value; public static function fromString($headerLine) { list($name, $value) = GenericHeader::splitHeaderLine($headerLine); if (strtolower($name) !== 'host') { throw new Exception\InvalidArgumentException('Invalid header line for Host string: "' . $name . '"'); } $header = new static($value); return $header; } public function __construct($value = null) { $this->value = $value; } public function getFieldName() { return 'Host'; } public function getFieldValue() { return $this->value; } public function toString() { return 'Host: ' . $this->getFieldValue(); } } } namespace Zend\Http\Header { class GenericHeader implements HeaderInterface { protected $fieldName = null; protected $fieldValue = null; public static function fromString($headerLine) { list($fieldName, $fieldValue) = GenericHeader::splitHeaderLine($headerLine); $header = new static($fieldName, $fieldValue); return $header; } public static function splitHeaderLine($headerLine) { $parts = explode(':', $headerLine, 2); if (count($parts) !== 2) { throw new Exception\InvalidArgumentException('Header must match with the format "name:value"'); } $parts[1] = ltrim($parts[1]); return $parts; } public function __construct($fieldName = null, $fieldValue = null) { if ($fieldName) { $this->setFieldName($fieldName); } if ($fieldValue !== null) { $this->setFieldValue($fieldValue); } } public function setFieldName($fieldName) { if (!is_string($fieldName) || empty($fieldName)) { throw new Exception\InvalidArgumentException('Header name must be a string'); } $fieldName = str_replace('_', '-', $fieldName); if (!preg_match('/^[!#-\'*+\-\.0-9A-Z\^-z|~]+$/', $fieldName)) { throw new Exception\InvalidArgumentException( 'Header name must be a valid RFC 2616 (section 4.2) field-name.' ); } $this->fieldName = $fieldName; return $this; } public function getFieldName() { return $this->fieldName; } public function setFieldValue($fieldValue) { $fieldValue = (string) $fieldValue; if (preg_match('/^\s+$/', $fieldValue)) { $fieldValue = ''; } $this->fieldValue = $fieldValue; return $this; } public function getFieldValue() { return $this->fieldValue; } public function toString() { return $this->getFieldName() . ': ' . $this->getFieldValue(); } } } namespace Zend\Validator { use Traversable; use Zend\Stdlib\ArrayUtils; abstract class AbstractValidator implements Translator\TranslatorAwareInterface, ValidatorInterface { protected $value; protected static $defaultTranslator; protected static $defaultTranslatorTextDomain = 'default'; protected static $messageLength = -1; protected $abstractOptions = array( 'messages' => array(), 'messageTemplates' => array(), 'messageVariables' => array(), 'translator' => null, 'translatorTextDomain' => null, 'translatorEnabled' => true, 'valueObscured' => false, ); public function __construct($options = null) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } if (isset($this->messageTemplates)) { $this->abstractOptions['messageTemplates'] = $this->messageTemplates; } if (isset($this->messageVariables)) { $this->abstractOptions['messageVariables'] = $this->messageVariables; } if (is_array($options)) { $this->setOptions($options); } } public function getOption($option) { if (array_key_exists($option, $this->abstractOptions)) { return $this->abstractOptions[$option]; } if (isset($this->options) && array_key_exists($option, $this->options)) { return $this->options[$option]; } throw new Exception\InvalidArgumentException("Invalid option '$option'"); } public function getOptions() { $result = $this->abstractOptions; if (isset($this->options)) { $result += $this->options; } return $result; } public function setOptions($options = array()) { if (!is_array($options) && !$options instanceof Traversable) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable'); } foreach ($options as $name => $option) { $fname = 'set' . ucfirst($name); $fname2 = 'is' . ucfirst($name); if (($name != 'setOptions') && method_exists($this, $name)) { $this->{$name}($option); } elseif (($fname != 'setOptions') && method_exists($this, $fname)) { $this->{$fname}($option); } elseif (method_exists($this, $fname2)) { $this->{$fname2}($option); } elseif (isset($this->options)) { $this->options[$name] = $option; } else { $this->abstractOptions[$name] = $option; } } return $this; } public function getMessages() { return array_unique($this->abstractOptions['messages'], SORT_REGULAR); } public function __invoke($value) { return $this->isValid($value); } public function getMessageVariables() { return array_keys($this->abstractOptions['messageVariables']); } public function getMessageTemplates() { return $this->abstractOptions['messageTemplates']; } public function setMessage($messageString, $messageKey = null) { if ($messageKey === null) { $keys = array_keys($this->abstractOptions['messageTemplates']); foreach ($keys as $key) { $this->setMessage($messageString, $key); } return $this; } if (!isset($this->abstractOptions['messageTemplates'][$messageKey])) { throw new Exception\InvalidArgumentException("No message template exists for key '$messageKey'"); } $this->abstractOptions['messageTemplates'][$messageKey] = $messageString; return $this; } public function setMessages(array $messages) { foreach ($messages as $key => $message) { $this->setMessage($message, $key); } return $this; } public function __get($property) { if ($property == 'value') { return $this->value; } if (array_key_exists($property, $this->abstractOptions['messageVariables'])) { $result = $this->abstractOptions['messageVariables'][$property]; if (is_array($result)) { $result = $this->{key($result)}[current($result)]; } else { $result = $this->{$result}; } return $result; } if (isset($this->messageVariables) && array_key_exists($property, $this->messageVariables)) { $result = $this->{$this->messageVariables[$property]}; if (is_array($result)) { $result = $this->{key($result)}[current($result)]; } else { $result = $this->{$result}; } return $result; } throw new Exception\InvalidArgumentException("No property exists by the name '$property'"); } protected function createMessage($messageKey, $value) { if (!isset($this->abstractOptions['messageTemplates'][$messageKey])) { return null; } $message = $this->abstractOptions['messageTemplates'][$messageKey]; $message = $this->translateMessage($messageKey, $message); if (is_object($value) && !in_array('__toString', get_class_methods($value)) ) { $value = get_class($value) . ' object'; } elseif (is_array($value)) { $value = var_export($value, 1); } else { $value = (string) $value; } if ($this->isValueObscured()) { $value = str_repeat('*', strlen($value)); } $message = str_replace('%value%', (string) $value, $message); foreach ($this->abstractOptions['messageVariables'] as $ident => $property) { if (is_array($property)) { $value = $this->{key($property)}[current($property)]; if (is_array($value)) { $value = '[' . implode(', ', $value) . ']'; } } else { $value = $this->$property; } $message = str_replace("%$ident%", (string) $value, $message); } $length = self::getMessageLength(); if (($length > -1) && (strlen($message) > $length)) { $message = substr($message, 0, ($length - 3)) . '...'; } return $message; } protected function error($messageKey, $value = null) { if ($messageKey === null) { $keys = array_keys($this->abstractOptions['messageTemplates']); $messageKey = current($keys); } if ($value === null) { $value = $this->value; } $this->abstractOptions['messages'][$messageKey] = $this->createMessage($messageKey, $value); } protected function getValue() { return $this->value; } protected function setValue($value) { $this->value = $value; $this->abstractOptions['messages'] = array(); } public function setValueObscured($flag) { $this->abstractOptions['valueObscured'] = (bool) $flag; return $this; } public function isValueObscured() { return $this->abstractOptions['valueObscured']; } public function setTranslator(Translator\TranslatorInterface $translator = null, $textDomain = null) { $this->abstractOptions['translator'] = $translator; if (null !== $textDomain) { $this->setTranslatorTextDomain($textDomain); } return $this; } public function getTranslator() { if (! $this->isTranslatorEnabled()) { return null; } if (null === $this->abstractOptions['translator']) { $this->abstractOptions['translator'] = self::getDefaultTranslator(); } return $this->abstractOptions['translator']; } public function hasTranslator() { return (bool) $this->abstractOptions['translator']; } public function setTranslatorTextDomain($textDomain = 'default') { $this->abstractOptions['translatorTextDomain'] = $textDomain; return $this; } public function getTranslatorTextDomain() { if (null === $this->abstractOptions['translatorTextDomain']) { $this->abstractOptions['translatorTextDomain'] = self::getDefaultTranslatorTextDomain(); } return $this->abstractOptions['translatorTextDomain']; } public static function setDefaultTranslator( Translator\TranslatorInterface $translator = null, $textDomain = null ) { static::$defaultTranslator = $translator; if (null !== $textDomain) { self::setDefaultTranslatorTextDomain($textDomain); } } public static function getDefaultTranslator() { return static::$defaultTranslator; } public static function hasDefaultTranslator() { return (bool) static::$defaultTranslator; } public static function setDefaultTranslatorTextDomain($textDomain = 'default') { static::$defaultTranslatorTextDomain = $textDomain; } public static function getDefaultTranslatorTextDomain() { return static::$defaultTranslatorTextDomain; } public function setTranslatorEnabled($flag = true) { $this->abstractOptions['translatorEnabled'] = (bool) $flag; return $this; } public function isTranslatorEnabled() { return $this->abstractOptions['translatorEnabled']; } public static function getMessageLength() { return static::$messageLength; } public static function setMessageLength($length = -1) { static::$messageLength = $length; } protected function translateMessage($messageKey, $message) { $translator = $this->getTranslator(); if (!$translator) { return $message; } return $translator->translate( $message, $this->getTranslatorTextDomain() ); } } } namespace Zend\Validator { use Zend\Stdlib\ErrorHandler; use Zend\Stdlib\StringUtils; class Hostname extends AbstractValidator { const CANNOT_DECODE_PUNYCODE = 'hostnameCannotDecodePunycode'; const INVALID = 'hostnameInvalid'; const INVALID_DASH = 'hostnameDashCharacter'; const INVALID_HOSTNAME = 'hostnameInvalidHostname'; const INVALID_HOSTNAME_SCHEMA = 'hostnameInvalidHostnameSchema'; const INVALID_LOCAL_NAME = 'hostnameInvalidLocalName'; const INVALID_URI = 'hostnameInvalidUri'; const IP_ADDRESS_NOT_ALLOWED = 'hostnameIpAddressNotAllowed'; const LOCAL_NAME_NOT_ALLOWED = 'hostnameLocalNameNotAllowed'; const UNDECIPHERABLE_TLD = 'hostnameUndecipherableTld'; const UNKNOWN_TLD = 'hostnameUnknownTld'; protected $messageTemplates = array( self::CANNOT_DECODE_PUNYCODE => "The input appears to be a DNS hostname but the given punycode notation cannot be decoded", self::INVALID => "Invalid type given. String expected", self::INVALID_DASH => "The input appears to be a DNS hostname but contains a dash in an invalid position", self::INVALID_HOSTNAME => "The input does not match the expected structure for a DNS hostname", self::INVALID_HOSTNAME_SCHEMA => "The input appears to be a DNS hostname but cannot match against hostname schema for TLD '%tld%'", self::INVALID_LOCAL_NAME => "The input does not appear to be a valid local network name", self::INVALID_URI => "The input does not appear to be a valid URI hostname", self::IP_ADDRESS_NOT_ALLOWED => "The input appears to be an IP address, but IP addresses are not allowed", self::LOCAL_NAME_NOT_ALLOWED => "The input appears to be a local network name but local network names are not allowed", self::UNDECIPHERABLE_TLD => "The input appears to be a DNS hostname but cannot extract TLD part", self::UNKNOWN_TLD => "The input appears to be a DNS hostname but cannot match TLD against known list", ); protected $messageVariables = array( 'tld' => 'tld', ); const ALLOW_DNS = 1; const ALLOW_IP = 2; const ALLOW_LOCAL = 4; const ALLOW_URI = 8; const ALLOW_ALL = 15; protected $validTlds = array( 'ac', 'academy', 'actor', 'ad', 'ae', 'aero', 'af', 'ag', 'agency', 'ai', 'al', 'am', 'an', 'ao', 'aq', 'ar', 'arpa', 'as', 'asia', 'at', 'au', 'aw', 'ax', 'az', 'ba', 'bar', 'bargains', 'bb', 'bd', 'be', 'berlin', 'best', 'bf', 'bg', 'bh', 'bi', 'bike', 'biz', 'bj', 'bl', 'blue', 'bm', 'bn', 'bo', 'boutique', 'bq', 'br', 'bs', 'bt', 'build', 'builders', 'buzz', 'bv', 'bw', 'by', 'bz', 'ca', 'cab', 'camera', 'camp', 'cards', 'careers', 'cat', 'catering', 'cc', 'cd', 'center', 'ceo', 'cf', 'cg', 'ch', 'cheap', 'christmas', 'ci', 'ck', 'cl', 'cleaning', 'clothing', 'club', 'cm', 'cn', 'co', 'codes', 'coffee', 'com', 'community', 'company', 'computer', 'construction', 'contractors', 'cool', 'coop', 'cr', 'cruises', 'cu', 'cv', 'cw', 'cx', 'cy', 'cz', 'dance', 'dating', 'de', 'democrat', 'diamonds', 'directory', 'dj', 'dk', 'dm', 'do', 'domains', 'dz', 'ec', 'edu', 'education', 'ee', 'eg', 'eh', 'email', 'enterprises', 'equipment', 'er', 'es', 'estate', 'et', 'eu', 'events', 'expert', 'exposed', 'farm', 'fi', 'fish', 'fj', 'fk', 'flights', 'florist', 'fm', 'fo', 'foundation', 'fr', 'futbol', 'ga', 'gallery', 'gb', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gift', 'gl', 'glass', 'gm', 'gn', 'gov', 'gp', 'gq', 'gr', 'graphics', 'gs', 'gt', 'gu', 'guitars', 'guru', 'gw', 'gy', 'hk', 'hm', 'hn', 'holdings', 'holiday', 'house', 'hr', 'ht', 'hu', 'id', 'ie', 'il', 'im', 'immobilien', 'in', 'industries', 'info', 'institute', 'int', 'international', 'io', 'iq', 'ir', 'is', 'it', 'je', 'jm', 'jo', 'jobs', 'jp', 'kaufen', 'ke', 'kg', 'kh', 'ki', 'kim', 'kitchen', 'kiwi', 'km', 'kn', 'kp', 'kr', 'kred', 'kw', 'ky', 'kz', 'la', 'land', 'lb', 'lc', 'li', 'lighting', 'limo', 'link', 'lk', 'lr', 'ls', 'lt', 'lu', 'luxury', 'lv', 'ly', 'ma', 'management', 'mango', 'marketing', 'mc', 'md', 'me', 'menu', 'mf', 'mg', 'mh', 'mil', 'mk', 'ml', 'mm', 'mn', 'mo', 'mobi', 'moda', 'monash', 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'museum', 'mv', 'mw', 'mx', 'my', 'mz', 'na', 'nagoya', 'name', 'nc', 'ne', 'net', 'neustar', 'nf', 'ng', 'ni', 'ninja', 'nl', 'no', 'np', 'nr', 'nu', 'nz', 'om', 'onl', 'org', 'pa', 'partners', 'parts', 'pe', 'pf', 'pg', 'ph', 'photo', 'photography', 'photos', 'pics', 'pink', 'pk', 'pl', 'plumbing', 'pm', 'pn', 'post', 'pr', 'pro', 'productions', 'properties', 'ps', 'pt', 'pub', 'pw', 'py', 'qa', 'qpon', 're', 'recipes', 'red', 'rentals', 'repair', 'report', 'reviews', 'rich', 'ro', 'rs', 'ru', 'ruhr', 'rw', 'sa', 'sb', 'sc', 'sd', 'se', 'sexy', 'sg', 'sh', 'shiksha', 'shoes', 'si', 'singles', 'sj', 'sk', 'sl', 'sm', 'sn', 'so', 'social', 'solar', 'solutions', 'sr', 'ss', 'st', 'su', 'supplies', 'supply', 'support', 'sv', 'sx', 'sy', 'systems', 'sz', 'tattoo', 'tc', 'td', 'technology', 'tel', 'tf', 'tg', 'th', 'tienda', 'tips', 'tj', 'tk', 'tl', 'tm', 'tn', 'to', 'today', 'tokyo', 'tools', 'tp', 'tr', 'training', 'travel', 'tt', 'tv', 'tw', 'tz', 'ua', 'ug', 'uk', 'um', 'uno', 'us', 'uy', 'uz', 'va', 'vacations', 'vc', 've', 'ventures', 'vg', 'vi', 'viajes', 'villas', 'vision', 'vn', 'voting', 'voyage', 'vu', 'wang', 'watch', 'wed', 'wf', 'wien', 'wiki', 'works', 'ws', '测试', 'परीक्षा', '集团', '在线', '한국', 'ভারত', 'বাংলা', '公益', '公司', '移动', '我爱你', 'испытание', 'қаз', 'онлайн', 'сайт', 'срб', '테스트', '삼성', 'சிங்கப்பூர்', 'дети', 'טעסט', '中文网', '中信', '中国', '中國', 'భారత్', 'ලංකා', '測試', 'ભારત', 'भारत', 'آزمایشی', 'பரிட்சை', '网络', 'укр', '香港', 'δοκιμή', 'إختبار', '台湾', '台灣', 'мон', 'الجزائر', 'عمان', 'ایران', 'امارات', 'بازار', 'پاکستان', 'الاردن', 'بھارت', 'المغرب', 'السعودية', 'سودان', 'مليسيا', 'شبكة', 'გე', 'ไทย', 'سورية', 'рф', 'تونس', 'みんな', 'ਭਾਰਤ', '游戏', 'مصر', 'قطر', 'இலங்கை', 'இந்தியா', '新加坡', 'فلسطين', 'テスト', '政务', 'xxx', 'xyz', 'ye', 'yt', 'za', 'zm', 'zone', 'zw' ); protected $validIdns = array( 'AC' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćĉċčďđēėęěĝġģĥħīįĵķĺļľŀłńņňŋőœŕŗřśŝşšţťŧūŭůűųŵŷźżž]{1,63}$/iu'), 'AR' => array(1 => '/^[\x{002d}0-9a-zà-ãç-êìíñ-õü]{1,63}$/iu'), 'AS' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĵķĸĺļľłńņňŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźż]{1,63}$/iu'), 'AT' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿœšž]{1,63}$/iu'), 'BIZ' => 'Hostname/Biz.php', 'BR' => array(1 => '/^[\x{002d}0-9a-zà-ãçéíó-õúü]{1,63}$/iu'), 'BV' => array(1 => '/^[\x{002d}0-9a-zàáä-éêñ-ôöøüčđńŋšŧž]{1,63}$/iu'), 'CAT' => array(1 => '/^[\x{002d}0-9a-z·àç-éíïòóúü]{1,63}$/iu'), 'CH' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿœ]{1,63}$/iu'), 'CL' => array(1 => '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu'), 'CN' => 'Hostname/Cn.php', 'COM' => 'Hostname/Com.php', 'DE' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿăąāćĉčċďđĕěėęēğĝġģĥħĭĩįīıĵķĺľļłńňņŋŏőōœĸŕřŗśŝšşťţŧŭůűũųūŵŷźžż]{1,63}$/iu'), 'DK' => array(1 => '/^[\x{002d}0-9a-zäéöü]{1,63}$/iu'), 'ES' => array(1 => '/^[\x{002d}0-9a-zàáçèéíïñòóúü·]{1,63}$/iu'), 'EU' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿ]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-zāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĵķĺļľŀłńņňŉŋōŏőœŕŗřśŝšťŧũūŭůűųŵŷźżž]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-zșț]{1,63}$/iu', 4 => '/^[\x{002d}0-9a-zΐάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ]{1,63}$/iu', 5 => '/^[\x{002d}0-9a-zабвгдежзийклмнопрстуфхцчшщъыьэюя]{1,63}$/iu', 6 => '/^[\x{002d}0-9a-zἀ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ὼώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷῂῃῄῆῇῐ-ῒΐῖῗῠ-ῧῲῳῴῶῷ]{1,63}$/iu'), 'FI' => array(1 => '/^[\x{002d}0-9a-zäåö]{1,63}$/iu'), 'GR' => array(1 => '/^[\x{002d}0-9a-zΆΈΉΊΌΎ-ΡΣ-ώἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼῂῃῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲῳῴῶ-ῼ]{1,63}$/iu'), 'HK' => 'Hostname/Cn.php', 'HU' => array(1 => '/^[\x{002d}0-9a-záéíóöúüőű]{1,63}$/iu'), 'IL' => array(1 => '/^[\x{002d}0-9\x{05D0}-\x{05EA}]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-z]{1,63}$/i'), 'INFO'=> array(1 => '/^[\x{002d}0-9a-zäåæéöøü]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-záéíóöúüőű]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-záæéíðóöúýþ]{1,63}$/iu', 4 => '/^[\x{AC00}-\x{D7A3}]{1,17}$/iu', 5 => '/^[\x{002d}0-9a-zāčēģīķļņōŗšūž]{1,63}$/iu', 6 => '/^[\x{002d}0-9a-ząčėęįšūųž]{1,63}$/iu', 7 => '/^[\x{002d}0-9a-zóąćęłńśźż]{1,63}$/iu', 8 => '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu'), 'IO' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿăąāćĉčċďđĕěėęēğĝġģĥħĭĩįīıĵķĺľļłńňņŋŏőōœĸŕřŗśŝšşťţŧŭůűũųūŵŷźžż]{1,63}$/iu'), 'IS' => array(1 => '/^[\x{002d}0-9a-záéýúíóþæöð]{1,63}$/iu'), 'IT' => array(1 => '/^[\x{002d}0-9a-zàâäèéêëìîïòôöùûüæœçÿß-]{1,63}$/iu'), 'JP' => 'Hostname/Jp.php', 'KR' => array(1 => '/^[\x{AC00}-\x{D7A3}]{1,17}$/iu'), 'LI' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿœ]{1,63}$/iu'), 'LT' => array(1 => '/^[\x{002d}0-9ąčęėįšųūž]{1,63}$/iu'), 'MD' => array(1 => '/^[\x{002d}0-9ăâîşţ]{1,63}$/iu'), 'MUSEUM' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćċčďđēėęěğġģħīįıķĺļľłńņňŋōőœŕŗřśşšţťŧūůűųŵŷźżžǎǐǒǔ\x{01E5}\x{01E7}\x{01E9}\x{01EF}ə\x{0292}ẁẃẅỳ]{1,63}$/iu'), 'NET' => 'Hostname/Com.php', 'NO' => array(1 => '/^[\x{002d}0-9a-zàáä-éêñ-ôöøüčđńŋšŧž]{1,63}$/iu'), 'NU' => 'Hostname/Com.php', 'ORG' => array(1 => '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-zóąćęłńśźż]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-záäåæéëíðóöøúüýþ]{1,63}$/iu', 4 => '/^[\x{002d}0-9a-záéíóöúüőű]{1,63}$/iu', 5 => '/^[\x{002d}0-9a-ząčėęįšūųž]{1,63}$/iu', 6 => '/^[\x{AC00}-\x{D7A3}]{1,17}$/iu', 7 => '/^[\x{002d}0-9a-zāčēģīķļņōŗšūž]{1,63}$/iu'), 'PE' => array(1 => '/^[\x{002d}0-9a-zñáéíóúü]{1,63}$/iu'), 'PL' => array(1 => '/^[\x{002d}0-9a-zāčēģīķļņōŗšūž]{1,63}$/iu', 2 => '/^[\x{002d}а-ик-ш\x{0450}ѓѕјљњќџ]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-zâîăşţ]{1,63}$/iu', 4 => '/^[\x{002d}0-9а-яё\x{04C2}]{1,63}$/iu', 5 => '/^[\x{002d}0-9a-zàáâèéêìíîòóôùúûċġħż]{1,63}$/iu', 6 => '/^[\x{002d}0-9a-zàäåæéêòóôöøü]{1,63}$/iu', 7 => '/^[\x{002d}0-9a-zóąćęłńśźż]{1,63}$/iu', 8 => '/^[\x{002d}0-9a-zàáâãçéêíòóôõúü]{1,63}$/iu', 9 => '/^[\x{002d}0-9a-zâîăşţ]{1,63}$/iu', 10=> '/^[\x{002d}0-9a-záäéíóôúýčďĺľňŕšťž]{1,63}$/iu', 11=> '/^[\x{002d}0-9a-zçë]{1,63}$/iu', 12=> '/^[\x{002d}0-9а-ик-шђјљњћџ]{1,63}$/iu', 13=> '/^[\x{002d}0-9a-zćčđšž]{1,63}$/iu', 14=> '/^[\x{002d}0-9a-zâçöûüğış]{1,63}$/iu', 15=> '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu', 16=> '/^[\x{002d}0-9a-zäõöüšž]{1,63}$/iu', 17=> '/^[\x{002d}0-9a-zĉĝĥĵŝŭ]{1,63}$/iu', 18=> '/^[\x{002d}0-9a-zâäéëîô]{1,63}$/iu', 19=> '/^[\x{002d}0-9a-zàáâäåæçèéêëìíîïðñòôöøùúûüýćčłńřśš]{1,63}$/iu', 20=> '/^[\x{002d}0-9a-zäåæõöøüšž]{1,63}$/iu', 21=> '/^[\x{002d}0-9a-zàáçèéìíòóùú]{1,63}$/iu', 22=> '/^[\x{002d}0-9a-zàáéíóöúüőű]{1,63}$/iu', 23=> '/^[\x{002d}0-9ΐά-ώ]{1,63}$/iu', 24=> '/^[\x{002d}0-9a-zàáâåæçèéêëðóôöøüþœ]{1,63}$/iu', 25=> '/^[\x{002d}0-9a-záäéíóöúüýčďěňřšťůž]{1,63}$/iu', 26=> '/^[\x{002d}0-9a-z·àçèéíïòóúü]{1,63}$/iu', 27=> '/^[\x{002d}0-9а-ъьюя\x{0450}\x{045D}]{1,63}$/iu', 28=> '/^[\x{002d}0-9а-яёіў]{1,63}$/iu', 29=> '/^[\x{002d}0-9a-ząčėęįšūųž]{1,63}$/iu', 30=> '/^[\x{002d}0-9a-záäåæéëíðóöøúüýþ]{1,63}$/iu', 31=> '/^[\x{002d}0-9a-zàâæçèéêëîïñôùûüÿœ]{1,63}$/iu', 32=> '/^[\x{002d}0-9а-щъыьэюяёєіїґ]{1,63}$/iu', 33=> '/^[\x{002d}0-9א-ת]{1,63}$/iu'), 'PR' => array(1 => '/^[\x{002d}0-9a-záéíóúñäëïüöâêîôûàèùæçœãõ]{1,63}$/iu'), 'PT' => array(1 => '/^[\x{002d}0-9a-záàâãçéêíóôõú]{1,63}$/iu'), 'RU' => array(1 => '/^[\x{002d}0-9а-яё]{1,63}$/iu'), 'SA' => array(1 => '/^[\x{002d}.0-9\x{0621}-\x{063A}\x{0641}-\x{064A}\x{0660}-\x{0669}]{1,63}$/iu'), 'SE' => array(1 => '/^[\x{002d}0-9a-zäåéöü]{1,63}$/iu'), 'SH' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿăąāćĉčċďđĕěėęēğĝġģĥħĭĩįīıĵķĺľļłńňņŋŏőōœĸŕřŗśŝšşťţŧŭůűũųūŵŷźžż]{1,63}$/iu'), 'SI' => array( 1 => '/^[\x{002d}0-9a-zà-öø-ÿ]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-zāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĵķĺļľŀłńņňŉŋōŏőœŕŗřśŝšťŧũūŭůűųŵŷźżž]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-zșț]{1,63}$/iu'), 'SJ' => array(1 => '/^[\x{002d}0-9a-zàáä-éêñ-ôöøüčđńŋšŧž]{1,63}$/iu'), 'TH' => array(1 => '/^[\x{002d}0-9a-z\x{0E01}-\x{0E3A}\x{0E40}-\x{0E4D}\x{0E50}-\x{0E59}]{1,63}$/iu'), 'TM' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćĉċčďđēėęěĝġģĥħīįĵķĺļľŀłńņňŋőœŕŗřśŝşšţťŧūŭůűųŵŷźżž]{1,63}$/iu'), 'TW' => 'Hostname/Cn.php', 'TR' => array(1 => '/^[\x{002d}0-9a-zğıüşöç]{1,63}$/iu'), 'UA' => array(1 => '/^[\x{002d}0-9a-zабвгдежзийклмнопрстуфхцчшщъыьэюяѐёђѓєѕіїјљњћќѝўџґӂʼ]{1,63}$/iu'), 'VE' => array(1 => '/^[\x{002d}0-9a-záéíóúüñ]{1,63}$/iu'), 'VN' => array(1 => '/^[ÀÁÂÃÈÉÊÌÍÒÓÔÕÙÚÝàáâãèéêìíòóôõùúýĂăĐđĨĩŨũƠơƯư\x{1EA0}-\x{1EF9}]{1,63}$/iu'), 'мон' => array(1 => '/^[\x{002d}0-9\x{0430}-\x{044F}]{1,63}$/iu'), 'срб' => array(1 => '/^[\x{002d}0-9а-ик-шђјљњћџ]{1,63}$/iu'), 'сайт' => array(1 => '/^[\x{002d}0-9а-яёіїѝйўґг]{1,63}$/iu'), 'онлайн' => array(1 => '/^[\x{002d}0-9а-яёіїѝйўґг]{1,63}$/iu'), '中国' => 'Hostname/Cn.php', '中國' => 'Hostname/Cn.php', 'ලංකා' => array(1 => '/^[\x{0d80}-\x{0dff}]{1,63}$/iu'), '香港' => 'Hostname/Cn.php', '台湾' => 'Hostname/Cn.php', '台灣' => 'Hostname/Cn.php', 'امارات' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'الاردن' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'السعودية' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'ไทย' => array(1 => '/^[\x{002d}0-9a-z\x{0E01}-\x{0E3A}\x{0E40}-\x{0E4D}\x{0E50}-\x{0E59}]{1,63}$/iu'), 'рф' => array(1 => '/^[\x{002d}0-9а-яё]{1,63}$/iu'), 'تونس' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'مصر' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'இலங்கை' => array(1 => '/^[\x{0b80}-\x{0bff}]{1,63}$/iu'), 'فلسطين' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), 'شبكة' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), ); protected $idnLength = array( 'BIZ' => array(5 => 17, 11 => 15, 12 => 20), 'CN' => array(1 => 20), 'COM' => array(3 => 17, 5 => 20), 'HK' => array(1 => 15), 'INFO'=> array(4 => 17), 'KR' => array(1 => 17), 'NET' => array(3 => 17, 5 => 20), 'ORG' => array(6 => 17), 'TW' => array(1 => 20), 'امارات' => array(1 => 30), 'الاردن' => array(1 => 30), 'السعودية' => array(1 => 30), 'تونس' => array(1 => 30), 'مصر' => array(1 => 30), 'فلسطين' => array(1 => 30), 'شبكة' => array(1 => 30), '中国' => array(1 => 20), '中國' => array(1 => 20), '香港' => array(1 => 20), '台湾' => array(1 => 20), '台灣' => array(1 => 20), ); protected $tld; protected $options = array( 'allow' => self::ALLOW_DNS, 'useIdnCheck' => true, 'useTldCheck' => true, 'ipValidator' => null, ); public function __construct($options = array()) { if (!is_array($options)) { $options = func_get_args(); $temp['allow'] = array_shift($options); if (!empty($options)) { $temp['useIdnCheck'] = array_shift($options); } if (!empty($options)) { $temp['useTldCheck'] = array_shift($options); } if (!empty($options)) { $temp['ipValidator'] = array_shift($options); } $options = $temp; } if (!array_key_exists('ipValidator', $options)) { $options['ipValidator'] = null; } parent::__construct($options); } public function getIpValidator() { return $this->options['ipValidator']; } public function setIpValidator(Ip $ipValidator = null) { if ($ipValidator === null) { $ipValidator = new Ip(); } $this->options['ipValidator'] = $ipValidator; return $this; } public function getAllow() { return $this->options['allow']; } public function setAllow($allow) { $this->options['allow'] = $allow; return $this; } public function getIdnCheck() { return $this->options['useIdnCheck']; } public function useIdnCheck($useIdnCheck) { $this->options['useIdnCheck'] = (bool) $useIdnCheck; return $this; } public function getTldCheck() { return $this->options['useTldCheck']; } public function useTldCheck($useTldCheck) { $this->options['useTldCheck'] = (bool) $useTldCheck; return $this; } public function isValid($value) { if (!is_string($value)) { $this->error(self::INVALID); return false; } $this->setValue($value); if (preg_match('/^[0-9a-f:.]*$/i', $value) && $this->getIpValidator() ->setTranslator($this->getTranslator()) ->isValid($value)) { if (!($this->getAllow() & self::ALLOW_IP)) { $this->error(self::IP_ADDRESS_NOT_ALLOWED); return false; } else { return true; } } if ($this->getAllow() & self::ALLOW_LOCAL) { if (substr($value, -1) === '.') { $value = substr($value, 0, -1); if (substr($value, -1) === '.') { $this->error(self::INVALID_LOCAL_NAME); return false; } } } $domainParts = explode('.', $value); if ((count($domainParts) == 4) && preg_match('/^[0-9.a-e:.]*$/i', $value) && $this->getIpValidator() ->setTranslator($this->getTranslator()) ->isValid($value)) { $this->error(self::INVALID_LOCAL_NAME); } $utf8StrWrapper = StringUtils::getWrapper('UTF-8'); if ((count($domainParts) > 1) && ($utf8StrWrapper->strlen($value) >= 4) && ($utf8StrWrapper->strlen($value) <= 254)) { $status = false; do { $matches = array(); if (preg_match('/([^.]{2,10})$/iu', end($domainParts), $matches) || (array_key_exists(end($domainParts), $this->validIdns))) { reset($domainParts); $this->tld = strtoupper($matches[1]); if ($this->getTldCheck()) { if (!in_array(strtolower($this->tld), $this->validTlds) && !in_array($this->tld, $this->validTlds)) { $this->error(self::UNKNOWN_TLD); $status = false; break; } array_pop($domainParts); } $regexChars = array(0 => '/^[a-z0-9\x2d]{1,63}$/i'); if ($this->getIdnCheck() && isset($this->validIdns[$this->tld])) { if (is_string($this->validIdns[$this->tld])) { $regexChars += include 'C:\xampp\htdocs\privat\php\zend2\studentbox_dev\vendor\zendframework\zendframework\library\Zend\Validator' . '/' . $this->validIdns[$this->tld]; } else { $regexChars += $this->validIdns[$this->tld]; } } $check = 0; foreach ($domainParts as $domainPart) { if (strpos($domainPart, 'xn--') === 0) { $domainPart = $this->decodePunycode(substr($domainPart, 4)); if ($domainPart === false) { return false; } } if (($utf8StrWrapper->strpos($domainPart, '-') === 0) || (($utf8StrWrapper->strlen($domainPart) > 2) && ($utf8StrWrapper->strpos($domainPart, '-', 2) == 2) && ($utf8StrWrapper->strpos($domainPart, '-', 3) == 3)) || ($utf8StrWrapper->strpos($domainPart, '-') === ($utf8StrWrapper->strlen($domainPart) - 1))) { $this->error(self::INVALID_DASH); $status = false; break 2; } $checked = false; foreach ($regexChars as $regexKey => $regexChar) { ErrorHandler::start(); $status = preg_match($regexChar, $domainPart); ErrorHandler::stop(); if ($status > 0) { $length = 63; if (array_key_exists($this->tld, $this->idnLength) && (array_key_exists($regexKey, $this->idnLength[$this->tld]))) { $length = $this->idnLength[$this->tld]; } if ($utf8StrWrapper->strlen($domainPart) > $length) { $this->error(self::INVALID_HOSTNAME); $status = false; } else { $checked = true; break; } } } if ($checked) { ++$check; } } if ($check !== count($domainParts)) { $this->error(self::INVALID_HOSTNAME_SCHEMA); $status = false; } } else { $this->error(self::UNDECIPHERABLE_TLD); $status = false; } } while (false); if ($status && ($this->getAllow() & self::ALLOW_DNS)) { return true; } } elseif ($this->getAllow() & self::ALLOW_DNS) { $this->error(self::INVALID_HOSTNAME); $status = false; } if ($this->getAllow() & self::ALLOW_URI) { if (preg_match("/^([a-zA-Z0-9-._~!$&\'()*+,;=]|%[[:xdigit:]]{2}){1,254}$/i", $value)) { return true; } else { $this->error(self::INVALID_URI); } } ErrorHandler::start(); $regexLocal = '/^(([a-zA-Z0-9\x2d]{1,63}\x2e)*[a-zA-Z0-9\x2d]{1,63}[\x2e]{0,1}){1,254}$/'; $status = preg_match($regexLocal, $value); ErrorHandler::stop(); $allowLocal = $this->getAllow() & self::ALLOW_LOCAL; if ($status && $allowLocal) { return true; } if (!$status) { $this->error(self::INVALID_LOCAL_NAME); } if ($status && !$allowLocal) { $this->error(self::LOCAL_NAME_NOT_ALLOWED); } return false; } protected function decodePunycode($encoded) { if (!preg_match('/^[a-z0-9-]+$/i', $encoded)) { $this->error(self::CANNOT_DECODE_PUNYCODE); return false; } $decoded = array(); $separator = strrpos($encoded, '-'); if ($separator > 0) { for ($x = 0; $x < $separator; ++$x) { $decoded[] = ord($encoded[$x]); } } $lengthd = count($decoded); $lengthe = strlen($encoded); $init = true; $base = 72; $index = 0; $char = 0x80; for ($indexe = ($separator) ? ($separator + 1) : 0; $indexe < $lengthe; ++$lengthd) { for ($oldIndex = $index, $pos = 1, $key = 36; 1; $key += 36) { $hex = ord($encoded[$indexe++]); $digit = ($hex - 48 < 10) ? $hex - 22 : (($hex - 65 < 26) ? $hex - 65 : (($hex - 97 < 26) ? $hex - 97 : 36)); $index += $digit * $pos; $tag = ($key <= $base) ? 1 : (($key >= $base + 26) ? 26 : ($key - $base)); if ($digit < $tag) { break; } $pos = (int) ($pos * (36 - $tag)); } $delta = intval($init ? (($index - $oldIndex) / 700) : (($index - $oldIndex) / 2)); $delta += intval($delta / ($lengthd + 1)); for ($key = 0; $delta > 910 / 2; $key += 36) { $delta = intval($delta / 35); } $base = intval($key + 36 * $delta / ($delta + 38)); $init = false; $char += (int) ($index / ($lengthd + 1)); $index %= ($lengthd + 1); if ($lengthd > 0) { for ($i = $lengthd; $i > $index; $i--) { $decoded[$i] = $decoded[($i - 1)]; } } $decoded[$index++] = $char; } foreach ($decoded as $key => $value) { if ($value < 128) { $decoded[$key] = chr($value); } elseif ($value < (1 << 11)) { $decoded[$key] = chr(192 + ($value >> 6)); $decoded[$key] .= chr(128 + ($value & 63)); } elseif ($value < (1 << 16)) { $decoded[$key] = chr(224 + ($value >> 12)); $decoded[$key] .= chr(128 + (($value >> 6) & 63)); $decoded[$key] .= chr(128 + ($value & 63)); } elseif ($value < (1 << 21)) { $decoded[$key] = chr(240 + ($value >> 18)); $decoded[$key] .= chr(128 + (($value >> 12) & 63)); $decoded[$key] .= chr(128 + (($value >> 6) & 63)); $decoded[$key] .= chr(128 + ($value & 63)); } else { $this->error(self::CANNOT_DECODE_PUNYCODE); return false; } } return implode($decoded); } } } namespace Zend\Validator { use Traversable; class Ip extends AbstractValidator { const INVALID = 'ipInvalid'; const NOT_IP_ADDRESS = 'notIpAddress'; protected $messageTemplates = array( self::INVALID => 'Invalid type given. String expected', self::NOT_IP_ADDRESS => "The input does not appear to be a valid IP address", ); protected $options = array( 'allowipv4' => true, 'allowipv6' => true, 'allowipvfuture' => false, 'allowliteral' => true, ); public function setOptions($options = array()) { parent::setOptions($options); if (!$this->options['allowipv4'] && !$this->options['allowipv6'] && !$this->options['allowipvfuture']) { throw new Exception\InvalidArgumentException('Nothing to validate. Check your options'); } return $this; } public function isValid($value) { if (!is_string($value)) { $this->error(self::INVALID); return false; } $this->setValue($value); if ($this->options['allowipv4'] && $this->validateIPv4($value)) { return true; } else { if ((bool) $this->options['allowliteral']) { static $regex = '/^\[(.*)\]$/'; if ((bool) preg_match($regex, $value, $matches)) { $value = $matches[1]; } } if (($this->options['allowipv6'] && $this->validateIPv6($value)) || ($this->options['allowipvfuture'] && $this->validateIPvFuture($value)) ) { return true; } } $this->error(self::NOT_IP_ADDRESS); return false; } protected function validateIPv4($value) { if (preg_match('/^([01]{8}.){3}[01]{8}\z/i', $value)) { $value = bindec(substr($value, 0, 8)) . '.' . bindec(substr($value, 9, 8)) . '.' . bindec(substr($value, 18, 8)) . '.' . bindec(substr($value, 27, 8)); } elseif (preg_match('/^([0-9]{3}.){3}[0-9]{3}\z/i', $value)) { $value = (int) substr($value, 0, 3) . '.' . (int) substr($value, 4, 3) . '.' . (int) substr($value, 8, 3) . '.' . (int) substr($value, 12, 3); } elseif (preg_match('/^([0-9a-f]{2}.){3}[0-9a-f]{2}\z/i', $value)) { $value = hexdec(substr($value, 0, 2)) . '.' . hexdec(substr($value, 3, 2)) . '.' . hexdec(substr($value, 6, 2)) . '.' . hexdec(substr($value, 9, 2)); } $ip2long = ip2long($value); if ($ip2long === false) { return false; } return ($value == long2ip($ip2long)); } protected function validateIPv6($value) { if (strlen($value) < 3) { return $value == '::'; } if (strpos($value, '.')) { $lastcolon = strrpos($value, ':'); if (!($lastcolon && $this->validateIPv4(substr($value, $lastcolon + 1)))) { return false; } $value = substr($value, 0, $lastcolon) . ':0:0'; } if (strpos($value, '::') === false) { return preg_match('/\A(?:[a-f0-9]{1,4}:){7}[a-f0-9]{1,4}\z/i', $value); } $colonCount = substr_count($value, ':'); if ($colonCount < 8) { return preg_match('/\A(?::|(?:[a-f0-9]{1,4}:)+):(?:(?:[a-f0-9]{1,4}:)*[a-f0-9]{1,4})?\z/i', $value); } if ($colonCount == 8) { return preg_match('/\A(?:::)?(?:[a-f0-9]{1,4}:){6}[a-f0-9]{1,4}(?:::)?\z/i', $value); } return false; } protected function validateIPvFuture($value) { static $regex = '/^v([[:xdigit:]]+)\.[[:alnum:]\-\._~!\$&\'\(\)\*\+,;=:]+$/'; $result = (bool) preg_match($regex, $value, $matches); return ($result && $matches[1] != 4 && $matches[1] != 6); } } } namespace Zend\Stdlib { use Zend\Stdlib\StringWrapper\StringWrapperInterface; abstract class StringUtils { protected static $wrapperRegistry = null; protected static $singleByteEncodings = array( 'ASCII', '7BIT', '8BIT', 'ISO-8859-1', 'ISO-8859-2', 'ISO-8859-3', 'ISO-8859-4', 'ISO-8859-5', 'ISO-8859-6', 'ISO-8859-7', 'ISO-8859-8', 'ISO-8859-9', 'ISO-8859-10', 'ISO-8859-11', 'ISO-8859-13', 'ISO-8859-14', 'ISO-8859-15', 'ISO-8859-16', 'CP-1251', 'CP-1252', ); protected static $hasPcreUnicodeSupport = null; public static function getRegisteredWrappers() { if (static::$wrapperRegistry === null) { static::$wrapperRegistry = array(); if (extension_loaded('intl')) { static::$wrapperRegistry[] = 'Zend\Stdlib\StringWrapper\Intl'; } if (extension_loaded('mbstring')) { static::$wrapperRegistry[] = 'Zend\Stdlib\StringWrapper\MbString'; } if (extension_loaded('iconv')) { static::$wrapperRegistry[] = 'Zend\Stdlib\StringWrapper\Iconv'; } static::$wrapperRegistry[] = 'Zend\Stdlib\StringWrapper\Native'; } return static::$wrapperRegistry; } public static function registerWrapper($wrapper) { $wrapper = (string) $wrapper; if (!in_array($wrapper, static::$wrapperRegistry, true)) { static::$wrapperRegistry[] = $wrapper; } } public static function unregisterWrapper($wrapper) { $index = array_search((string) $wrapper, static::$wrapperRegistry, true); if ($index !== false) { unset(static::$wrapperRegistry[$index]); } } public static function resetRegisteredWrappers() { static::$wrapperRegistry = null; } public static function getWrapper($encoding = 'UTF-8', $convertEncoding = null) { foreach (static::getRegisteredWrappers() as $wrapperClass) { if ($wrapperClass::isSupported($encoding, $convertEncoding)) { $wrapper = new $wrapperClass($encoding, $convertEncoding); $wrapper->setEncoding($encoding, $convertEncoding); return $wrapper; } } throw new Exception\RuntimeException( 'No wrapper found supporting "' . $encoding . '"' . (($convertEncoding !== null) ? ' and "' . $convertEncoding . '"' : '') ); } public static function getSingleByteEncodings() { return static::$singleByteEncodings; } public static function isSingleByteEncoding($encoding) { return in_array(strtoupper($encoding), static::$singleByteEncodings); } public static function isValidUtf8($str) { return is_string($str) && ($str === '' || preg_match('/^./su', $str) == 1); } public static function hasPcreUnicodeSupport() { if (static::$hasPcreUnicodeSupport === null) { ErrorHandler::start(); static::$hasPcreUnicodeSupport = defined('PREG_BAD_UTF8_OFFSET_ERROR') && preg_match('/\pL/u', 'a') == 1; ErrorHandler::stop(); } return static::$hasPcreUnicodeSupport; } } } namespace Zend\Stdlib\StringWrapper { use Zend\Stdlib\Exception; use Zend\Stdlib\StringUtils; abstract class AbstractStringWrapper implements StringWrapperInterface { protected $encoding = 'UTF-8'; protected $convertEncoding; public static function isSupported($encoding, $convertEncoding = null) { $supportedEncodings = static::getSupportedEncodings(); if (!in_array(strtoupper($encoding), $supportedEncodings)) { return false; } if ($convertEncoding !== null && !in_array(strtoupper($convertEncoding), $supportedEncodings)) { return false; } return true; } public function setEncoding($encoding, $convertEncoding = null) { $supportedEncodings = static::getSupportedEncodings(); $encodingUpper = strtoupper($encoding); if (!in_array($encodingUpper, $supportedEncodings)) { throw new Exception\InvalidArgumentException( 'Wrapper doesn\'t support character encoding "' . $encoding . '"' ); } if ($convertEncoding !== null) { $convertEncodingUpper = strtoupper($convertEncoding); if (!in_array($convertEncodingUpper, $supportedEncodings)) { throw new Exception\InvalidArgumentException( 'Wrapper doesn\'t support character encoding "' . $convertEncoding . '"' ); } $this->convertEncoding = $convertEncodingUpper; } else { $this->convertEncoding = null; } $this->encoding = $encodingUpper; return $this; } public function getEncoding() { return $this->encoding; } public function getConvertEncoding() { return $this->convertEncoding; } public function convert($str, $reverse = false) { $encoding = $this->getEncoding(); $convertEncoding = $this->getConvertEncoding(); if ($convertEncoding === null) { throw new Exception\LogicException( 'No convert encoding defined' ); } if ($encoding === $convertEncoding) { return $str; } $from = $reverse ? $convertEncoding : $encoding; $to = $reverse ? $encoding : $convertEncoding; throw new Exception\RuntimeException(sprintf( 'Converting from "%s" to "%s" isn\'t supported by this string wrapper', $from, $to )); } public function wordWrap($string, $width = 75, $break = "\n", $cut = false) { $string = (string) $string; if ($string === '') { return ''; } $break = (string) $break; if ($break === '') { throw new Exception\InvalidArgumentException('Break string cannot be empty'); } $width = (int) $width; if ($width === 0 && $cut) { throw new Exception\InvalidArgumentException('Cannot force cut when width is zero'); } if (StringUtils::isSingleByteEncoding($this->getEncoding())) { return wordwrap($string, $width, $break, $cut); } $stringWidth = $this->strlen($string); $breakWidth = $this->strlen($break); $result = ''; $lastStart = $lastSpace = 0; for ($current = 0; $current < $stringWidth; $current++) { $char = $this->substr($string, $current, 1); $possibleBreak = $char; if ($breakWidth !== 1) { $possibleBreak = $this->substr($string, $current, $breakWidth); } if ($possibleBreak === $break) { $result .= $this->substr($string, $lastStart, $current - $lastStart + $breakWidth); $current += $breakWidth - 1; $lastStart = $lastSpace = $current + 1; continue; } if ($char === ' ') { if ($current - $lastStart >= $width) { $result .= $this->substr($string, $lastStart, $current - $lastStart) . $break; $lastStart = $current + 1; } $lastSpace = $current; continue; } if ($current - $lastStart >= $width && $cut && $lastStart >= $lastSpace) { $result .= $this->substr($string, $lastStart, $current - $lastStart) . $break; $lastStart = $lastSpace = $current; continue; } if ($current - $lastStart >= $width && $lastStart < $lastSpace) { $result .= $this->substr($string, $lastStart, $lastSpace - $lastStart) . $break; $lastStart = $lastSpace = $lastSpace + 1; continue; } } if ($lastStart !== $current) { $result .= $this->substr($string, $lastStart, $current - $lastStart); } return $result; } public function strPad($input, $padLength, $padString = ' ', $padType = STR_PAD_RIGHT) { if (StringUtils::isSingleByteEncoding($this->getEncoding())) { return str_pad($input, $padLength, $padString, $padType); } $lengthOfPadding = $padLength - $this->strlen($input); if ($lengthOfPadding <= 0) { return $input; } $padStringLength = $this->strlen($padString); if ($padStringLength === 0) { return $input; } $repeatCount = floor($lengthOfPadding / $padStringLength); if ($padType === STR_PAD_BOTH) { $repeatCountLeft = $repeatCountRight = ($repeatCount - $repeatCount % 2) / 2; $lastStringLength = $lengthOfPadding - 2 * $repeatCountLeft * $padStringLength; $lastStringLeftLength = $lastStringRightLength = floor($lastStringLength / 2); $lastStringRightLength += $lastStringLength % 2; $lastStringLeft = $this->substr($padString, 0, $lastStringLeftLength); $lastStringRight = $this->substr($padString, 0, $lastStringRightLength); return str_repeat($padString, $repeatCountLeft) . $lastStringLeft . $input . str_repeat($padString, $repeatCountRight) . $lastStringRight; } $lastString = $this->substr($padString, 0, $lengthOfPadding % $padStringLength); if ($padType === STR_PAD_LEFT) { return str_repeat($padString, $repeatCount) . $lastString . $input; } return $input . str_repeat($padString, $repeatCount) . $lastString; } } } namespace Zend\Stdlib\StringWrapper { use Zend\Stdlib\Exception; class Intl extends AbstractStringWrapper { protected static $encodings = array('UTF-8'); public static function getSupportedEncodings() { return static::$encodings; } public function __construct() { if (!extension_loaded('intl')) { throw new Exception\ExtensionNotLoadedException( 'PHP extension "intl" is required for this wrapper' ); } } public function strlen($str) { return grapheme_strlen($str); } public function substr($str, $offset = 0, $length = null) { if ($length !== null) { return grapheme_substr($str, $offset, $length); } return grapheme_substr($str, $offset); } public function strpos($haystack, $needle, $offset = 0) { return grapheme_strpos($haystack, $needle, $offset); } } } namespace Zend\Mvc\Service { use Zend\Console\Console; use Zend\Console\Response as ConsoleResponse; use Zend\Http\PhpEnvironment\Response as HttpResponse; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class ResponseFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { if (Console::isConsole()) { return new ConsoleResponse(); } return new HttpResponse(); } } } namespace Zend\Http { use Zend\Stdlib\ErrorHandler; use Zend\Stdlib\ResponseInterface; class Response extends AbstractMessage implements ResponseInterface { const STATUS_CODE_CUSTOM = 0; const STATUS_CODE_100 = 100; const STATUS_CODE_101 = 101; const STATUS_CODE_102 = 102; const STATUS_CODE_200 = 200; const STATUS_CODE_201 = 201; const STATUS_CODE_202 = 202; const STATUS_CODE_203 = 203; const STATUS_CODE_204 = 204; const STATUS_CODE_205 = 205; const STATUS_CODE_206 = 206; const STATUS_CODE_207 = 207; const STATUS_CODE_208 = 208; const STATUS_CODE_300 = 300; const STATUS_CODE_301 = 301; const STATUS_CODE_302 = 302; const STATUS_CODE_303 = 303; const STATUS_CODE_304 = 304; const STATUS_CODE_305 = 305; const STATUS_CODE_306 = 306; const STATUS_CODE_307 = 307; const STATUS_CODE_400 = 400; const STATUS_CODE_401 = 401; const STATUS_CODE_402 = 402; const STATUS_CODE_403 = 403; const STATUS_CODE_404 = 404; const STATUS_CODE_405 = 405; const STATUS_CODE_406 = 406; const STATUS_CODE_407 = 407; const STATUS_CODE_408 = 408; const STATUS_CODE_409 = 409; const STATUS_CODE_410 = 410; const STATUS_CODE_411 = 411; const STATUS_CODE_412 = 412; const STATUS_CODE_413 = 413; const STATUS_CODE_414 = 414; const STATUS_CODE_415 = 415; const STATUS_CODE_416 = 416; const STATUS_CODE_417 = 417; const STATUS_CODE_418 = 418; const STATUS_CODE_422 = 422; const STATUS_CODE_423 = 423; const STATUS_CODE_424 = 424; const STATUS_CODE_425 = 425; const STATUS_CODE_426 = 426; const STATUS_CODE_428 = 428; const STATUS_CODE_429 = 429; const STATUS_CODE_431 = 431; const STATUS_CODE_500 = 500; const STATUS_CODE_501 = 501; const STATUS_CODE_502 = 502; const STATUS_CODE_503 = 503; const STATUS_CODE_504 = 504; const STATUS_CODE_505 = 505; const STATUS_CODE_506 = 506; const STATUS_CODE_507 = 507; const STATUS_CODE_508 = 508; const STATUS_CODE_511 = 511; protected $recommendedReasonPhrases = array( 100 => 'Continue', 101 => 'Switching Protocols', 102 => 'Processing', 200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content', 207 => 'Multi-status', 208 => 'Already Reported', 300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 306 => 'Switch Proxy', 307 => 'Temporary Redirect', 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested range not satisfiable', 417 => 'Expectation Failed', 418 => 'I\'m a teapot', 422 => 'Unprocessable Entity', 423 => 'Locked', 424 => 'Failed Dependency', 425 => 'Unordered Collection', 426 => 'Upgrade Required', 428 => 'Precondition Required', 429 => 'Too Many Requests', 431 => 'Request Header Fields Too Large', 500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version not supported', 506 => 'Variant Also Negotiates', 507 => 'Insufficient Storage', 508 => 'Loop Detected', 511 => 'Network Authentication Required', ); protected $statusCode = 200; protected $reasonPhrase = null; public static function fromString($string) { $lines = explode("\r\n", $string); if (!is_array($lines) || count($lines) == 1) { $lines = explode("\n", $string); } $firstLine = array_shift($lines); $response = new static(); $regex = '/^HTTP\/(?P<version>1\.[01]) (?P<status>\d{3})(?:[ ]+(?P<reason>.*))?$/'; $matches = array(); if (!preg_match($regex, $firstLine, $matches)) { throw new Exception\InvalidArgumentException( 'A valid response status line was not found in the provided string' ); } $response->version = $matches['version']; $response->setStatusCode($matches['status']); $response->setReasonPhrase((isset($matches['reason']) ? $matches['reason'] : '')); if (count($lines) == 0) { return $response; } $isHeader = true; $headers = $content = array(); foreach ($lines as $line) { if ($isHeader && $line == '') { $isHeader = false; continue; } if ($isHeader) { $headers[] = $line; } else { $content[] = $line; } } if ($headers) { $response->headers = implode("\r\n", $headers); } if ($content) { $response->setContent(implode("\r\n", $content)); } return $response; } public function getCookie() { return $this->getHeaders()->get('Set-Cookie'); } public function setStatusCode($code) { $const = get_class($this) . '::STATUS_CODE_' . $code; if (!is_numeric($code) || !defined($const)) { $code = is_scalar($code) ? $code : gettype($code); throw new Exception\InvalidArgumentException(sprintf( 'Invalid status code provided: "%s"', $code )); } $this->statusCode = (int) $code; return $this; } public function getStatusCode() { return $this->statusCode; } public function setCustomStatusCode($code) { if (!is_numeric($code)) { $code = is_scalar($code) ? $code : gettype($code); throw new Exception\InvalidArgumentException(sprintf( 'Invalid status code provided: "%s"', $code )); } $this->statusCode = (int) $code; return $this; } public function setReasonPhrase($reasonPhrase) { $this->reasonPhrase = trim($reasonPhrase); return $this; } public function getReasonPhrase() { if (null == $this->reasonPhrase and isset($this->recommendedReasonPhrases[$this->statusCode])) { return $this->recommendedReasonPhrases[$this->statusCode]; } return $this->reasonPhrase; } public function getBody() { $body = (string) $this->getContent(); $transferEncoding = $this->getHeaders()->get('Transfer-Encoding'); if (!empty($transferEncoding)) { if (strtolower($transferEncoding->getFieldValue()) == 'chunked') { $body = $this->decodeChunkedBody($body); } } $contentEncoding = $this->getHeaders()->get('Content-Encoding'); if (!empty($contentEncoding)) { $contentEncoding = $contentEncoding->getFieldValue(); if ($contentEncoding =='gzip') { $body = $this->decodeGzip($body); } elseif ($contentEncoding == 'deflate') { $body = $this->decodeDeflate($body); } } return $body; } public function isClientError() { $code = $this->getStatusCode(); return ($code < 500 && $code >= 400); } public function isForbidden() { return (403 == $this->getStatusCode()); } public function isInformational() { $code = $this->getStatusCode(); return ($code >= 100 && $code < 200); } public function isNotFound() { return (404 === $this->getStatusCode()); } public function isOk() { return (200 === $this->getStatusCode()); } public function isServerError() { $code = $this->getStatusCode(); return (500 <= $code && 600 > $code); } public function isRedirect() { $code = $this->getStatusCode(); return (300 <= $code && 400 > $code); } public function isSuccess() { $code = $this->getStatusCode(); return (200 <= $code && 300 > $code); } public function renderStatusLine() { $status = sprintf( 'HTTP/%s %d %s', $this->getVersion(), $this->getStatusCode(), $this->getReasonPhrase() ); return trim($status); } public function toString() { $str = $this->renderStatusLine() . "\r\n"; $str .= $this->getHeaders()->toString(); $str .= "\r\n"; $str .= $this->getContent(); return $str; } protected function decodeChunkedBody($body) { $decBody = ''; while (trim($body)) { if (! preg_match("/^([\da-fA-F]+)[^\r\n]*\r\n/sm", $body, $m)) { throw new Exception\RuntimeException( "Error parsing body - doesn't seem to be a chunked message" ); } $length = hexdec(trim($m[1])); $cut = strlen($m[0]); $decBody .= substr($body, $cut, $length); $body = substr($body, $cut + $length + 2); } return $decBody; } protected function decodeGzip($body) { if (!function_exists('gzinflate')) { throw new Exception\RuntimeException( 'zlib extension is required in order to decode "gzip" encoding' ); } ErrorHandler::start(); $return = gzinflate(substr($body, 10)); $test = ErrorHandler::stop(); if ($test) { throw new Exception\RuntimeException( 'Error occurred during gzip inflation', 0, $test ); } return $return; } protected function decodeDeflate($body) { if (!function_exists('gzuncompress')) { throw new Exception\RuntimeException( 'zlib extension is required in order to decode "deflate" encoding' ); } $zlibHeader = unpack('n', substr($body, 0, 2)); if ($zlibHeader[1] % 31 == 0) { return gzuncompress($body); } return gzinflate($body); } } } namespace Zend\Http\PhpEnvironment { use Zend\Http\Header\MultipleHeaderInterface; use Zend\Http\Response as HttpResponse; class Response extends HttpResponse { protected $version; protected $contentSent = false; public function getVersion() { if (!$this->version) { $this->version = $this->detectVersion(); } return $this->version; } protected function detectVersion() { if (isset($_SERVER['SERVER_PROTOCOL']) && $_SERVER['SERVER_PROTOCOL'] == 'HTTP/1.1') { return self::VERSION_11; } return self::VERSION_10; } public function headersSent() { return headers_sent(); } public function contentSent() { return $this->contentSent; } public function sendHeaders() { if ($this->headersSent()) { return $this; } $status = $this->renderStatusLine(); header($status); foreach ($this->getHeaders() as $header) { if ($header instanceof MultipleHeaderInterface) { header($header->toString(), false); continue; } header($header->toString()); } $this->headersSent = true; return $this; } public function sendContent() { if ($this->contentSent()) { return $this; } echo $this->getContent(); $this->contentSent = true; return $this; } public function send() { $this->sendHeaders() ->sendContent(); return $this; } } } namespace Zend\Mvc { use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; class RouteListener implements ListenerAggregateInterface { protected $listeners = array(); public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_ROUTE, array($this, 'onRoute')); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function onRoute($e) { $target = $e->getTarget(); $request = $e->getRequest(); $router = $e->getRouter(); $routeMatch = $router->match($request); if (!$routeMatch instanceof Router\RouteMatch) { $e->setError(Application::ERROR_ROUTER_NO_MATCH); $results = $target->getEventManager()->trigger(MvcEvent::EVENT_DISPATCH_ERROR, $e); if (count($results)) { $return = $results->last(); } else { $return = $e->getParams(); } return $return; } $e->setRouteMatch($routeMatch); return $routeMatch; } } } namespace Zend\Mvc { use ArrayObject; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\Mvc\Exception\InvalidControllerException; use Zend\Stdlib\ArrayUtils; class DispatchListener implements ListenerAggregateInterface { protected $listeners = array(); public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'onDispatch')); if (function_exists('zend_monitor_custom_event_ex')) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'reportMonitorEvent')); } } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function onDispatch(MvcEvent $e) { $routeMatch = $e->getRouteMatch(); $controllerName = $routeMatch->getParam('controller', 'not-found'); $application = $e->getApplication(); $events = $application->getEventManager(); $controllerLoader = $application->getServiceManager()->get('ControllerManager'); if (!$controllerLoader->has($controllerName)) { $return = $this->marshalControllerNotFoundEvent($application::ERROR_CONTROLLER_NOT_FOUND, $controllerName, $e, $application); return $this->complete($return, $e); } try { $controller = $controllerLoader->get($controllerName); } catch (InvalidControllerException $exception) { $return = $this->marshalControllerNotFoundEvent($application::ERROR_CONTROLLER_INVALID, $controllerName, $e, $application, $exception); return $this->complete($return, $e); } catch (\Exception $exception) { $return = $this->marshalBadControllerEvent($controllerName, $e, $application, $exception); return $this->complete($return, $e); } $request = $e->getRequest(); $response = $application->getResponse(); if ($controller instanceof InjectApplicationEventInterface) { $controller->setEvent($e); } try { $return = $controller->dispatch($request, $response); } catch (\Exception $ex) { $e->setError($application::ERROR_EXCEPTION) ->setController($controllerName) ->setControllerClass(get_class($controller)) ->setParam('exception', $ex); $results = $events->trigger(MvcEvent::EVENT_DISPATCH_ERROR, $e); $return = $results->last(); if (! $return) { $return = $e->getResult(); } } return $this->complete($return, $e); } public function reportMonitorEvent(MvcEvent $e) { $error = $e->getError(); $exception = $e->getParam('exception'); if ($exception instanceof \Exception) { zend_monitor_custom_event_ex($error, $exception->getMessage(), 'Zend Framework Exception', array('code' => $exception->getCode(), 'trace' => $exception->getTraceAsString())); } } protected function complete($return, MvcEvent $event) { if (!is_object($return)) { if (ArrayUtils::hasStringKeys($return)) { $return = new ArrayObject($return, ArrayObject::ARRAY_AS_PROPS); } } $event->setResult($return); return $return; } protected function marshalControllerNotFoundEvent( $type, $controllerName, MvcEvent $event, Application $application, \Exception $exception = null ) { $event->setError($type) ->setController($controllerName) ->setControllerClass('invalid controller class or alias: ' . $controllerName); if ($exception !== null) { $event->setParam('exception', $exception); } $events = $application->getEventManager(); $results = $events->trigger(MvcEvent::EVENT_DISPATCH_ERROR, $event); $return = $results->last(); if (! $return) { $return = $event->getResult(); } return $return; } protected function marshallControllerNotFoundEvent( $type, $controllerName, MvcEvent $event, Application $application, \Exception $exception = null ) { trigger_error(sprintf( '%s is deprecated; please use %s::marshalControllerNotFoundEvent instead', __METHOD__, __CLASS__ ), E_USER_DEPRECATED); return $this->marshalControllerNotFoundEvent($type, $controllerName, $event, $application, $exception); } protected function marshalBadControllerEvent( $controllerName, MvcEvent $event, Application $application, \Exception $exception ) { $event->setError($application::ERROR_EXCEPTION) ->setController($controllerName) ->setParam('exception', $exception); $events = $application->getEventManager(); $results = $events->trigger(MvcEvent::EVENT_DISPATCH_ERROR, $event); $return = $results->last(); if (! $return) { $return = $event->getResult(); } return $return; } } } namespace Zend\Mvc\Service { use Zend\Console\Console; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Mvc\View\Console\ViewManager as ConsoleViewManager; use Zend\Mvc\View\Http\ViewManager as HttpViewManager; class ViewManagerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { if (Console::isConsole()) { return $serviceLocator->get('ConsoleViewManager'); } return $serviceLocator->get('HttpViewManager'); } } } namespace Zend\Mvc\Service { use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Mvc\View\Http\ViewManager as HttpViewManager; class HttpViewManagerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { return new HttpViewManager(); } } } namespace Zend\EventManager { abstract class AbstractListenerAggregate implements ListenerAggregateInterface { protected $listeners = array(); public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $callback) { if ($events->detach($callback)) { unset($this->listeners[$index]); } } } } } namespace Zend\Mvc\View\Http { use ArrayAccess; use Traversable; use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\Mvc\MvcEvent; use Zend\ServiceManager\ServiceManager; use Zend\View\HelperPluginManager as ViewHelperManager; use Zend\View\Renderer\PhpRenderer as ViewPhpRenderer; use Zend\View\Resolver as ViewResolver; use Zend\View\Strategy\PhpRendererStrategy; use Zend\View\View; class ViewManager extends AbstractListenerAggregate { protected $config; protected $event; protected $services; protected $exceptionStrategy; protected $helperManager; protected $mvcRenderingStrategy; protected $renderer; protected $rendererStrategy; protected $resolver; protected $routeNotFoundStrategy; protected $view; protected $viewModel; public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_BOOTSTRAP, array($this, 'onBootstrap'), 10000); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function onBootstrap($event) { $application = $event->getApplication(); $services = $application->getServiceManager(); $config = $services->get('Config'); $events = $application->getEventManager(); $sharedEvents = $events->getSharedManager(); $this->config = isset($config['view_manager']) && (is_array($config['view_manager']) || $config['view_manager'] instanceof ArrayAccess) ? $config['view_manager'] : array(); $this->services = $services; $this->event = $event; $routeNotFoundStrategy = $this->getRouteNotFoundStrategy(); $exceptionStrategy = $this->getExceptionStrategy(); $mvcRenderingStrategy = $this->getMvcRenderingStrategy(); $injectTemplateListener = $this->getInjectTemplateListener(); $createViewModelListener = new CreateViewModelListener(); $injectViewModelListener = new InjectViewModelListener(); $this->registerMvcRenderingStrategies($events); $this->registerViewStrategies(); $events->attach($routeNotFoundStrategy); $events->attach($exceptionStrategy); $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($injectViewModelListener, 'injectViewModel'), -100); $events->attach(MvcEvent::EVENT_RENDER_ERROR, array($injectViewModelListener, 'injectViewModel'), -100); $events->attach($mvcRenderingStrategy); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($createViewModelListener, 'createViewModelFromArray'), -80); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($routeNotFoundStrategy, 'prepareNotFoundViewModel'), -90); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($createViewModelListener, 'createViewModelFromNull'), -80); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($injectTemplateListener, 'injectTemplate'), -90); $sharedEvents->attach('Zend\Stdlib\DispatchableInterface', MvcEvent::EVENT_DISPATCH, array($injectViewModelListener, 'injectViewModel'), -100); } public function getHelperManager() { if ($this->helperManager) { return $this->helperManager; } return $this->helperManager = $this->services->get('ViewHelperManager'); } public function getResolver() { if (null === $this->resolver) { $this->resolver = $this->services->get('ViewResolver'); } return $this->resolver; } public function getRenderer() { if ($this->renderer) { return $this->renderer; } $this->renderer = new ViewPhpRenderer; $this->renderer->setHelperPluginManager($this->getHelperManager()); $this->renderer->setResolver($this->getResolver()); $model = $this->getViewModel(); $modelHelper = $this->renderer->plugin('view_model'); $modelHelper->setRoot($model); $this->services->setService('ViewRenderer', $this->renderer); $this->services->setAlias('Zend\View\Renderer\PhpRenderer', 'ViewRenderer'); $this->services->setAlias('Zend\View\Renderer\RendererInterface', 'ViewRenderer'); return $this->renderer; } public function getRendererStrategy() { if ($this->rendererStrategy) { return $this->rendererStrategy; } $this->rendererStrategy = new PhpRendererStrategy( $this->getRenderer() ); $this->services->setService('ViewPhpRendererStrategy', $this->rendererStrategy); $this->services->setAlias('Zend\View\Strategy\PhpRendererStrategy', 'ViewPhpRendererStrategy'); return $this->rendererStrategy; } public function getView() { if ($this->view) { return $this->view; } $this->view = new View(); $this->view->setEventManager($this->services->get('EventManager')); $this->view->getEventManager()->attach($this->getRendererStrategy()); $this->services->setService('View', $this->view); $this->services->setAlias('Zend\View\View', 'View'); return $this->view; } public function getLayoutTemplate() { $layout = 'layout/layout'; if (isset($this->config['layout'])) { $layout = $this->config['layout']; } return $layout; } public function getMvcRenderingStrategy() { if ($this->mvcRenderingStrategy) { return $this->mvcRenderingStrategy; } $this->mvcRenderingStrategy = new DefaultRenderingStrategy($this->getView()); $this->mvcRenderingStrategy->setLayoutTemplate($this->getLayoutTemplate()); $this->services->setService('DefaultRenderingStrategy', $this->mvcRenderingStrategy); $this->services->setAlias('Zend\Mvc\View\DefaultRenderingStrategy', 'DefaultRenderingStrategy'); $this->services->setAlias('Zend\Mvc\View\Http\DefaultRenderingStrategy', 'DefaultRenderingStrategy'); return $this->mvcRenderingStrategy; } public function getExceptionStrategy() { if ($this->exceptionStrategy) { return $this->exceptionStrategy; } $this->exceptionStrategy = new ExceptionStrategy(); $displayExceptions = false; $exceptionTemplate = 'error'; if (isset($this->config['display_exceptions'])) { $displayExceptions = $this->config['display_exceptions']; } if (isset($this->config['exception_template'])) { $exceptionTemplate = $this->config['exception_template']; } $this->exceptionStrategy->setDisplayExceptions($displayExceptions); $this->exceptionStrategy->setExceptionTemplate($exceptionTemplate); $this->services->setService('ExceptionStrategy', $this->exceptionStrategy); $this->services->setAlias('Zend\Mvc\View\ExceptionStrategy', 'ExceptionStrategy'); $this->services->setAlias('Zend\Mvc\View\Http\ExceptionStrategy', 'ExceptionStrategy'); return $this->exceptionStrategy; } public function getRouteNotFoundStrategy() { if ($this->routeNotFoundStrategy) { return $this->routeNotFoundStrategy; } $this->routeNotFoundStrategy = new RouteNotFoundStrategy(); $displayExceptions = false; $displayNotFoundReason = false; $notFoundTemplate = '404'; if (isset($this->config['display_exceptions'])) { $displayExceptions = $this->config['display_exceptions']; } if (isset($this->config['display_not_found_reason'])) { $displayNotFoundReason = $this->config['display_not_found_reason']; } if (isset($this->config['not_found_template'])) { $notFoundTemplate = $this->config['not_found_template']; } $this->routeNotFoundStrategy->setDisplayExceptions($displayExceptions); $this->routeNotFoundStrategy->setDisplayNotFoundReason($displayNotFoundReason); $this->routeNotFoundStrategy->setNotFoundTemplate($notFoundTemplate); $this->services->setService('RouteNotFoundStrategy', $this->routeNotFoundStrategy); $this->services->setAlias('Zend\Mvc\View\RouteNotFoundStrategy', 'RouteNotFoundStrategy'); $this->services->setAlias('Zend\Mvc\View\Http\RouteNotFoundStrategy', 'RouteNotFoundStrategy'); $this->services->setAlias('404Strategy', 'RouteNotFoundStrategy'); return $this->routeNotFoundStrategy; } public function getInjectTemplateListener() { $listener = new InjectTemplateListener(); if (isset($this->config['controller_map'])) { $listener->setControllerMap($this->config['controller_map']); } return $listener; } public function getViewModel() { if ($this->viewModel) { return $this->viewModel; } $this->viewModel = $model = $this->event->getViewModel(); $model->setTemplate($this->getLayoutTemplate()); return $this->viewModel; } protected function registerMvcRenderingStrategies(EventManagerInterface $events) { if (!isset($this->config['mvc_strategies'])) { return; } $mvcStrategies = $this->config['mvc_strategies']; if (is_string($mvcStrategies)) { $mvcStrategies = array($mvcStrategies); } if (!is_array($mvcStrategies) && !$mvcStrategies instanceof Traversable) { return; } foreach ($mvcStrategies as $mvcStrategy) { if (!is_string($mvcStrategy)) { continue; } $listener = $this->services->get($mvcStrategy); if ($listener instanceof ListenerAggregateInterface) { $events->attach($listener, 100); } } } protected function registerViewStrategies() { if (!isset($this->config['strategies'])) { return; } $strategies = $this->config['strategies']; if (is_string($strategies)) { $strategies = array($strategies); } if (!is_array($strategies) && !$strategies instanceof Traversable) { return; } $view = $this->getView(); foreach ($strategies as $strategy) { if (!is_string($strategy)) { continue; } $listener = $this->services->get($strategy); if ($listener instanceof ListenerAggregateInterface) { $view->getEventManager()->attach($listener, 100); } } } } } namespace Zend\Mvc { use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; use Zend\Mvc\ResponseSender\ConsoleResponseSender; use Zend\Mvc\ResponseSender\HttpResponseSender; use Zend\Mvc\ResponseSender\PhpEnvironmentResponseSender; use Zend\Mvc\ResponseSender\SendResponseEvent; use Zend\Mvc\ResponseSender\SimpleStreamResponseSender; use Zend\Stdlib\ResponseInterface as Response; class SendResponseListener implements EventManagerAwareInterface, ListenerAggregateInterface { protected $listeners = array(); protected $event; protected $eventManager; public function setEventManager(EventManagerInterface $eventManager) { $eventManager->setIdentifiers(array( __CLASS__, get_class($this), )); $this->eventManager = $eventManager; $this->attachDefaultListeners(); return $this; } public function getEventManager() { if (!$this->eventManager instanceof EventManagerInterface) { $this->setEventManager(new EventManager()); } return $this->eventManager; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_FINISH, array($this, 'sendResponse'), -10000); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function sendResponse(MvcEvent $e) { $response = $e->getResponse(); if (!$response instanceof Response) { return; } $event = $this->getEvent(); $event->setResponse($response); $event->setTarget($this); $this->getEventManager()->trigger($event); } public function getEvent() { if (!$this->event instanceof SendResponseEvent) { $this->setEvent(new SendResponseEvent()); } return $this->event; } public function setEvent(SendResponseEvent $e) { $this->event = $e; return $this; } protected function attachDefaultListeners() { $events = $this->getEventManager(); $events->attach(SendResponseEvent::EVENT_SEND_RESPONSE, new PhpEnvironmentResponseSender(), -1000); $events->attach(SendResponseEvent::EVENT_SEND_RESPONSE, new ConsoleResponseSender(), -2000); $events->attach(SendResponseEvent::EVENT_SEND_RESPONSE, new SimpleStreamResponseSender(), -3000); $events->attach(SendResponseEvent::EVENT_SEND_RESPONSE, new HttpResponseSender(), -4000); } } } namespace Zend\Mvc\ResponseSender { use Zend\EventManager\Event; use Zend\Stdlib\ResponseInterface; class SendResponseEvent extends Event { const EVENT_SEND_RESPONSE = 'sendResponse'; protected $name = 'sendResponse'; protected $response; protected $headersSent = array(); protected $contentSent = array(); public function setResponse(ResponseInterface $response) { $this->setParam('response', $response); $this->response = $response; return $this; } public function getResponse() { return $this->response; } public function setContentSent() { $response = $this->getResponse(); $contentSent = $this->getParam('contentSent', array()); $contentSent[spl_object_hash($response)] = true; $this->setParam('contentSent', $contentSent); $this->contentSent[spl_object_hash($response)] = true; return $this; } public function contentSent() { $response = $this->getResponse(); if (isset($this->contentSent[spl_object_hash($response)])) { return true; } return false; } public function setHeadersSent() { $response = $this->getResponse(); $headersSent = $this->getParam('headersSent', array()); $headersSent[spl_object_hash($response)] = true; $this->setParam('headersSent', $headersSent); $this->headersSent[spl_object_hash($response)] = true; return $this; } public function headersSent() { $response = $this->getResponse(); if (isset($this->headersSent[spl_object_hash($response)])) { return true; } return false; } } } namespace Zend\Mvc\ResponseSender { use Zend\Http\Header\MultipleHeaderInterface; abstract class AbstractResponseSender implements ResponseSenderInterface { public function sendHeaders(SendResponseEvent $event) { if (headers_sent() || $event->headersSent()) { return $this; } $response = $event->getResponse(); foreach ($response->getHeaders() as $header) { if ($header instanceof MultipleHeaderInterface) { header($header->toString(), false); continue; } header($header->toString()); } $status = $response->renderStatusLine(); header($status); $event->setHeadersSent(); return $this; } } } namespace Zend\Mvc\ResponseSender { use Zend\Http\Response; class HttpResponseSender extends AbstractResponseSender { public function sendContent(SendResponseEvent $event) { if ($event->contentSent()) { return $this; } $response = $event->getResponse(); echo $response->getContent(); $event->setContentSent(); return $this; } public function __invoke(SendResponseEvent $event) { $response = $event->getResponse(); if (!$response instanceof Response) { return $this; } $this->sendHeaders($event) ->sendContent($event); $event->stopPropagation(true); return $this; } } } namespace Zend\Mvc\ResponseSender { use Zend\Http\PhpEnvironment\Response; class PhpEnvironmentResponseSender extends HttpResponseSender { public function __invoke(SendResponseEvent $event) { $response = $event->getResponse(); if (!$response instanceof Response) { return $this; } $this->sendHeaders($event) ->sendContent($event); $event->stopPropagation(true); return $this; } } } namespace Zend\Mvc\ResponseSender { use Zend\Console\Response; class ConsoleResponseSender implements ResponseSenderInterface { public function sendContent(SendResponseEvent $event) { if ($event->contentSent()) { return $this; } $response = $event->getResponse(); echo $response->getContent(); $event->setContentSent(); return $this; } public function __invoke(SendResponseEvent $event) { $response = $event->getResponse(); if (!$response instanceof Response) { return; } $this->sendContent($event); $errorLevel = (int) $response->getMetadata('errorLevel',0); $event->stopPropagation(true); exit($errorLevel); } } } namespace Zend\Mvc\ResponseSender { use Zend\Http\Response\Stream; class SimpleStreamResponseSender extends AbstractResponseSender { public function sendStream(SendResponseEvent $event) { if ($event->contentSent()) { return $this; } $response = $event->getResponse(); $stream = $response->getStream(); fpassthru($stream); $event->setContentSent(); } public function __invoke(SendResponseEvent $event) { $response = $event->getResponse(); if (!$response instanceof Stream) { return $this; } $this->sendHeaders($event); $this->sendStream($event); $event->stopPropagation(true); return $this; } } } namespace Zend\Mvc\Service { use Zend\Console\Console; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class RouterFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator, $cName = null, $rName = null) { $config = $serviceLocator->has('Config') ? $serviceLocator->get('Config') : array(); $routerClass = 'Zend\Mvc\Router\Http\TreeRouteStack'; $routerConfig = isset($config['router']) ? $config['router'] : array(); if ($rName === 'ConsoleRouter' || ($cName === 'router' && Console::isConsole()) ) { $routerClass = 'Zend\Mvc\Router\Console\SimpleRouteStack'; $routerConfig = isset($config['console']['router']) ? $config['console']['router'] : array(); } if (isset($routerConfig['router_class']) && class_exists($routerConfig['router_class'])) { $routerClass = $routerConfig['router_class']; } if (!isset($routerConfig['route_plugins'])) { $routePluginManager = $serviceLocator->get('RoutePluginManager'); $routerConfig['route_plugins'] = $routePluginManager; } $factory = sprintf('%s::factory', $routerClass); return call_user_func($factory, $routerConfig); } } } namespace Zend\Mvc\Router { use Traversable; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\RequestInterface as Request; class SimpleRouteStack implements RouteStackInterface { protected $routes; protected $routePluginManager; protected $defaultParams = array(); public function __construct(RoutePluginManager $routePluginManager = null) { $this->routes = new PriorityList(); if (null === $routePluginManager) { $routePluginManager = new RoutePluginManager(); } $this->routePluginManager = $routePluginManager; $this->init(); } public static function factory($options = array()) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } $routePluginManager = null; if (isset($options['route_plugins'])) { $routePluginManager = $options['route_plugins']; } $instance = new static($routePluginManager); if (isset($options['routes'])) { $instance->addRoutes($options['routes']); } if (isset($options['default_params'])) { $instance->setDefaultParams($options['default_params']); } return $instance; } protected function init() { } public function setRoutePluginManager(RoutePluginManager $routePlugins) { $this->routePluginManager = $routePlugins; return $this; } public function getRoutePluginManager() { return $this->routePluginManager; } public function addRoutes($routes) { if (!is_array($routes) && !$routes instanceof Traversable) { throw new Exception\InvalidArgumentException('addRoutes expects an array or Traversable set of routes'); } foreach ($routes as $name => $route) { $this->addRoute($name, $route); } return $this; } public function addRoute($name, $route, $priority = null) { if (!$route instanceof RouteInterface) { $route = $this->routeFromArray($route); } if ($priority === null && isset($route->priority)) { $priority = $route->priority; } $this->routes->insert($name, $route, $priority); return $this; } public function removeRoute($name) { $this->routes->remove($name); return $this; } public function setRoutes($routes) { $this->routes->clear(); $this->addRoutes($routes); return $this; } public function getRoutes() { return $this->routes; } public function hasRoute($name) { return $this->routes->get($name) !== null; } public function getRoute($name) { return $this->routes->get($name); } public function setDefaultParams(array $params) { $this->defaultParams = $params; return $this; } public function setDefaultParam($name, $value) { $this->defaultParams[$name] = $value; return $this; } protected function routeFromArray($specs) { if ($specs instanceof Traversable) { $specs = ArrayUtils::iteratorToArray($specs); } elseif (!is_array($specs)) { throw new Exception\InvalidArgumentException('Route definition must be an array or Traversable object'); } if (!isset($specs['type'])) { throw new Exception\InvalidArgumentException('Missing "type" option'); } elseif (!isset($specs['options'])) { $specs['options'] = array(); } $route = $this->getRoutePluginManager()->get($specs['type'], $specs['options']); if (isset($specs['priority'])) { $route->priority = $specs['priority']; } return $route; } public function match(Request $request) { foreach ($this->routes as $name => $route) { if (($match = $route->match($request)) instanceof RouteMatch) { $match->setMatchedRouteName($name); foreach ($this->defaultParams as $paramName => $value) { if ($match->getParam($paramName) === null) { $match->setParam($paramName, $value); } } return $match; } } return null; } public function assemble(array $params = array(), array $options = array()) { if (!isset($options['name'])) { throw new Exception\InvalidArgumentException('Missing "name" option'); } $route = $this->routes->get($options['name']); if (!$route) { throw new Exception\RuntimeException(sprintf('Route with name "%s" not found', $options['name'])); } unset($options['name']); return $route->assemble(array_merge($this->defaultParams, $params), $options); } } } namespace Zend\Mvc\Router\Http { use ArrayObject; use Traversable; use Zend\Mvc\Router\Exception; use Zend\Mvc\Router\SimpleRouteStack; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\RequestInterface as Request; use Zend\Uri\Http as HttpUri; class TreeRouteStack extends SimpleRouteStack { protected $baseUrl; protected $requestUri; protected $prototypes; public static function factory($options = array()) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } $instance = parent::factory($options); if (isset($options['prototypes'])) { $instance->addPrototypes($options['prototypes']); } return $instance; } protected function init() { $this->prototypes = new ArrayObject; $routes = $this->routePluginManager; foreach (array( 'chain' => __NAMESPACE__ . '\Chain', 'hostname' => __NAMESPACE__ . '\Hostname', 'literal' => __NAMESPACE__ . '\Literal', 'method' => __NAMESPACE__ . '\Method', 'part' => __NAMESPACE__ . '\Part', 'query' => __NAMESPACE__ . '\Query', 'regex' => __NAMESPACE__ . '\Regex', 'scheme' => __NAMESPACE__ . '\Scheme', 'segment' => __NAMESPACE__ . '\Segment', 'wildcard' => __NAMESPACE__ . '\Wildcard', ) as $name => $class ) { $routes->setInvokableClass($name, $class); }; } public function addRoute($name, $route, $priority = null) { if (!$route instanceof RouteInterface) { $route = $this->routeFromArray($route); } return parent::addRoute($name, $route, $priority); } protected function routeFromArray($specs) { if (is_string($specs)) { if (null === ($route = $this->getPrototype($specs))) { throw new Exception\RuntimeException(sprintf('Could not find prototype with name %s', $specs)); } return $route; } elseif ($specs instanceof Traversable) { $specs = ArrayUtils::iteratorToArray($specs); } elseif (!is_array($specs)) { throw new Exception\InvalidArgumentException('Route definition must be an array or Traversable object'); } if (isset($specs['chain_routes'])) { if (!is_array($specs['chain_routes'])) { throw new Exception\InvalidArgumentException('Chain routes must be an array or Traversable object'); } $chainRoutes = array_merge(array($specs), $specs['chain_routes']); unset($chainRoutes[0]['chain_routes']); if (isset($specs['child_routes'])) { unset($chainRoutes[0]['child_routes']); } $options = array( 'routes' => $chainRoutes, 'route_plugins' => $this->routePluginManager, 'prototypes' => $this->prototypes, ); $route = $this->routePluginManager->get('chain', $options); } else { $route = parent::routeFromArray($specs); } if (!$route instanceof RouteInterface) { throw new Exception\RuntimeException('Given route does not implement HTTP route interface'); } if (isset($specs['child_routes'])) { $options = array( 'route' => $route, 'may_terminate' => (isset($specs['may_terminate']) && $specs['may_terminate']), 'child_routes' => $specs['child_routes'], 'route_plugins' => $this->routePluginManager, 'prototypes' => $this->prototypes, ); $priority = (isset($route->priority) ? $route->priority : null); $route = $this->routePluginManager->get('part', $options); $route->priority = $priority; } return $route; } public function addPrototypes($routes) { if (!is_array($routes) && !$routes instanceof Traversable) { throw new Exception\InvalidArgumentException('addPrototypes expects an array or Traversable set of routes'); } foreach ($routes as $name => $route) { $this->addPrototype($name, $route); } return $this; } public function addPrototype($name, $route) { if (!$route instanceof RouteInterface) { $route = $this->routeFromArray($route); } $this->prototypes[$name] = $route; return $this; } public function getPrototype($name) { if (isset($this->prototypes[$name])) { return $this->prototypes[$name]; } return null; } public function match(Request $request, $pathOffset = null, array $options = array()) { if (!method_exists($request, 'getUri')) { return null; } if ($this->baseUrl === null && method_exists($request, 'getBaseUrl')) { $this->setBaseUrl($request->getBaseUrl()); } $uri = $request->getUri(); $baseUrlLength = strlen($this->baseUrl) ?: null; if ($pathOffset !== null) { $baseUrlLength += $pathOffset; } if ($this->requestUri === null) { $this->setRequestUri($uri); } if ($baseUrlLength !== null) { $pathLength = strlen($uri->getPath()) - $baseUrlLength; } else { $pathLength = null; } foreach ($this->routes as $name => $route) { if ( ($match = $route->match($request, $baseUrlLength, $options)) instanceof RouteMatch && ($pathLength === null || $match->getLength() === $pathLength) ) { $match->setMatchedRouteName($name); foreach ($this->defaultParams as $paramName => $value) { if ($match->getParam($paramName) === null) { $match->setParam($paramName, $value); } } return $match; } } return null; } public function assemble(array $params = array(), array $options = array()) { if (!isset($options['name'])) { throw new Exception\InvalidArgumentException('Missing "name" option'); } $names = explode('/', $options['name'], 2); $route = $this->routes->get($names[0]); if (!$route) { throw new Exception\RuntimeException(sprintf('Route with name "%s" not found', $names[0])); } if (isset($names[1])) { if (!$route instanceof TreeRouteStack) { throw new Exception\RuntimeException(sprintf('Route with name "%s" does not have child routes', $names[0])); } $options['name'] = $names[1]; } else { unset($options['name']); } if (isset($options['only_return_path']) && $options['only_return_path']) { return $this->baseUrl . $route->assemble(array_merge($this->defaultParams, $params), $options); } if (!isset($options['uri'])) { $uri = new HttpUri(); if (isset($options['force_canonical']) && $options['force_canonical']) { if ($this->requestUri === null) { throw new Exception\RuntimeException('Request URI has not been set'); } $uri->setScheme($this->requestUri->getScheme()) ->setHost($this->requestUri->getHost()) ->setPort($this->requestUri->getPort()); } $options['uri'] = $uri; } else { $uri = $options['uri']; } $path = $this->baseUrl . $route->assemble(array_merge($this->defaultParams, $params), $options); if (isset($options['query'])) { $uri->setQuery($options['query']); } if (isset($options['fragment'])) { $uri->setFragment($options['fragment']); } if ((isset($options['force_canonical']) && $options['force_canonical']) || $uri->getHost() !== null || $uri->getScheme() !== null) { if (($uri->getHost() === null || $uri->getScheme() === null) && $this->requestUri === null) { throw new Exception\RuntimeException('Request URI has not been set'); } if ($uri->getHost() === null) { $uri->setHost($this->requestUri->getHost()); } if ($uri->getScheme() === null) { $uri->setScheme($this->requestUri->getScheme()); } return $uri->setPath($path)->normalize()->toString(); } elseif (!$uri->isAbsolute() && $uri->isValidRelative()) { return $uri->setPath($path)->normalize()->toString(); } return $path; } public function setBaseUrl($baseUrl) { $this->baseUrl = rtrim($baseUrl, '/'); return $this; } public function getBaseUrl() { return $this->baseUrl; } public function setRequestUri(HttpUri $uri) { $this->requestUri = $uri; return $this; } public function getRequestUri() { return $this->requestUri; } } } namespace Zend\Stdlib { use Countable; use Iterator; class PriorityList implements Iterator, Countable { const EXTR_DATA = 0x00000001; const EXTR_PRIORITY = 0x00000002; const EXTR_BOTH = 0x00000003; protected $items = array(); protected $serial = 0; protected $isLIFO = 1; protected $count = 0; protected $sorted = false; public function insert($name, $value, $priority = 0) { $this->sorted = false; $this->count++; $this->items[$name] = array( 'data' => $value, 'priority' => (int) $priority, 'serial' => $this->serial++, ); } public function setPriority($name, $priority) { if (!isset($this->items[$name])) { throw new \Exception("item $name not found"); } $this->items[$name]['priority'] = (int) $priority; $this->sorted = false; return $this; } public function remove($name) { if (!isset($this->items[$name])) { return; } $this->count--; unset($this->items[$name]); } public function clear() { $this->items = array(); $this->serial = 0; $this->count = 0; $this->sorted = false; } public function get($name) { if (!isset($this->items[$name])) { return null; } return $this->items[$name]['data']; } protected function sort() { if (!$this->sorted) { uasort($this->items, array($this, 'compare')); $this->sorted = true; } } protected function compare(array $item1, array $item2) { return ($item1['priority'] === $item2['priority']) ? ($item1['serial'] > $item2['serial'] ? -1 : 1) * $this->isLIFO : ($item1['priority'] > $item2['priority'] ? -1 : 1); } public function isLIFO($flag = null) { if ($flag !== null) { if (($flag = ($flag === true ? 1 : -1)) !== $this->isLIFO) { $this->isLIFO = $flag; $this->sorted = false; } } return $this->isLIFO === 1; } public function rewind() { $this->sort(); reset($this->items); } public function current() { $node = current($this->items); return ($node !== false ? $node['data'] : false); } public function key() { return key($this->items); } public function next() { $node = next($this->items); return ($node !== false ? $node['data'] : false); } public function valid() { return ($this->current() !== false); } public function count() { return $this->count; } public function toArray($flag = self::EXTR_DATA) { $this->sort(); if ($flag == self::EXTR_BOTH) { return $this->items; } return array_map( ($flag == self::EXTR_PRIORITY) ? function ($item) { return $item['priority']; } : function ($item) { return $item['data']; }, $this->items ); } } } namespace Zend\Mvc\Router { use Zend\Stdlib\PriorityList as StdlibPriorityList; class PriorityList extends StdlibPriorityList { } } namespace Zend\Mvc\Router\Http { use Traversable; use Zend\Mvc\Router\Exception; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\RequestInterface as Request; class Literal implements RouteInterface { protected $route; protected $defaults; public function __construct($route, array $defaults = array()) { $this->route = $route; $this->defaults = $defaults; } public static function factory($options = array()) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } if (!isset($options['route'])) { throw new Exception\InvalidArgumentException('Missing "route" in options array'); } if (!isset($options['defaults'])) { $options['defaults'] = array(); } return new static($options['route'], $options['defaults']); } public function match(Request $request, $pathOffset = null) { if (!method_exists($request, 'getUri')) { return null; } $uri = $request->getUri(); $path = $uri->getPath(); if ($pathOffset !== null) { if ($pathOffset >= 0 && strlen($path) >= $pathOffset && !empty($this->route)) { if (strpos($path, $this->route, $pathOffset) === $pathOffset) { return new RouteMatch($this->defaults, strlen($this->route)); } } return null; } if ($path === $this->route) { return new RouteMatch($this->defaults, strlen($this->route)); } return null; } public function assemble(array $params = array(), array $options = array()) { return $this->route; } public function getAssembledParams() { return array(); } } } namespace Zend\Mvc\Router\Http { use Traversable; use Zend\I18n\Translator\TranslatorInterface as Translator; use Zend\Mvc\Router\Exception; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\RequestInterface as Request; class Segment implements RouteInterface { protected static $cacheEncode = array(); protected static $urlencodeCorrectionMap = array( '%21' => "!", '%24' => "$", '%26' => "&", '%27' => "'", '%28' => "(", '%29' => ")", '%2A' => "*", '%2B' => "+", '%2C' => ",", '%3A' => ":", '%3B' => ";", '%3D' => "=", '%40' => "@", ); protected $parts; protected $regex; protected $paramMap = array(); protected $defaults; protected $assembledParams = array(); protected $translationKeys = array(); public function __construct($route, array $constraints = array(), array $defaults = array()) { $this->defaults = $defaults; $this->parts = $this->parseRouteDefinition($route); $this->regex = $this->buildRegex($this->parts, $constraints); } public static function factory($options = array()) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } if (!isset($options['route'])) { throw new Exception\InvalidArgumentException('Missing "route" in options array'); } if (!isset($options['constraints'])) { $options['constraints'] = array(); } if (!isset($options['defaults'])) { $options['defaults'] = array(); } return new static($options['route'], $options['constraints'], $options['defaults']); } protected function parseRouteDefinition($def) { $currentPos = 0; $length = strlen($def); $parts = array(); $levelParts = array(&$parts); $level = 0; while ($currentPos < $length) { preg_match('(\G(?P<literal>[^:{\[\]]*)(?P<token>[:{\[\]]|$))', $def, $matches, 0, $currentPos); $currentPos += strlen($matches[0]); if (!empty($matches['literal'])) { $levelParts[$level][] = array('literal', $matches['literal']); } if ($matches['token'] === ':') { if (!preg_match('(\G(?P<name>[^:/{\[\]]+)(?:{(?P<delimiters>[^}]+)})?:?)', $def, $matches, 0, $currentPos)) { throw new Exception\RuntimeException('Found empty parameter name'); } $levelParts[$level][] = array('parameter', $matches['name'], isset($matches['delimiters']) ? $matches['delimiters'] : null); $currentPos += strlen($matches[0]); } elseif ($matches['token'] === '{') { if (!preg_match('(\G(?P<literal>[^}]+)\})', $def, $matches, 0, $currentPos)) { throw new Exception\RuntimeException('Translated literal missing closing bracket'); } $currentPos += strlen($matches[0]); $levelParts[$level][] = array('translated-literal', $matches['literal']); } elseif ($matches['token'] === '[') { $levelParts[$level][] = array('optional', array()); $levelParts[$level + 1] = &$levelParts[$level][count($levelParts[$level]) - 1][1]; $level++; } elseif ($matches['token'] === ']') { unset($levelParts[$level]); $level--; if ($level < 0) { throw new Exception\RuntimeException('Found closing bracket without matching opening bracket'); } } else { break; } } if ($level > 0) { throw new Exception\RuntimeException('Found unbalanced brackets'); } return $parts; } protected function buildRegex(array $parts, array $constraints, &$groupIndex = 1) { $regex = ''; foreach ($parts as $part) { switch ($part[0]) { case 'literal': $regex .= preg_quote($part[1]); break; case 'parameter': $groupName = '?P<param' . $groupIndex . '>'; if (isset($constraints[$part[1]])) { $regex .= '(' . $groupName . $constraints[$part[1]] . ')'; } elseif ($part[2] === null) { $regex .= '(' . $groupName . '[^/]+)'; } else { $regex .= '(' . $groupName . '[^' . $part[2] . ']+)'; } $this->paramMap['param' . $groupIndex++] = $part[1]; break; case 'optional': $regex .= '(?:' . $this->buildRegex($part[1], $constraints, $groupIndex) . ')?'; break; case 'translated-literal': $regex .= '#' . $part[1] . '#'; $this->translationKeys[] = $part[1]; break; } } return $regex; } protected function buildPath(array $parts, array $mergedParams, $isOptional, $hasChild, array $options) { if ($this->translationKeys) { if (!isset($options['translator']) || !$options['translator'] instanceof Translator) { throw new Exception\RuntimeException('No translator provided'); } $translator = $options['translator']; $textDomain = (isset($options['text_domain']) ? $options['text_domain'] : 'default'); $locale = (isset($options['locale']) ? $options['locale'] : null); } $path = ''; $skip = true; $skippable = false; foreach ($parts as $part) { switch ($part[0]) { case 'literal': $path .= $part[1]; break; case 'parameter': $skippable = true; if (!isset($mergedParams[$part[1]])) { if (!$isOptional || $hasChild) { throw new Exception\InvalidArgumentException(sprintf('Missing parameter "%s"', $part[1])); } return ''; } elseif (!$isOptional || $hasChild || !isset($this->defaults[$part[1]]) || $this->defaults[$part[1]] !== $mergedParams[$part[1]]) { $skip = false; } $path .= $this->encode($mergedParams[$part[1]]); $this->assembledParams[] = $part[1]; break; case 'optional': $skippable = true; $optionalPart = $this->buildPath($part[1], $mergedParams, true, $hasChild, $options); if ($optionalPart !== '') { $path .= $optionalPart; $skip = false; } break; case 'translated-literal': $path .= $translator->translate($part[1], $textDomain, $locale); break; } } if ($isOptional && $skippable && $skip) { return ''; } return $path; } public function match(Request $request, $pathOffset = null, array $options = array()) { if (!method_exists($request, 'getUri')) { return null; } $uri = $request->getUri(); $path = $uri->getPath(); $regex = $this->regex; if ($this->translationKeys) { if (!isset($options['translator']) || !$options['translator'] instanceof Translator) { throw new Exception\RuntimeException('No translator provided'); } $translator = $options['translator']; $textDomain = (isset($options['text_domain']) ? $options['text_domain'] : 'default'); $locale = (isset($options['locale']) ? $options['locale'] : null); foreach ($this->translationKeys as $key) { $regex = str_replace('#' . $key . '#', $translator->translate($key, $textDomain, $locale), $regex); } } if ($pathOffset !== null) { $result = preg_match('(\G' . $regex . ')', $path, $matches, null, $pathOffset); } else { $result = preg_match('(^' . $regex . '$)', $path, $matches); } if (!$result) { return null; } $matchedLength = strlen($matches[0]); $params = array(); foreach ($this->paramMap as $index => $name) { if (isset($matches[$index]) && $matches[$index] !== '') { $params[$name] = $this->decode($matches[$index]); } } return new RouteMatch(array_merge($this->defaults, $params), $matchedLength); } public function assemble(array $params = array(), array $options = array()) { $this->assembledParams = array(); return $this->buildPath( $this->parts, array_merge($this->defaults, $params), false, (isset($options['has_child']) ? $options['has_child'] : false), $options ); } public function getAssembledParams() { return $this->assembledParams; } protected function encode($value) { $key = (string) $value; if (!isset(static::$cacheEncode[$key])) { static::$cacheEncode[$key] = rawurlencode($value); static::$cacheEncode[$key] = strtr(static::$cacheEncode[$key], static::$urlencodeCorrectionMap); } return static::$cacheEncode[$key]; } protected function decode($value) { return rawurldecode($value); } } } namespace Zend\Mvc\Router\Http { use ArrayObject; use Traversable; use Zend\Mvc\Router\Exception; use Zend\Mvc\Router\PriorityList; use Zend\Mvc\Router\RoutePluginManager; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\RequestInterface as Request; class Part extends TreeRouteStack implements RouteInterface { protected $route; protected $mayTerminate; protected $childRoutes; public function __construct($route, $mayTerminate, RoutePluginManager $routePlugins, array $childRoutes = null, ArrayObject $prototypes = null) { $this->routePluginManager = $routePlugins; if (!$route instanceof RouteInterface) { $route = $this->routeFromArray($route); } if ($route instanceof self) { throw new Exception\InvalidArgumentException('Base route may not be a part route'); } $this->route = $route; $this->mayTerminate = $mayTerminate; $this->childRoutes = $childRoutes; $this->prototypes = $prototypes; $this->routes = new PriorityList(); } public static function factory($options = array()) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(__METHOD__ . ' expects an array or Traversable set of options'); } if (!isset($options['route'])) { throw new Exception\InvalidArgumentException('Missing "route" in options array'); } if (!isset($options['route_plugins'])) { throw new Exception\InvalidArgumentException('Missing "route_plugins" in options array'); } if (!isset($options['prototypes'])) { $options['prototypes'] = null; } if (!isset($options['may_terminate'])) { $options['may_terminate'] = false; } if (!isset($options['child_routes']) || !$options['child_routes']) { $options['child_routes'] = null; } if ($options['child_routes'] instanceof Traversable) { $options['child_routes'] = ArrayUtils::iteratorToArray($options['child_routes']); } return new static( $options['route'], $options['may_terminate'], $options['route_plugins'], $options['child_routes'], $options['prototypes'] ); } public function match(Request $request, $pathOffset = null, array $options = array()) { if ($pathOffset === null) { $pathOffset = 0; } $match = $this->route->match($request, $pathOffset, $options); if ($match !== null && method_exists($request, 'getUri')) { if ($this->childRoutes !== null) { $this->addRoutes($this->childRoutes); $this->childRoutes = null; } $nextOffset = $pathOffset + $match->getLength(); $uri = $request->getUri(); $pathLength = strlen($uri->getPath()); if ($this->mayTerminate && $nextOffset === $pathLength) { $query = $uri->getQuery(); if ('' == trim($query) || !$this->hasQueryChild()) { return $match; } } if (isset($options['translator']) && !isset($options['locale']) && null !== ($locale = $match->getParam('locale', null))) { $options['locale'] = $locale; } foreach ($this->routes as $name => $route) { if (($subMatch = $route->match($request, $nextOffset, $options)) instanceof RouteMatch) { if ($match->getLength() + $subMatch->getLength() + $pathOffset === $pathLength) { return $match->merge($subMatch)->setMatchedRouteName($name); } } } } return null; } public function assemble(array $params = array(), array $options = array()) { if ($this->childRoutes !== null) { $this->addRoutes($this->childRoutes); $this->childRoutes = null; } $options['has_child'] = (isset($options['name'])); if (isset($options['translator']) && !isset($options['locale']) && isset($params['locale'])) { $options['locale'] = $params['locale']; } $path = $this->route->assemble($params, $options); $params = array_diff_key($params, array_flip($this->route->getAssembledParams())); if (!isset($options['name'])) { if (!$this->mayTerminate) { throw new Exception\RuntimeException('Part route may not terminate'); } else { return $path; } } unset($options['has_child']); $options['only_return_path'] = true; $path .= parent::assemble($params, $options); return $path; } public function getAssembledParams() { return array(); } protected function hasQueryChild() { foreach ($this->routes as $route) { if ($route instanceof Query) { return true; } } return false; } } } namespace Zend\Mvc\View\Http { use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\Http\Response as HttpResponse; use Zend\Mvc\Application; use Zend\Mvc\MvcEvent; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ViewModel; class RouteNotFoundStrategy extends AbstractListenerAggregate { protected $displayExceptions = false; protected $displayNotFoundReason = false; protected $notFoundTemplate = 'error'; protected $reason = false; public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'prepareNotFoundViewModel'), -90); $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'detectNotFoundError')); $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'prepareNotFoundViewModel')); } public function setDisplayExceptions($displayExceptions) { $this->displayExceptions = (bool) $displayExceptions; return $this; } public function displayExceptions() { return $this->displayExceptions; } public function setDisplayNotFoundReason($displayNotFoundReason) { $this->displayNotFoundReason = (bool) $displayNotFoundReason; return $this; } public function displayNotFoundReason() { return $this->displayNotFoundReason; } public function setNotFoundTemplate($notFoundTemplate) { $this->notFoundTemplate = (string) $notFoundTemplate; return $this; } public function getNotFoundTemplate() { return $this->notFoundTemplate; } public function detectNotFoundError(MvcEvent $e) { $error = $e->getError(); if (empty($error)) { return; } switch ($error) { case Application::ERROR_CONTROLLER_NOT_FOUND: case Application::ERROR_CONTROLLER_INVALID: case Application::ERROR_ROUTER_NO_MATCH: $this->reason = $error; $response = $e->getResponse(); if (!$response) { $response = new HttpResponse(); $e->setResponse($response); } $response->setStatusCode(404); break; default: return; } } public function prepareNotFoundViewModel(MvcEvent $e) { $vars = $e->getResult(); if ($vars instanceof Response) { return; } $response = $e->getResponse(); if ($response->getStatusCode() != 404) { return; } if (!$vars instanceof ViewModel) { $model = new ViewModel(); if (is_string($vars)) { $model->setVariable('message', $vars); } else { $model->setVariable('message', 'Page not found.'); } } else { $model = $vars; if ($model->getVariable('message') === null) { $model->setVariable('message', 'Page not found.'); } } $model->setTemplate($this->getNotFoundTemplate()); $this->injectNotFoundReason($model); $this->injectException($model, $e); $this->injectController($model, $e); $e->setResult($model); } protected function injectNotFoundReason(ViewModel $model) { if (!$this->displayNotFoundReason()) { return; } if ($this->reason) { $model->setVariable('reason', $this->reason); return; } $model->setVariable('reason', Application::ERROR_CONTROLLER_CANNOT_DISPATCH); } protected function injectException($model, $e) { if (!$this->displayExceptions()) { return; } $model->setVariable('display_exceptions', true); $exception = $e->getParam('exception', false); if (!$exception instanceof \Exception) { return; } $model->setVariable('exception', $exception); } protected function injectController($model, $e) { if (!$this->displayExceptions() && !$this->displayNotFoundReason()) { return; } $controller = $e->getController(); if (empty($controller)) { $routeMatch = $e->getRouteMatch(); if (empty($routeMatch)) { return; } $controller = $routeMatch->getParam('controller', false); if (!$controller) { return; } } $controllerClass = $e->getControllerClass(); $model->setVariable('controller', $controller); $model->setVariable('controller_class', $controllerClass); } } } namespace Zend\Mvc\View\Http { use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\Http\Response as HttpResponse; use Zend\Mvc\Application; use Zend\Mvc\MvcEvent; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ViewModel; class ExceptionStrategy extends AbstractListenerAggregate { protected $displayExceptions = false; protected $exceptionTemplate = 'error'; public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'prepareExceptionViewModel')); $this->listeners[] = $events->attach(MvcEvent::EVENT_RENDER_ERROR, array($this, 'prepareExceptionViewModel')); } public function setDisplayExceptions($displayExceptions) { $this->displayExceptions = (bool) $displayExceptions; return $this; } public function displayExceptions() { return $this->displayExceptions; } public function setExceptionTemplate($exceptionTemplate) { $this->exceptionTemplate = (string) $exceptionTemplate; return $this; } public function getExceptionTemplate() { return $this->exceptionTemplate; } public function prepareExceptionViewModel(MvcEvent $e) { $error = $e->getError(); if (empty($error)) { return; } $result = $e->getResult(); if ($result instanceof Response) { return; } switch ($error) { case Application::ERROR_CONTROLLER_NOT_FOUND: case Application::ERROR_CONTROLLER_INVALID: case Application::ERROR_ROUTER_NO_MATCH: return; case Application::ERROR_EXCEPTION: default: $model = new ViewModel(array( 'message' => 'An error occurred during execution; please try again later.', 'exception' => $e->getParam('exception'), 'display_exceptions' => $this->displayExceptions(), )); $model->setTemplate($this->getExceptionTemplate()); $e->setResult($model); $response = $e->getResponse(); if (!$response) { $response = new HttpResponse(); $response->setStatusCode(500); $e->setResponse($response); } else { $statusCode = $response->getStatusCode(); if ($statusCode === 200) { $response->setStatusCode(500); } } break; } } } } namespace Zend\Mvc\View\Http { use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\Mvc\Application; use Zend\Mvc\MvcEvent; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ModelInterface as ViewModel; use Zend\View\View; class DefaultRenderingStrategy extends AbstractListenerAggregate { protected $layoutTemplate = 'layout'; protected $view; public function __construct(View $view) { $this->view = $view; } public function attach(EventManagerInterface $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_RENDER, array($this, 'render'), -10000); $this->listeners[] = $events->attach(MvcEvent::EVENT_RENDER_ERROR, array($this, 'render'), -10000); } public function setLayoutTemplate($layoutTemplate) { $this->layoutTemplate = (string) $layoutTemplate; return $this; } public function getLayoutTemplate() { return $this->layoutTemplate; } public function render(MvcEvent $e) { $result = $e->getResult(); if ($result instanceof Response) { return $result; } $request = $e->getRequest(); $response = $e->getResponse(); $viewModel = $e->getViewModel(); if (!$viewModel instanceof ViewModel) { return; } $view = $this->view; $view->setRequest($request); $view->setResponse($response); try { $view->render($viewModel); } catch (\Exception $ex) { if ($e->getName() === MvcEvent::EVENT_RENDER_ERROR) { throw $ex; } $application = $e->getApplication(); $events = $application->getEventManager(); $e->setError(Application::ERROR_EXCEPTION) ->setParam('exception', $ex); $events->trigger(MvcEvent::EVENT_RENDER_ERROR, $e); } return $response; } } } namespace Zend\View { use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\Stdlib\RequestInterface as Request; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ModelInterface as Model; use Zend\View\Renderer\RendererInterface as Renderer; use Zend\View\Renderer\TreeRendererInterface; class View implements EventManagerAwareInterface { protected $events; protected $request; protected $response; public function setRequest(Request $request) { $this->request = $request; return $this; } public function setResponse(Response $response) { $this->response = $response; return $this; } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers(array( __CLASS__, get_class($this), )); $this->events = $events; return $this; } public function getEventManager() { if (!$this->events instanceof EventManagerInterface) { $this->setEventManager(new EventManager()); } return $this->events; } public function addRenderingStrategy($callable, $priority = 1) { $this->getEventManager()->attach(ViewEvent::EVENT_RENDERER, $callable, $priority); return $this; } public function addResponseStrategy($callable, $priority = 1) { $this->getEventManager()->attach(ViewEvent::EVENT_RESPONSE, $callable, $priority); return $this; } public function render(Model $model) { $event = $this->getEvent(); $event->setModel($model); $events = $this->getEventManager(); $results = $events->trigger(ViewEvent::EVENT_RENDERER, $event, function ($result) { return ($result instanceof Renderer); }); $renderer = $results->last(); if (!$renderer instanceof Renderer) { throw new Exception\RuntimeException(sprintf( '%s: no renderer selected!', __METHOD__ )); } $event->setRenderer($renderer); $events->trigger(ViewEvent::EVENT_RENDERER_POST, $event); $model = $event->getModel(); if ($model->hasChildren() && (!$renderer instanceof TreeRendererInterface || !$renderer->canRenderTrees()) ) { $this->renderChildren($model); } $event->setModel($model); $event->setRenderer($renderer); $rendered = $renderer->render($model); $options = $model->getOptions(); if (array_key_exists('has_parent', $options) && $options['has_parent']) { return $rendered; } $event->setResult($rendered); $events->trigger(ViewEvent::EVENT_RESPONSE, $event); } protected function renderChildren(Model $model) { foreach ($model as $child) { if ($child->terminate()) { throw new Exception\DomainException('Inconsistent state; child view model is marked as terminal'); } $child->setOption('has_parent', true); $result = $this->render($child); $child->setOption('has_parent', null); $capture = $child->captureTo(); if (!empty($capture)) { if ($child->isAppend()) { $oldResult=$model->{$capture}; $model->setVariable($capture, $oldResult . $result); } else { $model->setVariable($capture, $result); } } } } protected function getEvent() { $event = new ViewEvent(); $event->setTarget($this); if (null !== ($request = $this->getRequest())) { $event->setRequest($request); } if (null !== ($response = $this->getResponse())) { $event->setResponse($response); } return $event; } } } namespace Zend\View\Strategy { use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface; use Zend\View\Renderer\PhpRenderer; use Zend\View\ViewEvent; class PhpRendererStrategy extends AbstractListenerAggregate { protected $contentPlaceholders = array('article', 'content'); protected $renderer; public function __construct(PhpRenderer $renderer) { $this->renderer = $renderer; } public function getRenderer() { return $this->renderer; } public function setContentPlaceholders(array $contentPlaceholders) { $this->contentPlaceholders = $contentPlaceholders; return $this; } public function getContentPlaceholders() { return $this->contentPlaceholders; } public function attach(EventManagerInterface $events, $priority = 1) { $this->listeners[] = $events->attach(ViewEvent::EVENT_RENDERER, array($this, 'selectRenderer'), $priority); $this->listeners[] = $events->attach(ViewEvent::EVENT_RESPONSE, array($this, 'injectResponse'), $priority); } public function selectRenderer(ViewEvent $e) { return $this->renderer; } public function injectResponse(ViewEvent $e) { $renderer = $e->getRenderer(); if ($renderer !== $this->renderer) { return; } $result = $e->getResult(); $response = $e->getResponse(); if (empty($result)) { $placeholders = $renderer->plugin('placeholder'); foreach ($this->contentPlaceholders as $placeholder) { if ($placeholders->containerExists($placeholder)) { $result = (string) $placeholders->getContainer($placeholder); break; } } } $response->setContent($result); } } } namespace Zend\View\Renderer { use ArrayAccess; use Traversable; use Zend\Filter\FilterChain; use Zend\View\Exception; use Zend\View\HelperPluginManager; use Zend\View\Helper\AbstractHelper; use Zend\View\Model\ModelInterface as Model; use Zend\View\Renderer\RendererInterface as Renderer; use Zend\View\Resolver\ResolverInterface as Resolver; use Zend\View\Resolver\TemplatePathStack; use Zend\View\Variables; class PhpRenderer implements Renderer, TreeRendererInterface { private $__content = ''; private $__renderTrees = false; private $__template = null; private $__templates = array(); private $__templateResolver; private $__file = null; private $__helpers; private $__filterChain; private $__vars; private $__varsCache = array(); private $__pluginCache = array(); public function __construct($config = array()) { $this->init(); } public function getEngine() { return $this; } public function init() { } public function setResolver(Resolver $resolver) { $this->__templateResolver = $resolver; return $this; } public function resolver($name = null) { if (null === $this->__templateResolver) { $this->setResolver(new TemplatePathStack()); } if (null !== $name) { return $this->__templateResolver->resolve($name, $this); } return $this->__templateResolver; } public function setVars($variables) { if (!is_array($variables) && !$variables instanceof ArrayAccess) { throw new Exception\InvalidArgumentException(sprintf( 'Expected array or ArrayAccess object; received "%s"', (is_object($variables) ? get_class($variables) : gettype($variables)) )); } if (!$variables instanceof Variables) { $variablesAsArray = array(); foreach ($variables as $key => $value) { $variablesAsArray[$key] = $value; } $variables = new Variables($variablesAsArray); } $this->__vars = $variables; return $this; } public function vars($key = null) { if (null === $this->__vars) { $this->setVars(new Variables()); } if (null === $key) { return $this->__vars; } return $this->__vars[$key]; } public function get($key) { if (null === $this->__vars) { $this->setVars(new Variables()); } return $this->__vars[$key]; } public function __get($name) { $vars = $this->vars(); return $vars[$name]; } public function __set($name, $value) { $vars = $this->vars(); $vars[$name] = $value; } public function __isset($name) { $vars = $this->vars(); return isset($vars[$name]); } public function __unset($name) { $vars = $this->vars(); if (!isset($vars[$name])) { return; } unset($vars[$name]); } public function setHelperPluginManager($helpers) { if (is_string($helpers)) { if (!class_exists($helpers)) { throw new Exception\InvalidArgumentException(sprintf( 'Invalid helper helpers class provided (%s)', $helpers )); } $helpers = new $helpers(); } if (!$helpers instanceof HelperPluginManager) { throw new Exception\InvalidArgumentException(sprintf( 'Helper helpers must extend Zend\View\HelperPluginManager; got type "%s" instead', (is_object($helpers) ? get_class($helpers) : gettype($helpers)) )); } $helpers->setRenderer($this); $this->__helpers = $helpers; return $this; } public function getHelperPluginManager() { if (null === $this->__helpers) { $this->setHelperPluginManager(new HelperPluginManager()); } return $this->__helpers; } public function plugin($name, array $options = null) { return $this->getHelperPluginManager()->get($name, $options); } public function __call($method, $argv) { if (!isset($this->__pluginCache[$method])) { $this->__pluginCache[$method] = $this->plugin($method); } if (is_callable($this->__pluginCache[$method])) { return call_user_func_array($this->__pluginCache[$method], $argv); } return $this->__pluginCache[$method]; } public function setFilterChain(FilterChain $filters) { $this->__filterChain = $filters; return $this; } public function getFilterChain() { if (null === $this->__filterChain) { $this->setFilterChain(new FilterChain()); } return $this->__filterChain; } public function render($nameOrModel, $values = null) { if ($nameOrModel instanceof Model) { $model = $nameOrModel; $nameOrModel = $model->getTemplate(); if (empty($nameOrModel)) { throw new Exception\DomainException(sprintf( '%s: received View Model argument, but template is empty', __METHOD__ )); } $options = $model->getOptions(); foreach ($options as $setting => $value) { $method = 'set' . $setting; if (method_exists($this, $method)) { $this->$method($value); } unset($method, $setting, $value); } unset($options); $helper = $this->plugin('view_model'); $helper->setCurrent($model); $values = $model->getVariables(); unset($model); } $this->addTemplate($nameOrModel); unset($nameOrModel); $this->__varsCache[] = $this->vars(); if (null !== $values) { $this->setVars($values); } unset($values); $__vars = $this->vars()->getArrayCopy(); if (array_key_exists('this', $__vars)) { unset($__vars['this']); } extract($__vars); unset($__vars); while ($this->__template = array_pop($this->__templates)) { $this->__file = $this->resolver($this->__template); if (!$this->__file) { throw new Exception\RuntimeException(sprintf( '%s: Unable to render template "%s"; resolver could not resolve to a file', __METHOD__, $this->__template )); } try { ob_start(); $includeReturn = include $this->__file; $this->__content = ob_get_clean(); } catch (\Exception $ex) { ob_end_clean(); throw $ex; } if ($includeReturn === false && empty($this->__content)) { throw new Exception\UnexpectedValueException(sprintf( '%s: Unable to render template "%s"; file include failed', __METHOD__, $this->__file )); } } $this->setVars(array_pop($this->__varsCache)); return $this->getFilterChain()->filter($this->__content); } public function setCanRenderTrees($renderTrees) { $this->__renderTrees = (bool) $renderTrees; return $this; } public function canRenderTrees() { return $this->__renderTrees; } public function addTemplate($template) { $this->__templates[] = $template; return $this; } public function __clone() { $this->__vars = clone $this->vars(); } } } namespace Zend\Mvc\Service { use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\View\Resolver as ViewResolver; class ViewResolverFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $resolver = new ViewResolver\AggregateResolver(); $resolver->attach($serviceLocator->get('ViewTemplateMapResolver')); $resolver->attach($serviceLocator->get('ViewTemplatePathStack')); return $resolver; } } } namespace Zend\View\Resolver { use Countable; use IteratorAggregate; use Zend\Stdlib\PriorityQueue; use Zend\View\Renderer\RendererInterface as Renderer; use Zend\View\Resolver\ResolverInterface as Resolver; class AggregateResolver implements Countable, IteratorAggregate, Resolver { const FAILURE_NO_RESOLVERS = 'AggregateResolver_Failure_No_Resolvers'; const FAILURE_NOT_FOUND = 'AggregateResolver_Failure_Not_Found'; protected $lastLookupFailure = false; protected $lastSuccessfulResolver; protected $queue; public function __construct() { $this->queue = new PriorityQueue(); } public function count() { return $this->queue->count(); } public function getIterator() { return $this->queue; } public function attach(Resolver $resolver, $priority = 1) { $this->queue->insert($resolver, $priority); return $this; } public function resolve($name, Renderer $renderer = null) { $this->lastLookupFailure = false; $this->lastSuccessfulResolver = null; if (0 === count($this->queue)) { $this->lastLookupFailure = static::FAILURE_NO_RESOLVERS; return false; } foreach ($this->queue as $resolver) { $resource = $resolver->resolve($name, $renderer); if (!$resource) { continue; } $this->lastSuccessfulResolver = $resolver; return $resource; } $this->lastLookupFailure = static::FAILURE_NOT_FOUND; return false; } public function getLastSuccessfulResolver() { return $this->lastSuccessfulResolver; } public function getLastLookupFailure() { return $this->lastLookupFailure; } } } namespace Zend\Mvc\Service { use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\View\Resolver as ViewResolver; class ViewTemplateMapResolverFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $config = $serviceLocator->get('Config'); $map = array(); if (is_array($config) && isset($config['view_manager'])) { $config = $config['view_manager']; if (is_array($config) && isset($config['template_map'])) { $map = $config['template_map']; } } return new ViewResolver\TemplateMapResolver($map); } } } namespace Zend\View\Resolver { use ArrayIterator; use IteratorAggregate; use Traversable; use Zend\Stdlib\ArrayUtils; use Zend\View\Exception; use Zend\View\Renderer\RendererInterface as Renderer; class TemplateMapResolver implements IteratorAggregate, ResolverInterface { protected $map = array(); public function __construct($map = array()) { $this->setMap($map); } public function getIterator() { return new ArrayIterator($this->map); } public function setMap($map) { if (!is_array($map) && !$map instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects an array or Traversable, received "%s"', __METHOD__, (is_object($map) ? get_class($map) : gettype($map)) )); } if ($map instanceof Traversable) { $map = ArrayUtils::iteratorToArray($map); } $this->map = $map; return $this; } public function add($nameOrMap, $path = null) { if (is_array($nameOrMap) || $nameOrMap instanceof Traversable) { $this->merge($nameOrMap); return $this; } if (!is_string($nameOrMap)) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects a string, array, or Traversable for the first argument; received "%s"', __METHOD__, (is_object($nameOrMap) ? get_class($nameOrMap) : gettype($nameOrMap)) )); } if (empty($path)) { if (isset($this->map[$nameOrMap])) { unset($this->map[$nameOrMap]); } return $this; } $this->map[$nameOrMap] = $path; return $this; } public function merge($map) { if (!is_array($map) && !$map instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects an array or Traversable, received "%s"', __METHOD__, (is_object($map) ? get_class($map) : gettype($map)) )); } if ($map instanceof Traversable) { $map = ArrayUtils::iteratorToArray($map); } $this->map = array_replace_recursive($this->map, $map); return $this; } public function has($name) { return array_key_exists($name, $this->map); } public function get($name) { if (!$this->has($name)) { return false; } return $this->map[$name]; } public function getMap() { return $this->map; } public function resolve($name, Renderer $renderer = null) { return $this->get($name); } } } namespace Zend\Mvc\Service { use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\View\Resolver as ViewResolver; class ViewTemplatePathStackFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $config = $serviceLocator->get('Config'); $templatePathStack = new ViewResolver\TemplatePathStack(); if (is_array($config) && isset($config['view_manager'])) { $config = $config['view_manager']; if (is_array($config)) { if (isset($config['template_path_stack'])) { $templatePathStack->addPaths($config['template_path_stack']); } if (isset($config['default_template_suffix'])) { $templatePathStack->setDefaultSuffix($config['default_template_suffix']); } } } return $templatePathStack; } } } namespace Zend\View\Resolver { use SplFileInfo; use Traversable; use Zend\Stdlib\SplStack; use Zend\View\Exception; use Zend\View\Renderer\RendererInterface as Renderer; class TemplatePathStack implements ResolverInterface { const FAILURE_NO_PATHS = 'TemplatePathStack_Failure_No_Paths'; const FAILURE_NOT_FOUND = 'TemplatePathStack_Failure_Not_Found'; protected $defaultSuffix = 'phtml'; protected $paths; protected $lastLookupFailure = false; protected $lfiProtectionOn = true; protected $useViewStream = false; protected $useStreamWrapper = false; public function __construct($options = null) { $this->useViewStream = (bool) ini_get('short_open_tag'); if ($this->useViewStream) { if (!in_array('zend.view', stream_get_wrappers())) { stream_wrapper_register('zend.view', 'Zend\View\Stream'); } } $this->paths = new SplStack; if (null !== $options) { $this->setOptions($options); } } public function setOptions($options) { if (!is_array($options) && !$options instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Expected array or Traversable object; received "%s"', (is_object($options) ? get_class($options) : gettype($options)) )); } foreach ($options as $key => $value) { switch (strtolower($key)) { case 'lfi_protection': $this->setLfiProtection($value); break; case 'script_paths': $this->addPaths($value); break; case 'use_stream_wrapper': $this->setUseStreamWrapper($value); break; case 'default_suffix': $this->setDefaultSuffix($value); break; default: break; } } } public function setDefaultSuffix($defaultSuffix) { $this->defaultSuffix = (string) $defaultSuffix; $this->defaultSuffix = ltrim($this->defaultSuffix, '.'); return $this; } public function getDefaultSuffix() { return $this->defaultSuffix; } public function addPaths(array $paths) { foreach ($paths as $path) { $this->addPath($path); } return $this; } public function setPaths($paths) { if ($paths instanceof SplStack) { $this->paths = $paths; } elseif (is_array($paths)) { $this->clearPaths(); $this->addPaths($paths); } else { throw new Exception\InvalidArgumentException( "Invalid argument provided for \$paths, expecting either an array or SplStack object" ); } return $this; } public static function normalizePath($path) { $path = rtrim($path, '/'); $path = rtrim($path, '\\'); $path .= DIRECTORY_SEPARATOR; return $path; } public function addPath($path) { if (!is_string($path)) { throw new Exception\InvalidArgumentException(sprintf( 'Invalid path provided; must be a string, received %s', gettype($path) )); } $this->paths[] = static::normalizePath($path); return $this; } public function clearPaths() { $this->paths = new SplStack; } public function getPaths() { return $this->paths; } public function setLfiProtection($flag) { $this->lfiProtectionOn = (bool) $flag; return $this; } public function isLfiProtectionOn() { return $this->lfiProtectionOn; } public function setUseStreamWrapper($flag) { $this->useStreamWrapper = (bool) $flag; return $this; } public function useStreamWrapper() { return ($this->useViewStream && $this->useStreamWrapper); } public function resolve($name, Renderer $renderer = null) { $this->lastLookupFailure = false; if ($this->isLfiProtectionOn() && preg_match('#\.\.[\\\/]#', $name)) { throw new Exception\DomainException( 'Requested scripts may not include parent directory traversal ("../", "..\\" notation)' ); } if (!count($this->paths)) { $this->lastLookupFailure = static::FAILURE_NO_PATHS; return false; } $defaultSuffix = $this->getDefaultSuffix(); if (pathinfo($name, PATHINFO_EXTENSION) == '') { $name .= '.' . $defaultSuffix; } foreach ($this->paths as $path) { $file = new SplFileInfo($path . $name); if ($file->isReadable()) { if (($filePath = $file->getRealPath()) === false && substr($path, 0, 7) === 'phar://') { $filePath = $path . $name; if (!file_exists($filePath)) { break; } } if ($this->useStreamWrapper()) { $filePath = 'zend.view://' . $filePath; } return $filePath; } } $this->lastLookupFailure = static::FAILURE_NOT_FOUND; return false; } public function getLastLookupFailure() { return $this->lastLookupFailure; } } } namespace Zend\Stdlib { use Serializable; class SplStack extends \SplStack { public function toArray() { $array = array(); foreach ($this as $item) { $array[] = $item; } return $array; } public function serialize() { return serialize($this->toArray()); } public function unserialize($data) { foreach (unserialize($data) as $item) { $this->unshift($item); } } } } namespace Zend\View\Model { use ArrayAccess; use ArrayIterator; use Traversable; use Zend\Stdlib\ArrayUtils; use Zend\View\Exception; use Zend\View\Model; use Zend\View\Variables as ViewVariables; class ViewModel implements ModelInterface, ClearableModelInterface, RetrievableChildrenInterface { protected $captureTo = 'content'; protected $children = array(); protected $options = array(); protected $template = ''; protected $terminate = false; protected $variables = array(); protected $append = false; public function __construct($variables = null, $options = null) { if (null === $variables) { $variables = new ViewVariables(); } $this->setVariables($variables, true); if (null !== $options) { $this->setOptions($options); } } public function __set($name, $value) { $this->setVariable($name, $value); } public function __get($name) { if (!$this->__isset($name)) { return null; } $variables = $this->getVariables(); return $variables[$name]; } public function __isset($name) { $variables = $this->getVariables(); return isset($variables[$name]); } public function __unset($name) { if (!$this->__isset($name)) { return null; } unset($this->variables[$name]); } public function setOption($name, $value) { $this->options[(string) $name] = $value; return $this; } public function getOption($name, $default = null) { $name = (string) $name; return array_key_exists($name, $this->options) ? $this->options[$name] : $default; } public function setOptions($options) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } if (!is_array($options)) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects an array, or Traversable argument; received "%s"', __METHOD__, (is_object($options) ? get_class($options) : gettype($options)) )); } $this->options = $options; return $this; } public function getOptions() { return $this->options; } public function clearOptions() { $this->options = array(); return $this; } public function getVariable($name, $default = null) { $name = (string) $name; if (array_key_exists($name, $this->variables)) { return $this->variables[$name]; } return $default; } public function setVariable($name, $value) { $this->variables[(string) $name] = $value; return $this; } public function setVariables($variables, $overwrite = false) { if (!is_array($variables) && !$variables instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( '%s: expects an array, or Traversable argument; received "%s"', __METHOD__, (is_object($variables) ? get_class($variables) : gettype($variables)) )); } if ($overwrite) { if (is_object($variables) && !$variables instanceof ArrayAccess) { $variables = ArrayUtils::iteratorToArray($variables); } $this->variables = $variables; return $this; } foreach ($variables as $key => $value) { $this->setVariable($key, $value); } return $this; } public function getVariables() { return $this->variables; } public function clearVariables() { $this->variables = new ViewVariables(); return $this; } public function setTemplate($template) { $this->template = (string) $template; return $this; } public function getTemplate() { return $this->template; } public function addChild(ModelInterface $child, $captureTo = null, $append = null) { $this->children[] = $child; if (null !== $captureTo) { $child->setCaptureTo($captureTo); } if (null !== $append) { $child->setAppend($append); } return $this; } public function getChildren() { return $this->children; } public function hasChildren() { return (0 < count($this->children)); } public function clearChildren() { $this->children = array(); return $this; } public function getChildrenByCaptureTo($capture, $recursive = true) { $children = array(); foreach ($this->children as $child) { if ($recursive === true) { $children += $child->getChildrenByCaptureTo($capture); } if ($child->captureTo() === $capture) { $children[] = $child; } } return $children; } public function setCaptureTo($capture) { $this->captureTo = (string) $capture; return $this; } public function captureTo() { return $this->captureTo; } public function setTerminal($terminate) { $this->terminate = (bool) $terminate; return $this; } public function terminate() { return $this->terminate; } public function setAppend($append) { $this->append = (bool) $append; return $this; } public function isAppend() { return $this->append; } public function count() { return count($this->children); } public function getIterator() { return new ArrayIterator($this->children); } } } namespace Zend\View { use ArrayObject; class Variables extends ArrayObject { protected $strictVars = false; public function __construct(array $variables = array(), array $options = array()) { parent::__construct( $variables, ArrayObject::ARRAY_AS_PROPS, 'ArrayIterator' ); $this->setOptions($options); } public function setOptions(array $options) { foreach ($options as $key => $value) { switch (strtolower($key)) { case 'strict_vars': $this->setStrictVars($value); break; default: $this[$key] = $value; break; } } return $this; } public function setStrictVars($flag) { $this->strictVars = (bool) $flag; return $this; } public function isStrict() { return $this->strictVars; } public function assign($spec) { if (is_object($spec)) { if (method_exists($spec, 'toArray')) { $spec = $spec->toArray(); } else { $spec = (array) $spec; } } if (!is_array($spec)) { throw new Exception\InvalidArgumentException(sprintf( 'assign() expects either an array or an object as an argument; received "%s"', gettype($spec) )); } foreach ($spec as $key => $value) { $this[$key] = $value; } return $this; } public function offsetGet($key) { if (!$this->offsetExists($key)) { if ($this->isStrict()) { trigger_error(sprintf( 'View variable "%s" does not exist', $key ), E_USER_NOTICE); } return null; } $return = parent::offsetGet($key); if (is_object($return) && is_callable($return)) { $return = call_user_func($return); } return $return; } public function clear() { $this->exchangeArray(array()); } } } namespace Zend\View\Helper { use Zend\View\Renderer\RendererInterface as Renderer; abstract class AbstractHelper implements HelperInterface { protected $view = null; public function setView(Renderer $view) { $this->view = $view; return $this; } public function getView() { return $this->view; } } } namespace Zend\View\Helper { use Zend\View\Model\ModelInterface as Model; class ViewModel extends AbstractHelper { protected $current; protected $root; public function setCurrent(Model $model) { $this->current = $model; return $this; } public function getCurrent() { return $this->current; } public function hasCurrent() { return ($this->current instanceof Model); } public function setRoot(Model $model) { $this->root = $model; return $this; } public function getRoot() { return $this->root; } public function hasRoot() { return ($this->root instanceof Model); } } } namespace Zend\View { use ArrayAccess; use Zend\EventManager\Event; use Zend\Stdlib\RequestInterface as Request; use Zend\Stdlib\ResponseInterface as Response; use Zend\View\Model\ModelInterface as Model; use Zend\View\Renderer\RendererInterface as Renderer; class ViewEvent extends Event { const EVENT_RENDERER = 'renderer'; const EVENT_RENDERER_POST = 'renderer.post'; const EVENT_RESPONSE = 'response'; protected $model; protected $renderer; protected $request; protected $response; protected $result; public function setModel(Model $model) { $this->model = $model; return $this; } public function setRequest(Request $request) { $this->request = $request; return $this; } public function setResponse(Response $response) { $this->response = $response; return $this; } public function setResult($result) { $this->result = $result; return $this; } public function getModel() { return $this->model; } public function setRenderer(Renderer $renderer) { $this->renderer = $renderer; return $this; } public function getRenderer() { return $this->renderer; } public function getRequest() { return $this->request; } public function getResponse() { return $this->response; } public function getResult() { return $this->result; } public function getParam($name, $default = null) { switch ($name) { case 'model': return $this->getModel(); case 'renderer': return $this->getRenderer(); case 'request': return $this->getRequest(); case 'response': return $this->getResponse(); case 'result': return $this->getResult(); default: return parent::getParam($name, $default); } } public function getParams() { $params = parent::getParams(); $params['model'] = $this->getModel(); $params['renderer'] = $this->getRenderer(); $params['request'] = $this->getRequest(); $params['response'] = $this->getResponse(); $params['result'] = $this->getResult(); return $params; } public function setParams($params) { parent::setParams($params); if (!is_array($params) && !$params instanceof ArrayAccess) { return $this; } foreach (array('model', 'renderer', 'request', 'response', 'result') as $param) { if (isset($params[$param])) { $method = 'set' . $param; $this->$method($params[$param]); } } return $this; } public function setParam($name, $value) { switch ($name) { case 'model': $this->setModel($value); break; case 'renderer': $this->setRenderer($value); break; case 'request': $this->setRequest($value); break; case 'response': $this->setResponse($value); break; case 'result': $this->setResult($value); break; default: parent::setParam($name, $value); break; } return $this; } } } namespace Zend\Mvc\View\Http { use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface as Events; use Zend\Filter\Word\CamelCaseToDash as CamelCaseToDashFilter; use Zend\Mvc\MvcEvent; use Zend\Mvc\ModuleRouteListener; use Zend\View\Model\ModelInterface as ViewModel; class InjectTemplateListener extends AbstractListenerAggregate { protected $inflector; protected $controllerMap = array(); public function attach(Events $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'injectTemplate'), -90); } public function injectTemplate(MvcEvent $e) { $model = $e->getResult(); if (!$model instanceof ViewModel) { return; } $template = $model->getTemplate(); if (!empty($template)) { return; } $routeMatch = $e->getRouteMatch(); $controller = $e->getTarget(); if (is_object($controller)) { $controller = get_class($controller); } if (!$controller) { $controller = $routeMatch->getParam('controller', ''); } $template = $this->mapController($controller); if (!$template) { $module = $this->deriveModuleNamespace($controller); if ($namespace = $routeMatch->getParam(ModuleRouteListener::MODULE_NAMESPACE)) { $controllerSubNs = $this->deriveControllerSubNamespace($namespace); if (!empty($controllerSubNs)) { if (!empty($module)) { $module .= '/' . $controllerSubNs; } else { $module = $controllerSubNs; } } } $controller = $this->deriveControllerClass($controller); $template = $this->inflectName($module); if (!empty($template)) { $template .= '/'; } $template .= $this->inflectName($controller); } $action = $routeMatch->getParam('action'); if (null !== $action) { $template .= '/' . $this->inflectName($action); } $model->setTemplate($template); } public function setControllerMap(array $map) { krsort($map); $this->controllerMap = $map; return $this; } public function mapController($controller) { foreach ($this->controllerMap as $namespace => $replacement) { if ( false == $replacement || !($controller === $namespace || strpos($controller, $namespace . '\\') === 0) ) { continue; } $map = ''; if (is_string($replacement)) { $map = rtrim($replacement, '/') . '/'; $controller = substr($controller, strlen($namespace) + 1); } $parts = explode('\\', $controller); array_pop($parts); $parts = array_diff($parts, array('Controller')); $parts[] = $this->deriveControllerClass($controller); $controller = implode('/', $parts); $template = trim($map . $controller, '/'); return $this->inflectName($template); } return false; } protected function inflectName($name) { if (!$this->inflector) { $this->inflector = new CamelCaseToDashFilter(); } $name = $this->inflector->filter($name); return strtolower($name); } protected function deriveModuleNamespace($controller) { if (!strstr($controller, '\\')) { return ''; } $module = substr($controller, 0, strpos($controller, '\\')); return $module; } protected function deriveControllerSubNamespace($namespace) { if (!strstr($namespace, '\\')) { return ''; } $nsArray = explode('\\', $namespace); $subNsArray = array_slice($nsArray, 2); if (empty($subNsArray)) { return ''; } return implode('/', $subNsArray); } protected function deriveControllerClass($controller) { if (strstr($controller, '\\')) { $controller = substr($controller, strrpos($controller, '\\') + 1); } if ((10 < strlen($controller)) && ('Controller' == substr($controller, -10)) ) { $controller = substr($controller, 0, -10); } return $controller; } } } namespace Zend\Mvc\View\Http { use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface as Events; use Zend\Mvc\MvcEvent; use Zend\Stdlib\ArrayUtils; use Zend\View\Model\ViewModel; class CreateViewModelListener extends AbstractListenerAggregate { public function attach(Events $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'createViewModelFromArray'), -80); $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'createViewModelFromNull'), -80); } public function createViewModelFromArray(MvcEvent $e) { $result = $e->getResult(); if (!ArrayUtils::hasStringKeys($result, true)) { return; } $model = new ViewModel($result); $e->setResult($model); } public function createViewModelFromNull(MvcEvent $e) { $result = $e->getResult(); if (null !== $result) { return; } $model = new ViewModel; $e->setResult($model); } } } namespace Zend\Mvc\View\Http { use Zend\EventManager\AbstractListenerAggregate; use Zend\EventManager\EventManagerInterface as Events; use Zend\Mvc\MvcEvent; use Zend\View\Model\ClearableModelInterface; use Zend\View\Model\ModelInterface as ViewModel; class InjectViewModelListener extends AbstractListenerAggregate { protected $inflector; public function attach(Events $events) { $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'injectViewModel'), -100); $this->listeners[] = $events->attach(MvcEvent::EVENT_DISPATCH_ERROR, array($this, 'injectViewModel'), -100); $this->listeners[] = $events->attach(MvcEvent::EVENT_RENDER_ERROR, array($this, 'injectViewModel'), -100); } public function injectViewModel(MvcEvent $e) { $result = $e->getResult(); if (!$result instanceof ViewModel) { return; } $model = $e->getViewModel(); if ($result->terminate()) { $e->setViewModel($result); return; } if ($e->getError() && $model instanceof ClearableModelInterface) { $model->clearChildren(); } $model->addChild($result); } } } namespace Zend\Mvc\Service { use Traversable; use Zend\I18n\Translator\Translator; use Zend\Mvc\I18n\DummyTranslator; use Zend\Mvc\I18n\Translator as MvcTranslator; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class TranslatorServiceFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { if ($serviceLocator->has('Zend\I18n\Translator\TranslatorInterface')) { return new MvcTranslator($serviceLocator->get('Zend\I18n\Translator\TranslatorInterface')); } if ($serviceLocator->has('Config')) { $config = $serviceLocator->get('Config'); if (array_key_exists('translator', $config) && $config['translator'] === false) { return new MvcTranslator(new DummyTranslator()); } if (array_key_exists('translator', $config) && ((is_array($config['translator']) && !empty($config['translator'])) || $config['translator'] instanceof Traversable) ) { $i18nTranslator = Translator::factory($config['translator']); $serviceLocator->setService('Zend\I18n\Translator\TranslatorInterface', $i18nTranslator); return new MvcTranslator($i18nTranslator); } } if (!extension_loaded('intl')) { return new MvcTranslator(new DummyTranslator()); } return new MvcTranslator(new Translator()); } } } namespace Zend\I18n\Translator { use Locale; use Traversable; use Zend\Cache; use Zend\Cache\Storage\StorageInterface as CacheStorage; use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerInterface; use Zend\I18n\Exception; use Zend\I18n\Translator\Loader\FileLoaderInterface; use Zend\I18n\Translator\Loader\RemoteLoaderInterface; use Zend\Stdlib\ArrayUtils; class Translator implements TranslatorInterface { const EVENT_MISSING_TRANSLATION = 'missingTranslation'; const EVENT_NO_MESSAGES_LOADED = 'noMessagesLoaded'; protected $messages = array(); protected $files = array(); protected $patterns = array(); protected $remote = array(); protected $locale; protected $fallbackLocale; protected $cache; protected $pluginManager; protected $events; protected $eventsEnabled = false; public static function factory($options) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException(sprintf( '%s expects an array or Traversable object; received "%s"', __METHOD__, (is_object($options) ? get_class($options) : gettype($options)) )); } $translator = new static(); if (isset($options['locale'])) { $locales = (array) $options['locale']; $translator->setLocale(array_shift($locales)); if (count($locales) > 0) { $translator->setFallbackLocale(array_shift($locales)); } } if (isset($options['translation_file_patterns'])) { if (!is_array($options['translation_file_patterns'])) { throw new Exception\InvalidArgumentException( '"translation_file_patterns" should be an array' ); } $requiredKeys = array('type', 'base_dir', 'pattern'); foreach ($options['translation_file_patterns'] as $pattern) { foreach ($requiredKeys as $key) { if (!isset($pattern[$key])) { throw new Exception\InvalidArgumentException( "'{$key}' is missing for translation pattern options" ); } } $translator->addTranslationFilePattern( $pattern['type'], $pattern['base_dir'], $pattern['pattern'], isset($pattern['text_domain']) ? $pattern['text_domain'] : 'default' ); } } if (isset($options['translation_files'])) { if (!is_array($options['translation_files'])) { throw new Exception\InvalidArgumentException( '"translation_files" should be an array' ); } $requiredKeys = array('type', 'filename'); foreach ($options['translation_files'] as $file) { foreach ($requiredKeys as $key) { if (!isset($file[$key])) { throw new Exception\InvalidArgumentException( "'{$key}' is missing for translation file options" ); } } $translator->addTranslationFile( $file['type'], $file['filename'], isset($file['text_domain']) ? $file['text_domain'] : 'default', isset($file['locale']) ? $file['locale'] : null ); } } if (isset($options['remote_translation'])) { if (!is_array($options['remote_translation'])) { throw new Exception\InvalidArgumentException( '"remote_translation" should be an array' ); } $requiredKeys = array('type'); foreach ($options['remote_translation'] as $remote) { foreach ($requiredKeys as $key) { if (!isset($remote[$key])) { throw new Exception\InvalidArgumentException( "'{$key}' is missing for remote translation options" ); } } $translator->addRemoteTranslations( $remote['type'], isset($remote['text_domain']) ? $remote['text_domain'] : 'default' ); } } if (isset($options['cache'])) { if ($options['cache'] instanceof CacheStorage) { $translator->setCache($options['cache']); } else { $translator->setCache(Cache\StorageFactory::factory($options['cache'])); } } if (isset($options['event_manager_enabled']) && $options['event_manager_enabled']) { $translator->enableEventManager(); } return $translator; } public function setLocale($locale) { $this->locale = $locale; return $this; } public function getLocale() { if ($this->locale === null) { if (!extension_loaded('intl')) { throw new Exception\ExtensionNotLoadedException(sprintf( '%s component requires the intl PHP extension', __NAMESPACE__ )); } $this->locale = Locale::getDefault(); } return $this->locale; } public function setFallbackLocale($locale) { $this->fallbackLocale = $locale; return $this; } public function getFallbackLocale() { return $this->fallbackLocale; } public function setCache(CacheStorage $cache = null) { $this->cache = $cache; return $this; } public function getCache() { return $this->cache; } public function setPluginManager(LoaderPluginManager $pluginManager) { $this->pluginManager = $pluginManager; return $this; } public function getPluginManager() { if (!$this->pluginManager instanceof LoaderPluginManager) { $this->setPluginManager(new LoaderPluginManager()); } return $this->pluginManager; } public function translate($message, $textDomain = 'default', $locale = null) { $locale = ($locale ?: $this->getLocale()); $translation = $this->getTranslatedMessage($message, $locale, $textDomain); if ($translation !== null && $translation !== '') { return $translation; } if (null !== ($fallbackLocale = $this->getFallbackLocale()) && $locale !== $fallbackLocale ) { return $this->translate($message, $textDomain, $fallbackLocale); } return $message; } public function translatePlural( $singular, $plural, $number, $textDomain = 'default', $locale = null ) { $locale = $locale ?: $this->getLocale(); $translation = $this->getTranslatedMessage($singular, $locale, $textDomain); if ($translation === null || $translation === '') { if (null !== ($fallbackLocale = $this->getFallbackLocale()) && $locale !== $fallbackLocale ) { return $this->translatePlural( $singular, $plural, $number, $textDomain, $fallbackLocale ); } return ($number == 1 ? $singular : $plural); } $index = $this->messages[$textDomain][$locale] ->getPluralRule() ->evaluate($number); if (!isset($translation[$index])) { throw new Exception\OutOfBoundsException(sprintf( 'Provided index %d does not exist in plural array', $index )); } return $translation[$index]; } protected function getTranslatedMessage( $message, $locale, $textDomain = 'default' ) { if ($message === '') { return ''; } if (!isset($this->messages[$textDomain][$locale])) { $this->loadMessages($textDomain, $locale); } if (isset($this->messages[$textDomain][$locale][$message])) { return $this->messages[$textDomain][$locale][$message]; } if ($this->isEventManagerEnabled()) { $results = $this->getEventManager()->trigger( self::EVENT_MISSING_TRANSLATION, $this, array( 'message' => $message, 'locale' => $locale, 'text_domain' => $textDomain, ), function ($r) { return is_string($r); } ); $last = $results->last(); if (is_string($last)) { return $last; } } return null; } public function addTranslationFile( $type, $filename, $textDomain = 'default', $locale = null ) { $locale = $locale ?: '*'; if (!isset($this->files[$textDomain])) { $this->files[$textDomain] = array(); } $this->files[$textDomain][$locale][] = array( 'type' => $type, 'filename' => $filename, ); return $this; } public function addTranslationFilePattern( $type, $baseDir, $pattern, $textDomain = 'default' ) { if (!isset($this->patterns[$textDomain])) { $this->patterns[$textDomain] = array(); } $this->patterns[$textDomain][] = array( 'type' => $type, 'baseDir' => rtrim($baseDir, '/'), 'pattern' => $pattern, ); return $this; } public function addRemoteTranslations($type, $textDomain = 'default') { if (!isset($this->remote[$textDomain])) { $this->remote[$textDomain] = array(); } $this->remote[$textDomain][] = $type; return $this; } protected function loadMessages($textDomain, $locale) { if (!isset($this->messages[$textDomain])) { $this->messages[$textDomain] = array(); } if (null !== ($cache = $this->getCache())) { $cacheId = 'Zend_I18n_Translator_Messages_' . md5($textDomain . $locale); if (null !== ($result = $cache->getItem($cacheId))) { $this->messages[$textDomain][$locale] = $result; return; } } $messagesLoaded = false; $messagesLoaded |= $this->loadMessagesFromRemote($textDomain, $locale); $messagesLoaded |= $this->loadMessagesFromPatterns($textDomain, $locale); $messagesLoaded |= $this->loadMessagesFromFiles($textDomain, $locale); if (!$messagesLoaded) { $discoveredTextDomain = null; if ($this->isEventManagerEnabled()) { $results = $this->getEventManager()->trigger( self::EVENT_NO_MESSAGES_LOADED, $this, array( 'locale' => $locale, 'text_domain' => $textDomain, ), function ($r) { return ($r instanceof TextDomain); } ); $last = $results->last(); if ($last instanceof TextDomain) { $discoveredTextDomain = $last; } } $this->messages[$textDomain][$locale] = $discoveredTextDomain; $messagesLoaded = true; } if ($messagesLoaded && $cache !== null) { $cache->setItem($cacheId, $this->messages[$textDomain][$locale]); } } protected function loadMessagesFromRemote($textDomain, $locale) { $messagesLoaded = false; if (isset($this->remote[$textDomain])) { foreach ($this->remote[$textDomain] as $loaderType) { $loader = $this->getPluginManager()->get($loaderType); if (!$loader instanceof RemoteLoaderInterface) { throw new Exception\RuntimeException('Specified loader is not a remote loader'); } if (isset($this->messages[$textDomain][$locale])) { $this->messages[$textDomain][$locale]->merge($loader->load($locale, $textDomain)); } else { $this->messages[$textDomain][$locale] = $loader->load($locale, $textDomain); } $messagesLoaded = true; } } return $messagesLoaded; } protected function loadMessagesFromPatterns($textDomain, $locale) { $messagesLoaded = false; if (isset($this->patterns[$textDomain])) { foreach ($this->patterns[$textDomain] as $pattern) { $filename = $pattern['baseDir'] . '/' . sprintf($pattern['pattern'], $locale); if (is_file($filename)) { $loader = $this->getPluginManager()->get($pattern['type']); if (!$loader instanceof FileLoaderInterface) { throw new Exception\RuntimeException('Specified loader is not a file loader'); } if (isset($this->messages[$textDomain][$locale])) { $this->messages[$textDomain][$locale]->merge($loader->load($locale, $filename)); } else { $this->messages[$textDomain][$locale] = $loader->load($locale, $filename); } $messagesLoaded = true; } } } return $messagesLoaded; } protected function loadMessagesFromFiles($textDomain, $locale) { $messagesLoaded = false; foreach (array($locale, '*') as $currentLocale) { if (!isset($this->files[$textDomain][$currentLocale])) { continue; } foreach ($this->files[$textDomain][$currentLocale] as $file) { $loader = $this->getPluginManager()->get($file['type']); if (!$loader instanceof FileLoaderInterface) { throw new Exception\RuntimeException('Specified loader is not a file loader'); } if (isset($this->messages[$textDomain][$locale])) { $this->messages[$textDomain][$locale]->merge($loader->load($locale, $file['filename'])); } else { $this->messages[$textDomain][$locale] = $loader->load($locale, $file['filename']); } $messagesLoaded = true; } unset($this->files[$textDomain][$currentLocale]); } return $messagesLoaded; } public function getEventManager() { if (!$this->events instanceof EventManagerInterface) { $this->setEventManager(new EventManager()); } return $this->events; } public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers(array( __CLASS__, get_class($this), 'translator', )); $this->events = $events; return $this; } public function isEventManagerEnabled() { return $this->eventsEnabled; } public function enableEventManager() { $this->eventsEnabled = true; return $this; } public function disableEventManager() { $this->eventsEnabled = false; return $this; } } } namespace Zend\Mvc\I18n { use Zend\I18n\Translator\TranslatorInterface as I18nTranslatorInterface; use Zend\Mvc\Exception; use Zend\Validator\Translator\TranslatorInterface as ValidatorTranslatorInterface; class Translator implements I18nTranslatorInterface, ValidatorTranslatorInterface { protected $translator; public function __construct(I18nTranslatorInterface $translator) { $this->translator = $translator; } public function __call($method, array $args) { if (!method_exists($this->translator, $method)) { throw new Exception\BadMethodCallException(sprintf( 'Unable to call method "%s"; does not exist in translator', $method )); } return call_user_func_array(array($this->translator, $method), $args); } public function getTranslator() { return $this->translator; } public function translate($message, $textDomain = 'default', $locale = null) { return $this->translator->translate($message, $textDomain, $locale); } public function translatePlural($singular, $plural, $number, $textDomain = 'default', $locale = null) { return $this->translator->translatePlural($singular, $plural, $number, $textDomain, $locale); } } } namespace Zend\Mvc\Router { class RouteMatch { protected $params = array(); protected $matchedRouteName; public function __construct(array $params) { $this->params = $params; } public function setMatchedRouteName($name) { $this->matchedRouteName = $name; return $this; } public function getMatchedRouteName() { return $this->matchedRouteName; } public function setParam($name, $value) { $this->params[$name] = $value; return $this; } public function getParams() { return $this->params; } public function getParam($name, $default = null) { if (array_key_exists($name, $this->params)) { return $this->params[$name]; } return $default; } } } namespace Zend\Mvc\Router\Http { use Zend\Mvc\Router\RouteMatch as BaseRouteMatch; class RouteMatch extends BaseRouteMatch { protected $length; public function __construct(array $params, $length = 0) { parent::__construct($params); $this->length = $length; } public function setMatchedRouteName($name) { if ($this->matchedRouteName === null) { $this->matchedRouteName = $name; } else { $this->matchedRouteName = $name . '/' . $this->matchedRouteName; } return $this; } public function merge(RouteMatch $match) { $this->params = array_merge($this->params, $match->getParams()); $this->length += $match->getLength(); $this->matchedRouteName = $match->getMatchedRouteName(); return $this; } public function getLength() { return $this->length; } } } namespace Zend\Mvc\Controller { use Zend\EventManager\EventInterface as Event; use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\Http\PhpEnvironment\Response as HttpResponse; use Zend\Http\Request as HttpRequest; use Zend\Mvc\InjectApplicationEventInterface; use Zend\Mvc\MvcEvent; use Zend\ServiceManager\ServiceLocatorAwareInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\Stdlib\DispatchableInterface as Dispatchable; use Zend\Stdlib\RequestInterface as Request; use Zend\Stdlib\ResponseInterface as Response; abstract class AbstractController implements Dispatchable, EventManagerAwareInterface, InjectApplicationEventInterface, ServiceLocatorAwareInterface { protected $plugins; protected $request; protected $response; protected $event; protected $events; protected $serviceLocator; protected $eventIdentifier; abstract public function onDispatch(MvcEvent $e); public function dispatch(Request $request, Response $response = null) { $this->request = $request; if (!$response) { $response = new HttpResponse(); } $this->response = $response; $e = $this->getEvent(); $e->setRequest($request) ->setResponse($response) ->setTarget($this); $result = $this->getEventManager()->trigger(MvcEvent::EVENT_DISPATCH, $e, function ($test) { return ($test instanceof Response); }); if ($result->stopped()) { return $result->last(); } return $e->getResult(); } public function getRequest() { if (!$this->request) { $this->request = new HttpRequest(); } return $this->request; } public function getResponse() { if (!$this->response) { $this->response = new HttpResponse(); } return $this->response; } public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers(array( 'Zend\Stdlib\DispatchableInterface', __CLASS__, get_class($this), $this->eventIdentifier, substr(get_class($this), 0, strpos(get_class($this), '\\')) )); $this->events = $events; $this->attachDefaultListeners(); return $this; } public function getEventManager() { if (!$this->events) { $this->setEventManager(new EventManager()); } return $this->events; } public function setEvent(Event $e) { if (!$e instanceof MvcEvent) { $eventParams = $e->getParams(); $e = new MvcEvent(); $e->setParams($eventParams); unset($eventParams); } $this->event = $e; } public function getEvent() { if (!$this->event) { $this->setEvent(new MvcEvent()); } return $this->event; } public function setServiceLocator(ServiceLocatorInterface $serviceLocator) { $this->serviceLocator = $serviceLocator; } public function getServiceLocator() { return $this->serviceLocator; } public function getPluginManager() { if (!$this->plugins) { $this->setPluginManager(new PluginManager()); } $this->plugins->setController($this); return $this->plugins; } public function setPluginManager(PluginManager $plugins) { $this->plugins = $plugins; $this->plugins->setController($this); return $this; } public function plugin($name, array $options = null) { return $this->getPluginManager()->get($name, $options); } public function __call($method, $params) { $plugin = $this->plugin($method); if (is_callable($plugin)) { return call_user_func_array($plugin, $params); } return $plugin; } protected function attachDefaultListeners() { $events = $this->getEventManager(); $events->attach(MvcEvent::EVENT_DISPATCH, array($this, 'onDispatch')); } public static function getMethodFromAction($action) { $method = str_replace(array('.', '-', '_'), ' ', $action); $method = ucwords($method); $method = str_replace(' ', '', $method); $method = lcfirst($method); $method .= 'Action'; return $method; } } } namespace Zend\Mvc\Controller { use Zend\Http\Response as HttpResponse; use Zend\Mvc\Exception; use Zend\Mvc\MvcEvent; use Zend\View\Model\ConsoleModel; use Zend\View\Model\ViewModel; abstract class AbstractActionController extends AbstractController { protected $eventIdentifier = __CLASS__; public function indexAction() { return new ViewModel(array( 'content' => 'Placeholder page' )); } public function notFoundAction() { $response = $this->response; $event = $this->getEvent(); $routeMatch = $event->getRouteMatch(); $routeMatch->setParam('action', 'not-found'); if ($response instanceof HttpResponse) { return $this->createHttpNotFoundModel($response); } return $this->createConsoleNotFoundModel($response); } public function onDispatch(MvcEvent $e) { $routeMatch = $e->getRouteMatch(); if (!$routeMatch) { throw new Exception\DomainException('Missing route matches; unsure how to retrieve action'); } $action = $routeMatch->getParam('action', 'not-found'); $method = static::getMethodFromAction($action); if (!method_exists($this, $method)) { $method = 'notFoundAction'; } $actionResponse = $this->$method(); $e->setResult($actionResponse); return $actionResponse; } protected function createHttpNotFoundModel(HttpResponse $response) { $response->setStatusCode(404); return new ViewModel(array( 'content' => 'Page not found', )); } protected function createConsoleNotFoundModel($response) { $viewModel = new ConsoleModel(); $viewModel->setErrorLevel(1); $viewModel->setResult('Page not found'); return $viewModel; } } } namespace Zend\Db\Adapter { use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; class AdapterServiceFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $serviceLocator) { $config = $serviceLocator->get('Config'); return new Adapter($config['db']); } } } namespace Zend\Db\Adapter { use Zend\Db\ResultSet; class Adapter implements AdapterInterface, Profiler\ProfilerAwareInterface { const QUERY_MODE_EXECUTE = 'execute'; const QUERY_MODE_PREPARE = 'prepare'; const PREPARE_TYPE_POSITIONAL = 'positional'; const PREPARE_TYPE_NAMED = 'named'; const FUNCTION_FORMAT_PARAMETER_NAME = 'formatParameterName'; const FUNCTION_QUOTE_IDENTIFIER = 'quoteIdentifier'; const FUNCTION_QUOTE_VALUE = 'quoteValue'; const VALUE_QUOTE_SEPARATOR = 'quoteSeparator'; protected $driver = null; protected $platform = null; protected $profiler = null; protected $queryResultSetPrototype = null; protected $lastPreparedStatement = null; public function __construct($driver, Platform\PlatformInterface $platform = null, ResultSet\ResultSetInterface $queryResultPrototype = null, Profiler\ProfilerInterface $profiler = null) { $parameters = array(); if (is_array($driver)) { $parameters = $driver; if ($profiler === null && isset($parameters['profiler'])) { $profiler = $this->createProfiler($parameters); } $driver = $this->createDriver($parameters); } elseif (!$driver instanceof Driver\DriverInterface) { throw new Exception\InvalidArgumentException( 'The supplied or instantiated driver object does not implement Zend\Db\Adapter\Driver\DriverInterface' ); } $driver->checkEnvironment(); $this->driver = $driver; if ($platform == null) { $platform = $this->createPlatform($parameters); } $this->platform = $platform; $this->queryResultSetPrototype = ($queryResultPrototype) ?: new ResultSet\ResultSet(); if ($profiler) { $this->setProfiler($profiler); } } public function setProfiler(Profiler\ProfilerInterface $profiler) { $this->profiler = $profiler; if ($this->driver instanceof Profiler\ProfilerAwareInterface) { $this->driver->setProfiler($profiler); } return $this; } public function getProfiler() { return $this->profiler; } public function getDriver() { if ($this->driver == null) { throw new Exception\RuntimeException('Driver has not been set or configured for this adapter.'); } return $this->driver; } public function getPlatform() { return $this->platform; } public function getQueryResultSetPrototype() { return $this->queryResultSetPrototype; } public function getCurrentSchema() { return $this->driver->getConnection()->getCurrentSchema(); } public function query($sql, $parametersOrQueryMode = self::QUERY_MODE_PREPARE, ResultSet\ResultSetInterface $resultPrototype = null) { if (is_string($parametersOrQueryMode) && in_array($parametersOrQueryMode, array(self::QUERY_MODE_PREPARE, self::QUERY_MODE_EXECUTE))) { $mode = $parametersOrQueryMode; $parameters = null; } elseif (is_array($parametersOrQueryMode) || $parametersOrQueryMode instanceof ParameterContainer) { $mode = self::QUERY_MODE_PREPARE; $parameters = $parametersOrQueryMode; } else { throw new Exception\InvalidArgumentException('Parameter 2 to this method must be a flag, an array, or ParameterContainer'); } if ($mode == self::QUERY_MODE_PREPARE) { $this->lastPreparedStatement = null; $this->lastPreparedStatement = $this->driver->createStatement($sql); $this->lastPreparedStatement->prepare(); if (is_array($parameters) || $parameters instanceof ParameterContainer) { $this->lastPreparedStatement->setParameterContainer((is_array($parameters)) ? new ParameterContainer($parameters) : $parameters); $result = $this->lastPreparedStatement->execute(); } else { return $this->lastPreparedStatement; } } else { $result = $this->driver->getConnection()->execute($sql); } if ($result instanceof Driver\ResultInterface && $result->isQueryResult()) { $resultSet = clone ($resultPrototype ?: $this->queryResultSetPrototype); $resultSet->initialize($result); return $resultSet; } return $result; } public function createStatement($initialSql = null, $initialParameters = null) { $statement = $this->driver->createStatement($initialSql); if ($initialParameters == null || !$initialParameters instanceof ParameterContainer && is_array($initialParameters)) { $initialParameters = new ParameterContainer((is_array($initialParameters) ? $initialParameters : array())); } $statement->setParameterContainer($initialParameters); return $statement; } public function getHelpers() { $functions = array(); $platform = $this->platform; foreach (func_get_args() as $arg) { switch ($arg) { case self::FUNCTION_QUOTE_IDENTIFIER: $functions[] = function ($value) use ($platform) { return $platform->quoteIdentifier($value); }; break; case self::FUNCTION_QUOTE_VALUE: $functions[] = function ($value) use ($platform) { return $platform->quoteValue($value); }; break; } } } public function __get($name) { switch (strtolower($name)) { case 'driver': return $this->driver; case 'platform': return $this->platform; default: throw new Exception\InvalidArgumentException('Invalid magic property on adapter'); } } protected function createDriver($parameters) { if (!isset($parameters['driver'])) { throw new Exception\InvalidArgumentException(__FUNCTION__ . ' expects a "driver" key to be present inside the parameters'); } if ($parameters['driver'] instanceof Driver\DriverInterface) { return $parameters['driver']; } if (!is_string($parameters['driver'])) { throw new Exception\InvalidArgumentException(__FUNCTION__ . ' expects a "driver" to be a string or instance of DriverInterface'); } $options = array(); if (isset($parameters['options'])) { $options = (array) $parameters['options']; unset($parameters['options']); } $driverName = strtolower($parameters['driver']); switch ($driverName) { case 'mysqli': $driver = new Driver\Mysqli\Mysqli($parameters, null, null, $options); break; case 'sqlsrv': $driver = new Driver\Sqlsrv\Sqlsrv($parameters); break; case 'oci8': $driver = new Driver\Oci8\Oci8($parameters); break; case 'pgsql': $driver = new Driver\Pgsql\Pgsql($parameters); break; case 'ibmdb2': $driver = new Driver\IbmDb2\IbmDb2($parameters); break; case 'pdo': default: if ($driverName == 'pdo' || strpos($driverName, 'pdo') === 0) { $driver = new Driver\Pdo\Pdo($parameters); } } if (!isset($driver) || !$driver instanceof Driver\DriverInterface) { throw new Exception\InvalidArgumentException('DriverInterface expected', null, null); } return $driver; } protected function createPlatform($parameters) { if (isset($parameters['platform'])) { $platformName = $parameters['platform']; } elseif ($this->driver instanceof Driver\DriverInterface) { $platformName = $this->driver->getDatabasePlatformName(Driver\DriverInterface::NAME_FORMAT_CAMELCASE); } else { throw new Exception\InvalidArgumentException('A platform could not be determined from the provided configuration'); } $options = (isset($parameters['platform_options'])) ? $parameters['platform_options'] : array(); switch ($platformName) { case 'Mysql': $driver = ($this->driver instanceof Driver\Mysqli\Mysqli || $this->driver instanceof Driver\Pdo\Pdo) ? $this->driver : null; return new Platform\Mysql($driver); case 'SqlServer': return new Platform\SqlServer(($this->driver instanceof Driver\Pdo\Pdo) ? $this->driver : null); case 'Oracle': return new Platform\Oracle($options); case 'Sqlite': return new Platform\Sqlite(($this->driver instanceof Driver\Pdo\Pdo) ? $this->driver : null); case 'Postgresql': $driver = ($this->driver instanceof Driver\Pgsql\Pgsql || $this->driver instanceof Driver\Pdo\Pdo) ? $this->driver : null; return new Platform\Postgresql($driver); case 'IbmDb2': return new Platform\IbmDb2($options); default: return new Platform\Sql92(); } } protected function createProfiler($parameters) { if ($parameters['profiler'] instanceof Profiler\ProfilerInterface) { $profiler = $parameters['profiler']; } elseif (is_bool($parameters['profiler'])) { $profiler = ($parameters['profiler'] == true) ? new Profiler\Profiler : null; } else { throw new Exception\InvalidArgumentException( '"profiler" parameter must be an instance of ProfilerInterface or a boolean' ); } return $profiler; } protected function createDriverFromParameters(array $parameters) { return $this->createDriver($parameters); } protected function createPlatformFromDriver(Driver\DriverInterface $driver) { return $this->createPlatform($driver); } } } namespace Zend\Db\Adapter\Driver\Pdo { use PDOStatement; use Zend\Db\Adapter\Driver\DriverInterface; use Zend\Db\Adapter\Driver\Feature\AbstractFeature; use Zend\Db\Adapter\Driver\Feature\DriverFeatureInterface; use Zend\Db\Adapter\Exception; use Zend\Db\Adapter\Profiler; class Pdo implements DriverInterface, DriverFeatureInterface, \Zend\Db\Adapter\Profiler\ProfilerAwareInterface { const FEATURES_DEFAULT = 'default'; protected $connection = null; protected $statementPrototype = null; protected $resultPrototype = null; protected $features = array(); public function __construct($connection, Statement $statementPrototype = null, Result $resultPrototype = null, $features = self::FEATURES_DEFAULT) { if (!$connection instanceof Connection) { $connection = new Connection($connection); } $this->registerConnection($connection); $this->registerStatementPrototype(($statementPrototype) ?: new Statement()); $this->registerResultPrototype(($resultPrototype) ?: new Result()); if (is_array($features)) { foreach ($features as $name => $feature) { $this->addFeature($name, $feature); } } elseif ($features instanceof AbstractFeature) { $this->addFeature($features->getName(), $features); } elseif ($features === self::FEATURES_DEFAULT) { $this->setupDefaultFeatures(); } } public function setProfiler(Profiler\ProfilerInterface $profiler) { $this->profiler = $profiler; if ($this->connection instanceof Profiler\ProfilerAwareInterface) { $this->connection->setProfiler($profiler); } if ($this->statementPrototype instanceof Profiler\ProfilerAwareInterface) { $this->statementPrototype->setProfiler($profiler); } return $this; } public function getProfiler() { return $this->profiler; } public function registerConnection(Connection $connection) { $this->connection = $connection; $this->connection->setDriver($this); return $this; } public function registerStatementPrototype(Statement $statementPrototype) { $this->statementPrototype = $statementPrototype; $this->statementPrototype->setDriver($this); } public function registerResultPrototype(Result $resultPrototype) { $this->resultPrototype = $resultPrototype; } public function addFeature($name, $feature) { if ($feature instanceof AbstractFeature) { $name = $feature->getName(); $feature->setDriver($this); } $this->features[$name] = $feature; return $this; } public function setupDefaultFeatures() { $driverName = $this->connection->getDriverName(); if ($driverName == 'sqlite') { $this->addFeature(null, new Feature\SqliteRowCounter); } elseif ($driverName == 'oci') { $this->addFeature(null, new Feature\OracleRowCounter); } return $this; } public function getFeature($name) { if (isset($this->features[$name])) { return $this->features[$name]; } return false; } public function getDatabasePlatformName($nameFormat = self::NAME_FORMAT_CAMELCASE) { $name = $this->getConnection()->getDriverName(); if ($nameFormat == self::NAME_FORMAT_CAMELCASE) { switch ($name) { case 'pgsql': return 'Postgresql'; case 'oci': return 'Oracle'; case 'dblib': case 'sqlsrv': return 'SqlServer'; default: return ucfirst($name); } } else { switch ($name) { case 'sqlite': return 'SQLite'; case 'mysql': return 'MySQL'; case 'pgsql': return 'PostgreSQL'; case 'oci': return 'Oracle'; case 'dblib': case 'sqlsrv': return 'SQLServer'; default: return ucfirst($name); } } } public function checkEnvironment() { if (!extension_loaded('PDO')) { throw new Exception\RuntimeException('The PDO extension is required for this adapter but the extension is not loaded'); } } public function getConnection() { return $this->connection; } public function createStatement($sqlOrResource = null) { $statement = clone $this->statementPrototype; if ($sqlOrResource instanceof PDOStatement) { $statement->setResource($sqlOrResource); } else { if (is_string($sqlOrResource)) { $statement->setSql($sqlOrResource); } if (!$this->connection->isConnected()) { $this->connection->connect(); } $statement->initialize($this->connection->getResource()); } return $statement; } public function createResult($resource, $context = null) { $result = clone $this->resultPrototype; $rowCount = null; if ($this->connection->getDriverName() == 'sqlite' && ($sqliteRowCounter = $this->getFeature('SqliteRowCounter')) && $resource->columnCount() > 0) { $rowCount = $sqliteRowCounter->getRowCountClosure($context); } if ($this->connection->getDriverName() == 'oci' && ($oracleRowCounter = $this->getFeature('OracleRowCounter')) && $resource->columnCount() > 0) { $rowCount = $oracleRowCounter->getRowCountClosure($context); } $result->initialize($resource, $this->connection->getLastGeneratedValue(), $rowCount); return $result; } public function getPrepareType() { return self::PARAMETERIZATION_NAMED; } public function formatParameterName($name, $type = null) { if ($type == null && !is_numeric($name) || $type == self::PARAMETERIZATION_NAMED) { return ':' . $name; } return '?'; } public function getLastGeneratedValue($name = null) { return $this->connection->getLastGeneratedValue($name); } } } namespace Zend\Db\Adapter\Driver\Pdo { use Zend\Db\Adapter\Driver\ConnectionInterface; use Zend\Db\Adapter\Exception; use Zend\Db\Adapter\Profiler; class Connection implements ConnectionInterface, \Zend\Db\Adapter\Profiler\ProfilerAwareInterface { protected $driver = null; protected $profiler = null; protected $driverName = null; protected $connectionParameters = array(); protected $resource = null; protected $inTransaction = false; protected $dsn = null; public function __construct($connectionParameters = null) { if (is_array($connectionParameters)) { $this->setConnectionParameters($connectionParameters); } elseif ($connectionParameters instanceof \PDO) { $this->setResource($connectionParameters); } elseif (null !== $connectionParameters) { throw new Exception\InvalidArgumentException('$connection must be an array of parameters, a PDO object or null'); } } public function setDriver(Pdo $driver) { $this->driver = $driver; return $this; } public function setProfiler(Profiler\ProfilerInterface $profiler) { $this->profiler = $profiler; return $this; } public function getProfiler() { return $this->profiler; } public function getDriverName() { return $this->driverName; } public function setConnectionParameters(array $connectionParameters) { $this->connectionParameters = $connectionParameters; if (isset($connectionParameters['dsn'])) { $this->driverName = substr($connectionParameters['dsn'], 0, strpos($connectionParameters['dsn'], ':') ); } elseif (isset($connectionParameters['pdodriver'])) { $this->driverName = strtolower($connectionParameters['pdodriver']); } elseif (isset($connectionParameters['driver'])) { $this->driverName = strtolower(substr( str_replace(array('-', '_', ' '), '', $connectionParameters['driver']), 3 )); } } public function getConnectionParameters() { return $this->connectionParameters; } public function getDsn() { if (!$this->dsn) { throw new Exception\RunTimeException("The DSN has not been set or constructed from parameters in connect() for this Connection"); } return $this->dsn; } public function getCurrentSchema() { if (!$this->isConnected()) { $this->connect(); } switch ($this->driverName) { case 'mysql': $sql = 'SELECT DATABASE()'; break; case 'sqlite': return 'main'; case 'sqlsrv': case 'dblib': $sql = 'SELECT SCHEMA_NAME()'; break; case 'pgsql': default: $sql = 'SELECT CURRENT_SCHEMA'; break; } $result = $this->resource->query($sql); if ($result instanceof \PDOStatement) { return $result->fetchColumn(); } return false; } public function setResource(\PDO $resource) { $this->resource = $resource; $this->driverName = strtolower($this->resource->getAttribute(\PDO::ATTR_DRIVER_NAME)); return $this; } public function getResource() { if (!$this->isConnected()) { $this->connect(); } return $this->resource; } public function connect() { if ($this->resource) { return $this; } $dsn = $username = $password = $hostname = $database = null; $options = array(); foreach ($this->connectionParameters as $key => $value) { switch (strtolower($key)) { case 'dsn': $dsn = $value; break; case 'driver': $value = strtolower($value); if (strpos($value, 'pdo') === 0) { $pdoDriver = strtolower(substr(str_replace(array('-', '_', ' '), '', $value), 3)); } break; case 'pdodriver': $pdoDriver = (string) $value; break; case 'user': case 'username': $username = (string) $value; break; case 'pass': case 'password': $password = (string) $value; break; case 'host': case 'hostname': $hostname = (string) $value; break; case 'port': $port = (int) $value; break; case 'database': case 'dbname': $database = (string) $value; break; case 'charset': $charset = (string) $value; break; case 'driver_options': case 'options': $value = (array) $value; $options = array_diff_key($options, $value) + $value; break; default: $options[$key] = $value; break; } } if (!isset($dsn) && isset($pdoDriver)) { $dsn = array(); switch ($pdoDriver) { case 'sqlite': $dsn[] = $database; break; case 'sqlsrv': if (isset($database)) { $dsn[] = "database={$database}"; } if (isset($hostname)) { $dsn[] = "server={$hostname}"; } break; default: if (isset($database)) { $dsn[] = "dbname={$database}"; } if (isset($hostname)) { $dsn[] = "host={$hostname}"; } if (isset($port)) { $dsn[] = "port={$port}"; } if (isset($charset) && $pdoDriver != 'pgsql') { $dsn[] = "charset={$charset}"; } break; } $dsn = $pdoDriver . ':' . implode(';', $dsn); } elseif (!isset($dsn)) { throw new Exception\InvalidConnectionParametersException( 'A dsn was not provided or could not be constructed from your parameters', $this->connectionParameters ); } $this->dsn = $dsn; try { $this->resource = new \PDO($dsn, $username, $password, $options); $this->resource->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION); if (isset($charset) && $pdoDriver == 'pgsql') { $this->resource->exec('SET NAMES ' . $this->resource->quote($charset)); } $this->driverName = strtolower($this->resource->getAttribute(\PDO::ATTR_DRIVER_NAME)); } catch (\PDOException $e) { $code = $e->getCode(); if (!is_long($code)) { $code = null; } throw new Exception\RuntimeException('Connect Error: ' . $e->getMessage(), $code, $e); } return $this; } public function isConnected() { return ($this->resource instanceof \PDO); } public function disconnect() { if ($this->isConnected()) { $this->resource = null; } return $this; } public function beginTransaction() { if (!$this->isConnected()) { $this->connect(); } $this->resource->beginTransaction(); $this->inTransaction = true; return $this; } public function inTransaction() { return $this->inTransaction; } public function commit() { if (!$this->isConnected()) { $this->connect(); } $this->resource->commit(); $this->inTransaction = false; return $this; } public function rollback() { if (!$this->isConnected()) { throw new Exception\RuntimeException('Must be connected before you can rollback'); } if (!$this->inTransaction) { throw new Exception\RuntimeException('Must call beginTransaction() before you can rollback'); } $this->resource->rollBack(); return $this; } public function execute($sql) { if (!$this->isConnected()) { $this->connect(); } if ($this->profiler) { $this->profiler->profilerStart($sql); } $resultResource = $this->resource->query($sql); if ($this->profiler) { $this->profiler->profilerFinish($sql); } if ($resultResource === false) { $errorInfo = $this->resource->errorInfo(); throw new Exception\InvalidQueryException($errorInfo[2]); } $result = $this->driver->createResult($resultResource, $sql); return $result; } public function prepare($sql) { if (!$this->isConnected()) { $this->connect(); } $statement = $this->driver->createStatement($sql); return $statement; } public function getLastGeneratedValue($name = null) { if ($name === null && $this->driverName == 'pgsql') { return null; } try { return $this->resource->lastInsertId($name); } catch (\Exception $e) { } return false; } } } namespace Zend\Db\Adapter\Driver\Pdo { use Zend\Db\Adapter\Driver\StatementInterface; use Zend\Db\Adapter\Exception; use Zend\Db\Adapter\ParameterContainer; use Zend\Db\Adapter\Profiler; class Statement implements StatementInterface, \Zend\Db\Adapter\Profiler\ProfilerAwareInterface { protected $pdo = null; protected $profiler = null; protected $driver = null; protected $sql = ''; protected $isQuery = null; protected $parameterContainer = null; protected $parametersBound = false; protected $resource = null; protected $isPrepared = false; public function setDriver(Pdo $driver) { $this->driver = $driver; return $this; } public function setProfiler(Profiler\ProfilerInterface $profiler) { $this->profiler = $profiler; return $this; } public function getProfiler() { return $this->profiler; } public function initialize(\PDO $connectionResource) { $this->pdo = $connectionResource; return $this; } public function setResource(\PDOStatement $pdoStatement) { $this->resource = $pdoStatement; return $this; } public function getResource() { return $this->resource; } public function setSql($sql) { $this->sql = $sql; return $this; } public function getSql() { return $this->sql; } public function setParameterContainer(ParameterContainer $parameterContainer) { $this->parameterContainer = $parameterContainer; return $this; } public function getParameterContainer() { return $this->parameterContainer; } public function prepare($sql = null) { if ($this->isPrepared) { throw new Exception\RuntimeException('This statement has been prepared already'); } if ($sql == null) { $sql = $this->sql; } $this->resource = $this->pdo->prepare($sql); if ($this->resource === false) { $error = $this->pdo->errorInfo(); throw new Exception\RuntimeException($error[2]); } $this->isPrepared = true; } public function isPrepared() { return $this->isPrepared; } public function execute($parameters = null) { if (!$this->isPrepared) { $this->prepare(); } if (!$this->parameterContainer instanceof ParameterContainer) { if ($parameters instanceof ParameterContainer) { $this->parameterContainer = $parameters; $parameters = null; } else { $this->parameterContainer = new ParameterContainer(); } } if (is_array($parameters)) { $this->parameterContainer->setFromArray($parameters); } if ($this->parameterContainer->count() > 0) { $this->bindParametersFromContainer(); } if ($this->profiler) { $this->profiler->profilerStart($this); } try { $this->resource->execute(); } catch (\PDOException $e) { if ($this->profiler) { $this->profiler->profilerFinish(); } throw new Exception\InvalidQueryException( 'Statement could not be executed (' . implode(' - ', $this->resource->errorInfo()) . ')', null, $e ); } if ($this->profiler) { $this->profiler->profilerFinish(); } $result = $this->driver->createResult($this->resource, $this); return $result; } protected function bindParametersFromContainer() { if ($this->parametersBound) { return; } $parameters = $this->parameterContainer->getNamedArray(); foreach ($parameters as $name => &$value) { if (is_bool($value)) { $type = \PDO::PARAM_BOOL; } elseif (is_int($value)) { $type = \PDO::PARAM_INT; } else { $type = \PDO::PARAM_STR; } if ($this->parameterContainer->offsetHasErrata($name)) { switch ($this->parameterContainer->offsetGetErrata($name)) { case ParameterContainer::TYPE_INTEGER: $type = \PDO::PARAM_INT; break; case ParameterContainer::TYPE_NULL: $type = \PDO::PARAM_NULL; break; case ParameterContainer::TYPE_LOB: $type = \PDO::PARAM_LOB; break; } } $parameter = is_int($name) ? ($name + 1) : $name; $this->resource->bindParam($parameter, $value, $type); } } public function __clone() { $this->isPrepared = false; $this->parametersBound = false; $this->resource = null; if ($this->parameterContainer) { $this->parameterContainer = clone $this->parameterContainer; } } } } namespace Zend\Db\Adapter\Driver\Pdo { use Iterator; use PDOStatement; use Zend\Db\Adapter\Driver\ResultInterface; use Zend\Db\Adapter\Exception; class Result implements ResultInterface { const STATEMENT_MODE_SCROLLABLE = 'scrollable'; const STATEMENT_MODE_FORWARD = 'forward'; protected $statementMode = self::STATEMENT_MODE_FORWARD; protected $resource = null; protected $options; protected $currentComplete = false; protected $currentData = null; protected $position = -1; protected $generatedValue = null; protected $rowCount = null; public function initialize(PDOStatement $resource, $generatedValue, $rowCount = null) { $this->resource = $resource; $this->generatedValue = $generatedValue; $this->rowCount = $rowCount; return $this; } public function buffer() { return null; } public function isBuffered() { return false; } public function getResource() { return $this->resource; } public function current() { if ($this->currentComplete) { return $this->currentData; } $this->currentData = $this->resource->fetch(\PDO::FETCH_ASSOC); $this->currentComplete = true; return $this->currentData; } public function next() { $this->currentData = $this->resource->fetch(\PDO::FETCH_ASSOC); $this->currentComplete = true; $this->position++; return $this->currentData; } public function key() { return $this->position; } public function rewind() { if ($this->statementMode == self::STATEMENT_MODE_FORWARD && $this->position > 0) { throw new Exception\RuntimeException( 'This result is a forward only result set, calling rewind() after moving forward is not supported' ); } $this->currentData = $this->resource->fetch(\PDO::FETCH_ASSOC); $this->currentComplete = true; $this->position = 0; } public function valid() { return ($this->currentData !== false); } public function count() { if (is_int($this->rowCount)) { return $this->rowCount; } if ($this->rowCount instanceof \Closure) { $this->rowCount = (int) call_user_func($this->rowCount); } else { $this->rowCount = (int) $this->resource->rowCount(); } return $this->rowCount; } public function getFieldCount() { return $this->resource->columnCount(); } public function isQueryResult() { return ($this->resource->columnCount() > 0); } public function getAffectedRows() { return $this->resource->rowCount(); } public function getGeneratedValue() { return $this->generatedValue; } } } namespace Zend\Db\Adapter\Platform { use Zend\Db\Adapter\Driver\DriverInterface; use Zend\Db\Adapter\Driver\Mysqli; use Zend\Db\Adapter\Driver\Pdo; use Zend\Db\Adapter\Exception; class Mysql implements PlatformInterface { protected $resource = null; public function __construct($driver = null) { if ($driver) { $this->setDriver($driver); } } public function setDriver($driver) { if ($driver instanceof Mysqli\Mysqli || ($driver instanceof Pdo\Pdo && $driver->getDatabasePlatformName() == 'Mysql') || ($driver instanceof \mysqli) || ($driver instanceof \PDO && $driver->getAttribute(\PDO::ATTR_DRIVER_NAME) == 'mysql') ) { $this->resource = $driver; return $this; } throw new Exception\InvalidArgumentException('$driver must be a Mysqli or Mysql PDO Zend\Db\Adapter\Driver, Mysqli instance or MySQL PDO instance'); } public function getName() { return 'MySQL'; } public function getQuoteIdentifierSymbol() { return '`'; } public function quoteIdentifier($identifier) { return '`' . str_replace('`', '``', $identifier) . '`'; } public function quoteIdentifierChain($identifierChain) { $identifierChain = str_replace('`', '``', $identifierChain); if (is_array($identifierChain)) { $identifierChain = implode('`.`', $identifierChain); } return '`' . $identifierChain . '`'; } public function getQuoteValueSymbol() { return '\''; } public function quoteValue($value) { if ($this->resource instanceof DriverInterface) { $this->resource = $this->resource->getConnection()->getResource(); } if ($this->resource instanceof \mysqli) { return '\'' . $this->resource->real_escape_string($value) . '\''; } if ($this->resource instanceof \PDO) { return $this->resource->quote($value); } trigger_error( 'Attempting to quote a value in ' . __CLASS__ . ' without extension/driver support ' . 'can introduce security vulnerabilities in a production environment.' ); return '\'' . addcslashes($value, "\x00\n\r\\'\"\x1a") . '\''; } public function quoteTrustedValue($value) { if ($this->resource instanceof DriverInterface) { $this->resource = $this->resource->getConnection()->getResource(); } if ($this->resource instanceof \mysqli) { return '\'' . $this->resource->real_escape_string($value) . '\''; } if ($this->resource instanceof \PDO) { return $this->resource->quote($value); } return '\'' . addcslashes($value, "\x00\n\r\\'\"\x1a") . '\''; } public function quoteValueList($valueList) { if (!is_array($valueList)) { return $this->quoteValue($valueList); } $value = reset($valueList); do { $valueList[key($valueList)] = $this->quoteValue($value); } while ($value = next($valueList)); return implode(', ', $valueList); } public function getIdentifierSeparator() { return '.'; } public function quoteIdentifierInFragment($identifier, array $safeWords = array()) { $parts = preg_split('#([^0-9,a-z,A-Z$_])#', $identifier, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY); if ($safeWords) { $safeWords = array_flip($safeWords); $safeWords = array_change_key_case($safeWords, CASE_LOWER); } foreach ($parts as $i => $part) { if ($safeWords && isset($safeWords[strtolower($part)])) { continue; } switch ($part) { case ' ': case '.': case '*': case 'AS': case 'As': case 'aS': case 'as': break; default: $parts[$i] = '`' . str_replace('`', '``', $part) . '`'; } } return implode('', $parts); } } } namespace Zend\Db\ResultSet { use ArrayIterator; use Countable; use Iterator; use IteratorAggregate; use Zend\Db\Adapter\Driver\ResultInterface; abstract class AbstractResultSet implements Iterator, ResultSetInterface { protected $buffer = null; protected $count = null; protected $dataSource = null; protected $fieldCount = null; protected $position = 0; public function initialize($dataSource) { if (is_array($this->buffer)) { $this->buffer = array(); } if ($dataSource instanceof ResultInterface) { $this->count = $dataSource->count(); $this->fieldCount = $dataSource->getFieldCount(); $this->dataSource = $dataSource; if ($dataSource->isBuffered()) { $this->buffer = -1; } if (is_array($this->buffer)) { $this->dataSource->rewind(); } return $this; } if (is_array($dataSource)) { $first = current($dataSource); reset($dataSource); $this->count = count($dataSource); $this->fieldCount = count($first); $this->dataSource = new ArrayIterator($dataSource); $this->buffer = -1; } elseif ($dataSource instanceof IteratorAggregate) { $this->dataSource = $dataSource->getIterator(); } elseif ($dataSource instanceof Iterator) { $this->dataSource = $dataSource; } else { throw new Exception\InvalidArgumentException('DataSource provided is not an array, nor does it implement Iterator or IteratorAggregate'); } if ($this->count == null && $this->dataSource instanceof Countable) { $this->count = $this->dataSource->count(); } return $this; } public function buffer() { if ($this->buffer === -2) { throw new Exception\RuntimeException('Buffering must be enabled before iteration is started'); } elseif ($this->buffer === null) { $this->buffer = array(); if ($this->dataSource instanceof ResultInterface) { $this->dataSource->rewind(); } } return $this; } public function isBuffered() { if ($this->buffer === -1 || is_array($this->buffer)) { return true; } return false; } public function getDataSource() { return $this->dataSource; } public function getFieldCount() { if (null !== $this->fieldCount) { return $this->fieldCount; } $dataSource = $this->getDataSource(); if (null === $dataSource) { return 0; } $dataSource->rewind(); if (!$dataSource->valid()) { $this->fieldCount = 0; return 0; } $row = $dataSource->current(); if (is_object($row) && $row instanceof Countable) { $this->fieldCount = $row->count(); return $this->fieldCount; } $row = (array) $row; $this->fieldCount = count($row); return $this->fieldCount; } public function next() { if ($this->buffer === null) { $this->buffer = -2; } $this->dataSource->next(); $this->position++; } public function key() { return $this->position; } public function current() { if ($this->buffer === null) { $this->buffer = -2; } elseif (is_array($this->buffer) && isset($this->buffer[$this->position])) { return $this->buffer[$this->position]; } $data = $this->dataSource->current(); if (is_array($this->buffer)) { $this->buffer[$this->position] = $data; } return $data; } public function valid() { if (is_array($this->buffer) && isset($this->buffer[$this->position])) { return true; } if ($this->dataSource instanceof Iterator) { return $this->dataSource->valid(); } else { $key = key($this->dataSource); return ($key !== null); } } public function rewind() { if (!is_array($this->buffer)) { if ($this->dataSource instanceof Iterator) { $this->dataSource->rewind(); } else { reset($this->dataSource); } } $this->position = 0; } public function count() { if ($this->count !== null) { return $this->count; } $this->count = count($this->dataSource); return $this->count; } public function toArray() { $return = array(); foreach ($this as $row) { if (is_array($row)) { $return[] = $row; } elseif (method_exists($row, 'toArray')) { $return[] = $row->toArray(); } elseif (method_exists($row, 'getArrayCopy')) { $return[] = $row->getArrayCopy(); } else { throw new Exception\RuntimeException( 'Rows as part of this DataSource, with type ' . gettype($row) . ' cannot be cast to an array' ); } } return $return; } } } namespace Zend\Db\ResultSet { use ArrayObject; class ResultSet extends AbstractResultSet { const TYPE_ARRAYOBJECT = 'arrayobject'; const TYPE_ARRAY = 'array'; protected $allowedReturnTypes = array( self::TYPE_ARRAYOBJECT, self::TYPE_ARRAY, ); protected $arrayObjectPrototype = null; protected $returnType = self::TYPE_ARRAYOBJECT; public function __construct($returnType = self::TYPE_ARRAYOBJECT, $arrayObjectPrototype = null) { $this->returnType = (in_array($returnType, array(self::TYPE_ARRAY, self::TYPE_ARRAYOBJECT))) ? $returnType : self::TYPE_ARRAYOBJECT; if ($this->returnType === self::TYPE_ARRAYOBJECT) { $this->setArrayObjectPrototype(($arrayObjectPrototype) ?: new ArrayObject(array(), ArrayObject::ARRAY_AS_PROPS)); } } public function setArrayObjectPrototype($arrayObjectPrototype) { if (!is_object($arrayObjectPrototype) || (!$arrayObjectPrototype instanceof ArrayObject && !method_exists($arrayObjectPrototype, 'exchangeArray')) ) { throw new Exception\InvalidArgumentException('Object must be of type ArrayObject, or at least implement exchangeArray'); } $this->arrayObjectPrototype = $arrayObjectPrototype; return $this; } public function getArrayObjectPrototype() { return $this->arrayObjectPrototype; } public function getReturnType() { return $this->returnType; } public function current() { $data = parent::current(); if ($this->returnType === self::TYPE_ARRAYOBJECT && is_array($data)) { $ao = clone $this->arrayObjectPrototype; if ($ao instanceof ArrayObject || method_exists($ao, 'exchangeArray')) { $ao->exchangeArray($data); } return $ao; } return $data; } } } namespace Zend\Db\TableGateway { use Zend\Db\Adapter\AdapterInterface; use Zend\Db\ResultSet\ResultSet; use Zend\Db\ResultSet\ResultSetInterface; use Zend\Db\Sql\Delete; use Zend\Db\Sql\Insert; use Zend\Db\Sql\Select; use Zend\Db\Sql\Sql; use Zend\Db\Sql\TableIdentifier; use Zend\Db\Sql\Update; use Zend\Db\Sql\Where; abstract class AbstractTableGateway implements TableGatewayInterface { protected $isInitialized = false; protected $adapter = null; protected $table = null; protected $columns = array(); protected $featureSet = null; protected $resultSetPrototype = null; protected $sql = null; protected $lastInsertValue = null; public function isInitialized() { return $this->isInitialized; } public function initialize() { if ($this->isInitialized) { return; } if (!$this->featureSet instanceof Feature\FeatureSet) { $this->featureSet = new Feature\FeatureSet; } $this->featureSet->setTableGateway($this); $this->featureSet->apply('preInitialize', array()); if (!$this->adapter instanceof AdapterInterface) { throw new Exception\RuntimeException('This table does not have an Adapter setup'); } if (!is_string($this->table) && !$this->table instanceof TableIdentifier) { throw new Exception\RuntimeException('This table object does not have a valid table set.'); } if (!$this->resultSetPrototype instanceof ResultSetInterface) { $this->resultSetPrototype = new ResultSet; } if (!$this->sql instanceof Sql) { $this->sql = new Sql($this->adapter, $this->table); } $this->featureSet->apply('postInitialize', array()); $this->isInitialized = true; } public function getTable() { return $this->table; } public function getAdapter() { return $this->adapter; } public function getColumns() { return $this->columns; } public function getFeatureSet() { return $this->featureSet; } public function getResultSetPrototype() { return $this->resultSetPrototype; } public function getSql() { return $this->sql; } public function select($where = null) { if (!$this->isInitialized) { $this->initialize(); } $select = $this->sql->select(); if ($where instanceof \Closure) { $where($select); } elseif ($where !== null) { $select->where($where); } return $this->selectWith($select); } public function selectWith(Select $select) { if (!$this->isInitialized) { $this->initialize(); } return $this->executeSelect($select); } protected function executeSelect(Select $select) { $selectState = $select->getRawState(); if ($selectState['table'] != $this->table && (is_array($selectState['table']) && end($selectState['table']) != $this->table)) { throw new Exception\RuntimeException('The table name of the provided select object must match that of the table'); } if ($selectState['columns'] == array(Select::SQL_STAR) && $this->columns !== array()) { $select->columns($this->columns); } $this->featureSet->apply('preSelect', array($select)); $statement = $this->sql->prepareStatementForSqlObject($select); $result = $statement->execute(); $resultSet = clone $this->resultSetPrototype; $resultSet->initialize($result); $this->featureSet->apply('postSelect', array($statement, $result, $resultSet)); return $resultSet; } public function insert($set) { if (!$this->isInitialized) { $this->initialize(); } $insert = $this->sql->insert(); $insert->values($set); return $this->executeInsert($insert); } public function insertWith(Insert $insert) { if (!$this->isInitialized) { $this->initialize(); } return $this->executeInsert($insert); } protected function executeInsert(Insert $insert) { $insertState = $insert->getRawState(); if ($insertState['table'] != $this->table) { throw new Exception\RuntimeException('The table name of the provided Insert object must match that of the table'); } $this->featureSet->apply('preInsert', array($insert)); $statement = $this->sql->prepareStatementForSqlObject($insert); $result = $statement->execute(); $this->lastInsertValue = $this->adapter->getDriver()->getConnection()->getLastGeneratedValue(); $this->featureSet->apply('postInsert', array($statement, $result)); return $result->getAffectedRows(); } public function update($set, $where = null) { if (!$this->isInitialized) { $this->initialize(); } $sql = $this->sql; $update = $sql->update(); $update->set($set); if ($where !== null) { $update->where($where); } return $this->executeUpdate($update); } public function updateWith(Update $update) { if (!$this->isInitialized) { $this->initialize(); } return $this->executeUpdate($update); } protected function executeUpdate(Update $update) { $updateState = $update->getRawState(); if ($updateState['table'] != $this->table) { throw new Exception\RuntimeException('The table name of the provided Update object must match that of the table'); } $this->featureSet->apply('preUpdate', array($update)); $statement = $this->sql->prepareStatementForSqlObject($update); $result = $statement->execute(); $this->featureSet->apply('postUpdate', array($statement, $result)); return $result->getAffectedRows(); } public function delete($where) { if (!$this->isInitialized) { $this->initialize(); } $delete = $this->sql->delete(); if ($where instanceof \Closure) { $where($delete); } else { $delete->where($where); } return $this->executeDelete($delete); } public function deleteWith(Delete $delete) { $this->initialize(); return $this->executeDelete($delete); } protected function executeDelete(Delete $delete) { $deleteState = $delete->getRawState(); if ($deleteState['table'] != $this->table) { throw new Exception\RuntimeException('The table name of the provided Update object must match that of the table'); } $this->featureSet->apply('preDelete', array($delete)); $statement = $this->sql->prepareStatementForSqlObject($delete); $result = $statement->execute(); $this->featureSet->apply('postDelete', array($statement, $result)); return $result->getAffectedRows(); } public function getLastInsertValue() { return $this->lastInsertValue; } public function __get($property) { switch (strtolower($property)) { case 'lastinsertvalue': return $this->lastInsertValue; case 'adapter': return $this->adapter; case 'table': return $this->table; } if ($this->featureSet->canCallMagicGet($property)) { return $this->featureSet->callMagicGet($property); } throw new Exception\InvalidArgumentException('Invalid magic property access in ' . __CLASS__ . '::__get()'); } public function __set($property, $value) { if ($this->featureSet->canCallMagicSet($property)) { return $this->featureSet->callMagicSet($property, $value); } throw new Exception\InvalidArgumentException('Invalid magic property access in ' . __CLASS__ . '::__set()'); } public function __call($method, $arguments) { if ($this->featureSet->canCallMagicCall($method)) { return $this->featureSet->callMagicCall($method, $arguments); } throw new Exception\InvalidArgumentException('Invalid method (' . $method . ') called, caught by ' . __CLASS__ . '::__call()'); } public function __clone() { $this->resultSetPrototype = (isset($this->resultSetPrototype)) ? clone $this->resultSetPrototype : null; $this->sql = clone $this->sql; if (is_object($this->table)) { $this->table = clone $this->table; } } } } namespace Zend\Db\TableGateway { use Zend\Db\Adapter\AdapterInterface; use Zend\Db\ResultSet\ResultSet; use Zend\Db\ResultSet\ResultSetInterface; use Zend\Db\Sql\Sql; use Zend\Db\Sql\TableIdentifier; class TableGateway extends AbstractTableGateway { public function __construct($table, AdapterInterface $adapter, $features = null, ResultSetInterface $resultSetPrototype = null, Sql $sql = null) { if (!(is_string($table) || $table instanceof TableIdentifier)) { throw new Exception\InvalidArgumentException('Table name must be a string or an instance of Zend\Db\Sql\TableIdentifier'); } $this->table = $table; $this->adapter = $adapter; if ($features !== null) { if ($features instanceof Feature\AbstractFeature) { $features = array($features); } if (is_array($features)) { $this->featureSet = new Feature\FeatureSet($features); } elseif ($features instanceof Feature\FeatureSet) { $this->featureSet = $features; } else { throw new Exception\InvalidArgumentException( 'TableGateway expects $feature to be an instance of an AbstractFeature or a FeatureSet, or an array of AbstractFeatures' ); } } else { $this->featureSet = new Feature\FeatureSet(); } $this->resultSetPrototype = ($resultSetPrototype) ?: new ResultSet; $this->sql = ($sql) ?: new Sql($this->adapter, $this->table); if ($this->sql->getTable() != $this->table) { throw new Exception\InvalidArgumentException('The table inside the provided Sql object must match the table of this TableGateway'); } $this->initialize(); } } } namespace Zend\Db\TableGateway\Feature { use Zend\Db\TableGateway\AbstractTableGateway; use Zend\Db\TableGateway\TableGatewayInterface; class FeatureSet { const APPLY_HALT = 'halt'; protected $tableGateway = null; protected $features = array(); protected $magicSpecifications = array(); public function __construct(array $features = array()) { if ($features) { $this->addFeatures($features); } } public function setTableGateway(AbstractTableGateway $tableGateway) { $this->tableGateway = $tableGateway; foreach ($this->features as $feature) { $feature->setTableGateway($this->tableGateway); } return $this; } public function getFeatureByClassName($featureClassName) { $feature = false; foreach ($this->features as $potentialFeature) { if ($potentialFeature instanceof $featureClassName) { $feature = $potentialFeature; break; } } return $feature; } public function addFeatures(array $features) { foreach ($features as $feature) { $this->addFeature($feature); } return $this; } public function addFeature(AbstractFeature $feature) { if ($this->tableGateway instanceof TableGatewayInterface) { $feature->setTableGateway($this->tableGateway); } $this->features[] = $feature; return $this; } public function apply($method, $args) { foreach ($this->features as $feature) { if (method_exists($feature, $method)) { $return = call_user_func_array(array($feature, $method), $args); if ($return === self::APPLY_HALT) { break; } } } } public function canCallMagicGet($property) { return false; } public function callMagicGet($property) { $return = null; return $return; } public function canCallMagicSet($property) { return false; } public function callMagicSet($property, $value) { $return = null; return $return; } public function canCallMagicCall($method) { return false; } public function callMagicCall($method, $arguments) { $return = null; return $return; } } } namespace Zend\Db\Sql { use Zend\Db\Adapter\AdapterInterface; use Zend\Db\Adapter\Driver\StatementInterface; use Zend\Db\Adapter\Platform\PlatformInterface; class Sql { protected $adapter = null; protected $table = null; protected $sqlPlatform = null; public function __construct(AdapterInterface $adapter, $table = null, Platform\AbstractPlatform $sqlPlatform = null) { $this->adapter = $adapter; if ($table) { $this->setTable($table); } $this->sqlPlatform = ($sqlPlatform) ?: new Platform\Platform($adapter); } public function getAdapter() { return $this->adapter; } public function hasTable() { return ($this->table != null); } public function setTable($table) { if (is_string($table) || is_array($table) || $table instanceof TableIdentifier) { $this->table = $table; } else { throw new Exception\InvalidArgumentException('Table must be a string, array or instance of TableIdentifier.'); } return $this; } public function getTable() { return $this->table; } public function getSqlPlatform() { return $this->sqlPlatform; } public function select($table = null) { if ($this->table !== null && $table !== null) { throw new Exception\InvalidArgumentException(sprintf( 'This Sql object is intended to work with only the table "%s" provided at construction time.', $this->table )); } return new Select(($table) ?: $this->table); } public function insert($table = null) { if ($this->table !== null && $table !== null) { throw new Exception\InvalidArgumentException(sprintf( 'This Sql object is intended to work with only the table "%s" provided at construction time.', $this->table )); } return new Insert(($table) ?: $this->table); } public function update($table = null) { if ($this->table !== null && $table !== null) { throw new Exception\InvalidArgumentException(sprintf( 'This Sql object is intended to work with only the table "%s" provided at construction time.', $this->table )); } return new Update(($table) ?: $this->table); } public function delete($table = null) { if ($this->table !== null && $table !== null) { throw new Exception\InvalidArgumentException(sprintf( 'This Sql object is intended to work with only the table "%s" provided at construction time.', $this->table )); } return new Delete(($table) ?: $this->table); } public function prepareStatementForSqlObject(PreparableSqlInterface $sqlObject, StatementInterface $statement = null) { $statement = ($statement) ?: $this->adapter->getDriver()->createStatement(); if ($this->sqlPlatform) { $this->sqlPlatform->setSubject($sqlObject); $this->sqlPlatform->prepareStatement($this->adapter, $statement); } else { $sqlObject->prepareStatement($this->adapter, $statement); } return $statement; } public function getSqlStringForSqlObject(SqlInterface $sqlObject, PlatformInterface $platform = null) { $platform = ($platform) ?: $this->adapter->getPlatform(); if ($this->sqlPlatform) { $this->sqlPlatform->setSubject($sqlObject); $sqlString = $this->sqlPlatform->getSqlString($platform); } else { $sqlString = $sqlObject->getSqlString($platform); } return $sqlString; } } } namespace Zend\Db\Sql\Platform { use Zend\Db\Adapter\AdapterInterface; use Zend\Db\Adapter\Platform\PlatformInterface; use Zend\Db\Adapter\StatementContainerInterface; use Zend\Db\Sql\Exception; use Zend\Db\Sql\PreparableSqlInterface; use Zend\Db\Sql\SqlInterface; class AbstractPlatform implements PlatformDecoratorInterface, PreparableSqlInterface, SqlInterface { protected $subject = null; protected $decorators = array(); public function setSubject($subject) { $this->subject = $subject; } public function setTypeDecorator($type, PlatformDecoratorInterface $decorator) { $this->decorators[$type] = $decorator; } public function getDecorators() { return $this->decorators; } public function prepareStatement(AdapterInterface $adapter, StatementContainerInterface $statementContainer) { if (!$this->subject instanceof PreparableSqlInterface) { throw new Exception\RuntimeException('The subject does not appear to implement Zend\Db\Sql\PreparableSqlInterface, thus calling prepareStatement() has no effect'); } $decoratorForType = false; foreach ($this->decorators as $type => $decorator) { if ($this->subject instanceof $type && $decorator instanceof PreparableSqlInterface) { $decoratorForType = $decorator; break; } } if ($decoratorForType) { $decoratorForType->setSubject($this->subject); $decoratorForType->prepareStatement($adapter, $statementContainer); } else { $this->subject->prepareStatement($adapter, $statementContainer); } } public function getSqlString(PlatformInterface $adapterPlatform = null) { if (!$this->subject instanceof SqlInterface) { throw new Exception\RuntimeException('The subject does not appear to implement Zend\Db\Sql\PreparableSqlInterface, thus calling prepareStatement() has no effect'); } $decoratorForType = false; foreach ($this->decorators as $type => $decorator) { if ($this->subject instanceof $type && $decorator instanceof SqlInterface) { $decoratorForType = $decorator; break; } } if ($decoratorForType) { $decoratorForType->setSubject($this->subject); return $decoratorForType->getSqlString($adapterPlatform); } return $this->subject->getSqlString($adapterPlatform); } } } namespace Zend\Db\Sql\Platform { use Zend\Db\Adapter\AdapterInterface; class Platform extends AbstractPlatform { protected $adapter = null; public function __construct(AdapterInterface $adapter) { $this->adapter = $adapter; $platform = $adapter->getPlatform(); switch (strtolower($platform->getName())) { case 'mysql': $platform = new Mysql\Mysql(); $this->decorators = $platform->decorators; break; case 'sqlserver': $platform = new SqlServer\SqlServer(); $this->decorators = $platform->decorators; break; case 'oracle': $platform = new Oracle\Oracle(); $this->decorators = $platform->decorators; break; case 'ibm db2': case 'ibm_db2': case 'ibmdb2': $platform = new IbmDb2\IbmDb2(); $this->decorators = $platform->decorators; default: } } } } namespace Zend\Db\Sql\Platform\Mysql { use Zend\Db\Sql\Platform\AbstractPlatform; class Mysql extends AbstractPlatform { public function __construct() { $this->setTypeDecorator('Zend\Db\Sql\Select', new SelectDecorator()); $this->setTypeDecorator('Zend\Db\Sql\Ddl\CreateTable', new Ddl\CreateTableDecorator()); } } } namespace Zend\Db\Sql { use Zend\Db\Adapter\Driver\DriverInterface; use Zend\Db\Adapter\ParameterContainer; use Zend\Db\Adapter\Platform\PlatformInterface; use Zend\Db\Adapter\StatementContainer; use Zend\Db\Sql\Platform\PlatformDecoratorInterface; abstract class AbstractSql { protected $specifications = array(); protected $processInfo = array('paramPrefix' => '', 'subselectCount' => 0); protected $instanceParameterIndex = array(); protected function processExpression(ExpressionInterface $expression, PlatformInterface $platform, DriverInterface $driver = null, $namedParameterPrefix = null) { static $runtimeExpressionPrefix = 0; if ($driver && ((!is_string($namedParameterPrefix) || $namedParameterPrefix == ''))) { $namedParameterPrefix = sprintf('expr%04dParam', ++$runtimeExpressionPrefix); } $sql = ''; $statementContainer = new StatementContainer; $parameterContainer = $statementContainer->getParameterContainer(); $parts = $expression->getExpressionData(); if (!isset($this->instanceParameterIndex[$namedParameterPrefix])) { $this->instanceParameterIndex[$namedParameterPrefix] = 1; } $expressionParamIndex = &$this->instanceParameterIndex[$namedParameterPrefix]; foreach ($parts as $part) { if (is_string($part)) { $sql .= $part; continue; } if (!is_array($part)) { throw new Exception\RuntimeException('Elements returned from getExpressionData() array must be a string or array.'); } $values = $part[1]; $types = (isset($part[2])) ? $part[2] : array(); foreach ($values as $vIndex => $value) { if (isset($types[$vIndex]) && $types[$vIndex] == ExpressionInterface::TYPE_IDENTIFIER) { $values[$vIndex] = $platform->quoteIdentifierInFragment($value); } elseif (isset($types[$vIndex]) && $types[$vIndex] == ExpressionInterface::TYPE_VALUE && $value instanceof Select) { if ($driver) { $values[$vIndex] = '(' . $this->processSubSelect($value, $platform, $driver, $parameterContainer) . ')'; } else { $values[$vIndex] = '(' . $this->processSubSelect($value, $platform) . ')'; } } elseif (isset($types[$vIndex]) && $types[$vIndex] == ExpressionInterface::TYPE_VALUE && $value instanceof ExpressionInterface) { $innerStatementContainer = $this->processExpression($value, $platform, $driver, $namedParameterPrefix . $vIndex . 'subpart'); $values[$vIndex] = $innerStatementContainer->getSql(); if ($driver) { $parameterContainer->merge($innerStatementContainer->getParameterContainer()); } } elseif (isset($types[$vIndex]) && $types[$vIndex] == ExpressionInterface::TYPE_VALUE) { if ($driver) { $name = $namedParameterPrefix . $expressionParamIndex++; $parameterContainer->offsetSet($name, $value); $values[$vIndex] = $driver->formatParameterName($name); continue; } $values[$vIndex] = $platform->quoteValue($value); } elseif (isset($types[$vIndex]) && $types[$vIndex] == ExpressionInterface::TYPE_LITERAL) { $values[$vIndex] = $value; } } $sql .= vsprintf($part[0], $values); } $statementContainer->setSql($sql); return $statementContainer; } protected function createSqlFromSpecificationAndParameters($specifications, $parameters) { if (is_string($specifications)) { return vsprintf($specifications, $parameters); } $parametersCount = count($parameters); foreach ($specifications as $specificationString => $paramSpecs) { if ($parametersCount == count($paramSpecs)) { break; } unset($specificationString, $paramSpecs); } if (!isset($specificationString)) { throw new Exception\RuntimeException( 'A number of parameters was found that is not supported by this specification' ); } $topParameters = array(); foreach ($parameters as $position => $paramsForPosition) { if (isset($paramSpecs[$position]['combinedby'])) { $multiParamValues = array(); foreach ($paramsForPosition as $multiParamsForPosition) { $ppCount = count($multiParamsForPosition); if (!isset($paramSpecs[$position][$ppCount])) { throw new Exception\RuntimeException('A number of parameters (' . $ppCount . ') was found that is not supported by this specification'); } $multiParamValues[] = vsprintf($paramSpecs[$position][$ppCount], $multiParamsForPosition); } $topParameters[] = implode($paramSpecs[$position]['combinedby'], $multiParamValues); } elseif ($paramSpecs[$position] !== null) { $ppCount = count($paramsForPosition); if (!isset($paramSpecs[$position][$ppCount])) { throw new Exception\RuntimeException('A number of parameters (' . $ppCount . ') was found that is not supported by this specification'); } $topParameters[] = vsprintf($paramSpecs[$position][$ppCount], $paramsForPosition); } else { $topParameters[] = $paramsForPosition; } } return vsprintf($specificationString, $topParameters); } protected function processSubSelect(Select $subselect, PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($driver) { $stmtContainer = new StatementContainer; $this->processInfo['subselectCount']++; $subselect->processInfo['subselectCount'] = $this->processInfo['subselectCount']; $subselect->processInfo['paramPrefix'] = 'subselect' . $subselect->processInfo['subselectCount']; if ($this instanceof PlatformDecoratorInterface) { $subselectDecorator = clone $this; $subselectDecorator->setSubject($subselect); $subselectDecorator->prepareStatement(new \Zend\Db\Adapter\Adapter($driver, $platform), $stmtContainer); } else { $subselect->prepareStatement(new \Zend\Db\Adapter\Adapter($driver, $platform), $stmtContainer); } $this->processInfo['subselectCount'] = $subselect->processInfo['subselectCount']; $parameterContainer->merge($stmtContainer->getParameterContainer()->getNamedArray()); $sql = $stmtContainer->getSql(); } else { if ($this instanceof PlatformDecoratorInterface) { $subselectDecorator = clone $this; $subselectDecorator->setSubject($subselect); $sql = $subselectDecorator->getSqlString($platform); } else { $sql = $subselect->getSqlString($platform); } } return $sql; } } } namespace Zend\Db\Sql { use Zend\Db\Adapter\AdapterInterface; use Zend\Db\Adapter\Driver\DriverInterface; use Zend\Db\Adapter\StatementContainerInterface; use Zend\Db\Adapter\ParameterContainer; use Zend\Db\Adapter\Platform\PlatformInterface; use Zend\Db\Adapter\Platform\Sql92 as AdapterSql92Platform; class Select extends AbstractSql implements SqlInterface, PreparableSqlInterface { const SELECT = 'select'; const QUANTIFIER = 'quantifier'; const COLUMNS = 'columns'; const TABLE = 'table'; const JOINS = 'joins'; const WHERE = 'where'; const GROUP = 'group'; const HAVING = 'having'; const ORDER = 'order'; const LIMIT = 'limit'; const OFFSET = 'offset'; const QUANTIFIER_DISTINCT = 'DISTINCT'; const QUANTIFIER_ALL = 'ALL'; const JOIN_INNER = 'inner'; const JOIN_OUTER = 'outer'; const JOIN_LEFT = 'left'; const JOIN_RIGHT = 'right'; const SQL_STAR = '*'; const ORDER_ASCENDING = 'ASC'; const ORDER_DESCENDING = 'DESC'; const COMBINE = 'combine'; const COMBINE_UNION = 'union'; const COMBINE_EXCEPT = 'except'; const COMBINE_INTERSECT = 'intersect'; protected $specifications = array( 'statementStart' => '%1$s', self::SELECT => array( 'SELECT %1$s FROM %2$s' => array( array(1 => '%1$s', 2 => '%1$s AS %2$s', 'combinedby' => ', '), null ), 'SELECT %1$s %2$s FROM %3$s' => array( null, array(1 => '%1$s', 2 => '%1$s AS %2$s', 'combinedby' => ', '), null ), 'SELECT %1$s' => array( array(1 => '%1$s', 2 => '%1$s AS %2$s', 'combinedby' => ', '), ), ), self::JOINS => array( '%1$s' => array( array(3 => '%1$s JOIN %2$s ON %3$s', 'combinedby' => ' ') ) ), self::WHERE => 'WHERE %1$s', self::GROUP => array( 'GROUP BY %1$s' => array( array(1 => '%1$s', 'combinedby' => ', ') ) ), self::HAVING => 'HAVING %1$s', self::ORDER => array( 'ORDER BY %1$s' => array( array(1 => '%1$s', 2 => '%1$s %2$s', 'combinedby' => ', ') ) ), self::LIMIT => 'LIMIT %1$s', self::OFFSET => 'OFFSET %1$s', 'statementEnd' => '%1$s', self::COMBINE => '%1$s ( %2$s )', ); protected $tableReadOnly = false; protected $prefixColumnsWithTable = true; protected $table = null; protected $quantifier = null; protected $columns = array(self::SQL_STAR); protected $joins = array(); protected $where = null; protected $order = array(); protected $group = null; protected $having = null; protected $limit = null; protected $offset = null; protected $combine = array(); public function __construct($table = null) { if ($table) { $this->from($table); $this->tableReadOnly = true; } $this->where = new Where; $this->having = new Having; } public function from($table) { if ($this->tableReadOnly) { throw new Exception\InvalidArgumentException('Since this object was created with a table and/or schema in the constructor, it is read only.'); } if (!is_string($table) && !is_array($table) && !$table instanceof TableIdentifier) { throw new Exception\InvalidArgumentException('$table must be a string, array, or an instance of TableIdentifier'); } if (is_array($table) && (!is_string(key($table)) || count($table) !== 1)) { throw new Exception\InvalidArgumentException('from() expects $table as an array is a single element associative array'); } $this->table = $table; return $this; } public function quantifier($quantifier) { if (!is_string($quantifier) && !$quantifier instanceof Expression) { throw new Exception\InvalidArgumentException( 'Quantifier must be one of DISTINCT, ALL, or some platform specific Expression object' ); } $this->quantifier = $quantifier; return $this; } public function columns(array $columns, $prefixColumnsWithTable = true) { $this->columns = $columns; $this->prefixColumnsWithTable = (bool) $prefixColumnsWithTable; return $this; } public function join($name, $on, $columns = self::SQL_STAR, $type = self::JOIN_INNER) { if (is_array($name) && (!is_string(key($name)) || count($name) !== 1)) { throw new Exception\InvalidArgumentException( sprintf("join() expects '%s' as an array is a single element associative array", array_shift($name)) ); } if (!is_array($columns)) { $columns = array($columns); } $this->joins[] = array( 'name' => $name, 'on' => $on, 'columns' => $columns, 'type' => $type ); return $this; } public function where($predicate, $combination = Predicate\PredicateSet::OP_AND) { if ($predicate instanceof Where) { $this->where = $predicate; } else { $this->where->addPredicates($predicate, $combination); } return $this; } public function group($group) { if (is_array($group)) { foreach ($group as $o) { $this->group[] = $o; } } else { $this->group[] = $group; } return $this; } public function having($predicate, $combination = Predicate\PredicateSet::OP_AND) { if ($predicate instanceof Having) { $this->having = $predicate; } else { $this->having->addPredicates($predicate, $combination); } return $this; } public function order($order) { if (is_string($order)) { if (strpos($order, ',') !== false) { $order = preg_split('#,\s+#', $order); } else { $order = (array) $order; } } elseif (!is_array($order)) { $order = array($order); } foreach ($order as $k => $v) { if (is_string($k)) { $this->order[$k] = $v; } else { $this->order[] = $v; } } return $this; } public function limit($limit) { if (!is_numeric($limit)) { throw new Exception\InvalidArgumentException(sprintf( '%s expects parameter to be numeric, "%s" given', __METHOD__, (is_object($limit) ? get_class($limit) : gettype($limit)) )); } $this->limit = $limit; return $this; } public function offset($offset) { if (!is_numeric($offset)) { throw new Exception\InvalidArgumentException(sprintf( '%s expects parameter to be numeric, "%s" given', __METHOD__, (is_object($offset) ? get_class($offset) : gettype($offset)) )); } $this->offset = $offset; return $this; } public function combine(Select $select, $type = self::COMBINE_UNION, $modifier = '') { if ($this->combine !== array()) { throw new Exception\InvalidArgumentException('This Select object is already combined and cannot be combined with multiple Selects objects'); } $this->combine = array( 'select' => $select, 'type' => $type, 'modifier' => $modifier ); return $this; } public function reset($part) { switch ($part) { case self::TABLE: if ($this->tableReadOnly) { throw new Exception\InvalidArgumentException( 'Since this object was created with a table and/or schema in the constructor, it is read only.' ); } $this->table = null; break; case self::QUANTIFIER: $this->quantifier = null; break; case self::COLUMNS: $this->columns = array(); break; case self::JOINS: $this->joins = array(); break; case self::WHERE: $this->where = new Where; break; case self::GROUP: $this->group = null; break; case self::HAVING: $this->having = new Having; break; case self::LIMIT: $this->limit = null; break; case self::OFFSET: $this->offset = null; break; case self::ORDER: $this->order = array(); break; case self::COMBINE: $this->combine = array(); break; } return $this; } public function setSpecification($index, $specification) { if (!method_exists($this, 'process' . $index)) { throw new Exception\InvalidArgumentException('Not a valid specification name.'); } $this->specifications[$index] = $specification; return $this; } public function getRawState($key = null) { $rawState = array( self::TABLE => $this->table, self::QUANTIFIER => $this->quantifier, self::COLUMNS => $this->columns, self::JOINS => $this->joins, self::WHERE => $this->where, self::ORDER => $this->order, self::GROUP => $this->group, self::HAVING => $this->having, self::LIMIT => $this->limit, self::OFFSET => $this->offset, self::COMBINE => $this->combine ); return (isset($key) && array_key_exists($key, $rawState)) ? $rawState[$key] : $rawState; } public function prepareStatement(AdapterInterface $adapter, StatementContainerInterface $statementContainer) { $parameterContainer = $statementContainer->getParameterContainer(); if (!$parameterContainer instanceof ParameterContainer) { $parameterContainer = new ParameterContainer(); $statementContainer->setParameterContainer($parameterContainer); } $sqls = array(); $parameters = array(); $platform = $adapter->getPlatform(); $driver = $adapter->getDriver(); foreach ($this->specifications as $name => $specification) { $parameters[$name] = $this->{'process' . $name}($platform, $driver, $parameterContainer, $sqls, $parameters); if ($specification && is_array($parameters[$name])) { $sqls[$name] = $this->createSqlFromSpecificationAndParameters($specification, $parameters[$name]); } } $sql = implode(' ', $sqls); $statementContainer->setSql($sql); return; } public function getSqlString(PlatformInterface $adapterPlatform = null) { $adapterPlatform = ($adapterPlatform) ?: new AdapterSql92Platform; $sqls = array(); $parameters = array(); foreach ($this->specifications as $name => $specification) { $parameters[$name] = $this->{'process' . $name}($adapterPlatform, null, null, $sqls, $parameters); if ($specification && is_array($parameters[$name])) { $sqls[$name] = $this->createSqlFromSpecificationAndParameters($specification, $parameters[$name]); } } $sql = implode(' ', $sqls); return $sql; } public function isTableReadOnly() { return $this->tableReadOnly; } protected function renderTable($table, $alias = null) { $sql = $table; if ($alias) { $sql .= ' AS ' . $alias; } return $sql; } protected function processStatementStart(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->combine !== array()) { return array('('); } } protected function processStatementEnd(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->combine !== array()) { return array(')'); } } protected function processSelect(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { $expr = 1; if ($this->table) { $table = $this->table; $schema = $alias = null; if (is_array($table)) { $alias = key($this->table); $table = current($this->table); } if ($table instanceof TableIdentifier) { list($table, $schema) = $table->getTableAndSchema(); } if ($table instanceof Select) { $table = '(' . $this->processSubselect($table, $platform, $driver, $parameterContainer) . ')'; } else { $table = $platform->quoteIdentifier($table); } if ($schema) { $table = $platform->quoteIdentifier($schema) . $platform->getIdentifierSeparator() . $table; } if ($alias) { $fromTable = $platform->quoteIdentifier($alias); $table = $this->renderTable($table, $fromTable); } else { $fromTable = $table; } } else { $fromTable = ''; } if ($this->prefixColumnsWithTable) { $fromTable .= $platform->getIdentifierSeparator(); } else { $fromTable = ''; } $columns = array(); foreach ($this->columns as $columnIndexOrAs => $column) { $columnName = ''; if ($column === self::SQL_STAR) { $columns[] = array($fromTable . self::SQL_STAR); continue; } if ($column instanceof ExpressionInterface) { $columnParts = $this->processExpression( $column, $platform, $driver, $this->processInfo['paramPrefix'] . ((is_string($columnIndexOrAs)) ? $columnIndexOrAs : 'column') ); if ($parameterContainer) { $parameterContainer->merge($columnParts->getParameterContainer()); } $columnName .= $columnParts->getSql(); } else { $columnName .= $fromTable . $platform->quoteIdentifier($column); } if (is_string($columnIndexOrAs)) { $columnAs = $platform->quoteIdentifier($columnIndexOrAs); } elseif (stripos($columnName, ' as ') === false) { $columnAs = (is_string($column)) ? $platform->quoteIdentifier($column) : 'Expression' . $expr++; } $columns[] = (isset($columnAs)) ? array($columnName, $columnAs) : array($columnName); } $separator = $platform->getIdentifierSeparator(); foreach ($this->joins as $join) { foreach ($join['columns'] as $jKey => $jColumn) { $jColumns = array(); if ($jColumn instanceof ExpressionInterface) { $jColumnParts = $this->processExpression( $jColumn, $platform, $driver, $this->processInfo['paramPrefix'] . ((is_string($jKey)) ? $jKey : 'column') ); if ($parameterContainer) { $parameterContainer->merge($jColumnParts->getParameterContainer()); } $jColumns[] = $jColumnParts->getSql(); } else { $name = (is_array($join['name'])) ? key($join['name']) : $name = $join['name']; if ($name instanceof TableIdentifier) { $name = ($name->hasSchema() ? $platform->quoteIdentifier($name->getSchema()) . $separator : '') . $platform->quoteIdentifier($name->getTable()); } else { $name = $platform->quoteIdentifier($name); } $jColumns[] = $name . $separator . $platform->quoteIdentifierInFragment($jColumn); } if (is_string($jKey)) { $jColumns[] = $platform->quoteIdentifier($jKey); } elseif ($jColumn !== self::SQL_STAR) { $jColumns[] = $platform->quoteIdentifier($jColumn); } $columns[] = $jColumns; } } if ($this->quantifier) { if ($this->quantifier instanceof ExpressionInterface) { $quantifierParts = $this->processExpression($this->quantifier, $platform, $driver, 'quantifier'); if ($parameterContainer) { $parameterContainer->merge($quantifierParts->getParameterContainer()); } $quantifier = $quantifierParts->getSql(); } else { $quantifier = $this->quantifier; } } if (!isset($table)) { return array($columns); } elseif (isset($quantifier)) { return array($quantifier, $columns, $table); } else { return array($columns, $table); } } protected function processJoins(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if (!$this->joins) { return null; } $joinSpecArgArray = array(); foreach ($this->joins as $j => $join) { $joinSpecArgArray[$j] = array(); $joinName = null; $joinAs = null; $joinSpecArgArray[$j][] = strtoupper($join['type']); if (is_array($join['name'])) { $joinName = current($join['name']); $joinAs = $platform->quoteIdentifier(key($join['name'])); } else { $joinName = $join['name']; } if ($joinName instanceof ExpressionInterface) { $joinName = $joinName->getExpression(); } elseif ($joinName instanceof TableIdentifier) { $joinName = $joinName->getTableAndSchema(); $joinName = ($joinName[1] ? $platform->quoteIdentifier($joinName[1]) . $platform->getIdentifierSeparator() : '') . $platform->quoteIdentifier($joinName[0]); } else { if ($joinName instanceof Select) { $joinName = '(' . $this->processSubSelect($joinName, $platform, $driver, $parameterContainer) . ')'; } else { $joinName = $platform->quoteIdentifier($joinName); } } $joinSpecArgArray[$j][] = (isset($joinAs)) ? $joinName . ' AS ' . $joinAs : $joinName; $joinSpecArgArray[$j][] = ($join['on'] instanceof ExpressionInterface) ? $this->processExpression($join['on'], $platform, $driver, $this->processInfo['paramPrefix'] . 'join' . ($j+1) . 'part') : $platform->quoteIdentifierInFragment($join['on'], array('=', 'AND', 'OR', '(', ')', 'BETWEEN', '<', '>')); if ($joinSpecArgArray[$j][2] instanceof StatementContainerInterface) { if ($parameterContainer) { $parameterContainer->merge($joinSpecArgArray[$j][2]->getParameterContainer()); } $joinSpecArgArray[$j][2] = $joinSpecArgArray[$j][2]->getSql(); } } return array($joinSpecArgArray); } protected function processWhere(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->where->count() == 0) { return null; } $whereParts = $this->processExpression($this->where, $platform, $driver, $this->processInfo['paramPrefix'] . 'where'); if ($parameterContainer) { $parameterContainer->merge($whereParts->getParameterContainer()); } return array($whereParts->getSql()); } protected function processGroup(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->group === null) { return null; } $groups = array(); foreach ($this->group as $column) { $columnSql = ''; if ($column instanceof Expression) { $columnParts = $this->processExpression($column, $platform, $driver, $this->processInfo['paramPrefix'] . 'group'); if ($parameterContainer) { $parameterContainer->merge($columnParts->getParameterContainer()); } $columnSql .= $columnParts->getSql(); } else { $columnSql .= $platform->quoteIdentifierInFragment($column); } $groups[] = $columnSql; } return array($groups); } protected function processHaving(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->having->count() == 0) { return null; } $whereParts = $this->processExpression($this->having, $platform, $driver, $this->processInfo['paramPrefix'] . 'having'); if ($parameterContainer) { $parameterContainer->merge($whereParts->getParameterContainer()); } return array($whereParts->getSql()); } protected function processOrder(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if (empty($this->order)) { return null; } $orders = array(); foreach ($this->order as $k => $v) { if ($v instanceof Expression) { $orderParts = $this->processExpression($v, $platform, $driver); if ($parameterContainer) { $parameterContainer->merge($orderParts->getParameterContainer()); } $orders[] = array($orderParts->getSql()); continue; } if (is_int($k)) { if (strpos($v, ' ') !== false) { list($k, $v) = preg_split('# #', $v, 2); } else { $k = $v; $v = self::ORDER_ASCENDING; } } if (strtoupper($v) == self::ORDER_DESCENDING) { $orders[] = array($platform->quoteIdentifierInFragment($k), self::ORDER_DESCENDING); } else { $orders[] = array($platform->quoteIdentifierInFragment($k), self::ORDER_ASCENDING); } } return array($orders); } protected function processLimit(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->limit === null) { return null; } $limit = $this->limit; if ($driver) { $sql = $driver->formatParameterName('limit'); $parameterContainer->offsetSet('limit', $limit, ParameterContainer::TYPE_INTEGER); } else { $sql = $platform->quoteValue($limit); } return array($sql); } protected function processOffset(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->offset === null) { return null; } $offset = $this->offset; if ($driver) { $parameterContainer->offsetSet('offset', $offset, ParameterContainer::TYPE_INTEGER); return array($driver->formatParameterName('offset')); } return array($platform->quoteValue($offset)); } protected function processCombine(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->combine == array()) { return null; } $type = $this->combine['type']; if ($this->combine['modifier']) { $type .= ' ' . $this->combine['modifier']; } $type = strtoupper($type); if ($driver) { $sql = $this->processSubSelect($this->combine['select'], $platform, $driver, $parameterContainer); return array($type, $sql); } return array( $type, $this->processSubSelect($this->combine['select'], $platform) ); } public function __get($name) { switch (strtolower($name)) { case 'where': return $this->where; case 'having': return $this->having; default: throw new Exception\InvalidArgumentException('Not a valid magic property for this object'); } } public function __clone() { $this->where = clone $this->where; $this->having = clone $this->having; } } } namespace Zend\Db\Sql\Platform\Mysql { use Zend\Db\Adapter\AdapterInterface; use Zend\Db\Adapter\Driver\DriverInterface; use Zend\Db\Adapter\ParameterContainer; use Zend\Db\Adapter\Platform\PlatformInterface; use Zend\Db\Adapter\StatementContainerInterface; use Zend\Db\Sql\Platform\PlatformDecoratorInterface; use Zend\Db\Sql\Select; class SelectDecorator extends Select implements PlatformDecoratorInterface { protected $select = null; public function setSubject($select) { $this->select = $select; } public function prepareStatement(AdapterInterface $adapter, StatementContainerInterface $statementContainer) { foreach (get_object_vars($this->select) as $name => $value) { $this->{$name} = $value; } if ($this->limit === null && $this->offset !== null) { $this->specifications[self::LIMIT] = 'LIMIT 18446744073709551615'; } parent::prepareStatement($adapter, $statementContainer); } public function getSqlString(PlatformInterface $platform = null) { foreach (get_object_vars($this->select) as $name => $value) { $this->{$name} = $value; } if ($this->limit === null && $this->offset !== null) { $this->specifications[self::LIMIT] = 'LIMIT 18446744073709551615'; } return parent::getSqlString($platform); } protected function processLimit(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->limit === null && $this->offset !== null) { return array(''); } if ($this->limit === null) { return null; } if ($driver) { $sql = $driver->formatParameterName('limit'); $parameterContainer->offsetSet('limit', $this->limit, ParameterContainer::TYPE_INTEGER); } else { $sql = $this->limit; } return array($sql); } protected function processOffset(PlatformInterface $platform, DriverInterface $driver = null, ParameterContainer $parameterContainer = null) { if ($this->offset === null) { return null; } if ($driver) { $parameterContainer->offsetSet('offset', $this->offset, ParameterContainer::TYPE_INTEGER); return array($driver->formatParameterName('offset')); } return array($this->offset); } } } namespace Zend\Db\Sql\Predicate { use Countable; use Zend\Db\Sql\Exception; class PredicateSet implements PredicateInterface, Countable { const COMBINED_BY_AND = 'AND'; const OP_AND = 'AND'; const COMBINED_BY_OR = 'OR'; const OP_OR = 'OR'; protected $defaultCombination = self::COMBINED_BY_AND; protected $predicates = array(); public function __construct(array $predicates = null, $defaultCombination = self::COMBINED_BY_AND) { $this->defaultCombination = $defaultCombination; if ($predicates) { foreach ($predicates as $predicate) { $this->addPredicate($predicate); } } } public function addPredicate(PredicateInterface $predicate, $combination = null) { if ($combination === null || !in_array($combination, array(self::OP_AND, self::OP_OR))) { $combination = $this->defaultCombination; } if ($combination == self::OP_OR) { $this->orPredicate($predicate); return $this; } $this->andPredicate($predicate); return $this; } public function addPredicates($predicates, $combination = self::OP_AND) { if ($predicates === null) { throw new Exception\InvalidArgumentException('Predicate cannot be null'); } if ($predicates instanceof PredicateInterface) { $this->addPredicate($predicates, $combination); return $this; } if ($predicates instanceof \Closure) { $predicates($this); return $this; } if (is_string($predicates)) { $predicates = (strpos($predicates, Expression::PLACEHOLDER) !== false) ? new Expression($predicates) : new Literal($predicates); $this->addPredicate($predicates, $combination); return $this; } if (is_array($predicates)) { foreach ($predicates as $pkey => $pvalue) { if (is_string($pkey)) { if (strpos($pkey, '?') !== false) { $predicates = new Expression($pkey, $pvalue); } elseif ($pvalue === null) { $predicates = new IsNull($pkey, $pvalue); } elseif (is_array($pvalue)) { $predicates = new In($pkey, $pvalue); } elseif ($pvalue instanceof PredicateInterface) { throw new Exception\InvalidArgumentException( 'Using Predicate must not use string keys' ); } else { $predicates = new Operator($pkey, Operator::OP_EQ, $pvalue); } } elseif ($pvalue instanceof PredicateInterface) { $predicates = $pvalue; } else { $predicates = (strpos($pvalue, Expression::PLACEHOLDER) !== false) ? new Expression($pvalue) : new Literal($pvalue); } $this->addPredicate($predicates, $combination); } } return $this; } public function getPredicates() { return $this->predicates; } public function orPredicate(PredicateInterface $predicate) { $this->predicates[] = array(self::OP_OR, $predicate); return $this; } public function andPredicate(PredicateInterface $predicate) { $this->predicates[] = array(self::OP_AND, $predicate); return $this; } public function getExpressionData() { $parts = array(); for ($i = 0, $count = count($this->predicates); $i < $count; $i++) { $predicate = $this->predicates[$i][1]; if ($predicate instanceof PredicateSet) { $parts[] = '('; } $parts = array_merge($parts, $predicate->getExpressionData()); if ($predicate instanceof PredicateSet) { $parts[] = ')'; } if (isset($this->predicates[$i+1])) { $parts[] = sprintf(' %s ', $this->predicates[$i+1][0]); } } return $parts; } public function count() { return count($this->predicates); } } } namespace Zend\Db\Sql\Predicate { use Zend\Db\Sql\Exception\RuntimeException; class Predicate extends PredicateSet { protected $unnest = null; protected $nextPredicateCombineOperator = null; public function nest() { $predicateSet = new Predicate(); $predicateSet->setUnnest($this); $this->addPredicate($predicateSet, ($this->nextPredicateCombineOperator) ?: $this->defaultCombination); $this->nextPredicateCombineOperator = null; return $predicateSet; } public function setUnnest(Predicate $predicate) { $this->unnest = $predicate; } public function unnest() { if ($this->unnest == null) { throw new RuntimeException('Not nested'); } $unnset = $this->unnest; $this->unnest = null; return $unnset; } public function equalTo($left, $right, $leftType = self::TYPE_IDENTIFIER, $rightType = self::TYPE_VALUE) { $this->addPredicate( new Operator($left, Operator::OPERATOR_EQUAL_TO, $right, $leftType, $rightType), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function notEqualTo($left, $right, $leftType = self::TYPE_IDENTIFIER, $rightType = self::TYPE_VALUE) { $this->addPredicate( new Operator($left, Operator::OPERATOR_NOT_EQUAL_TO, $right, $leftType, $rightType), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function lessThan($left, $right, $leftType = self::TYPE_IDENTIFIER, $rightType = self::TYPE_VALUE) { $this->addPredicate( new Operator($left, Operator::OPERATOR_LESS_THAN, $right, $leftType, $rightType), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function greaterThan($left, $right, $leftType = self::TYPE_IDENTIFIER, $rightType = self::TYPE_VALUE) { $this->addPredicate( new Operator($left, Operator::OPERATOR_GREATER_THAN, $right, $leftType, $rightType), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function lessThanOrEqualTo($left, $right, $leftType = self::TYPE_IDENTIFIER, $rightType = self::TYPE_VALUE) { $this->addPredicate( new Operator($left, Operator::OPERATOR_LESS_THAN_OR_EQUAL_TO, $right, $leftType, $rightType), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function greaterThanOrEqualTo($left, $right, $leftType = self::TYPE_IDENTIFIER, $rightType = self::TYPE_VALUE) { $this->addPredicate( new Operator($left, Operator::OPERATOR_GREATER_THAN_OR_EQUAL_TO, $right, $leftType, $rightType), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function like($identifier, $like) { $this->addPredicate( new Like($identifier, $like), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function notLike($identifier, $notLike) { $this->addPredicate( new NotLike($identifier, $notLike), ($this->nextPredicateCombineOperator) ? : $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function expression($expression, $parameters) { $this->addPredicate( new Expression($expression, $parameters), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function literal($literal) { if (func_num_args() >= 2) { $parameters = func_get_arg(1); $predicate = new Expression($literal, $parameters); } if (!isset($predicate)) { $predicate = new Literal($literal); } $this->addPredicate( $predicate, ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function isNull($identifier) { $this->addPredicate( new IsNull($identifier), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function isNotNull($identifier) { $this->addPredicate( new IsNotNull($identifier), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function in($identifier, $valueSet = null) { $this->addPredicate( new In($identifier, $valueSet), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function notIn($identifier, $valueSet = null) { $this->addPredicate( new NotIn($identifier, $valueSet), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function between($identifier, $minValue, $maxValue) { $this->addPredicate( new Between($identifier, $minValue, $maxValue), ($this->nextPredicateCombineOperator) ?: $this->defaultCombination ); $this->nextPredicateCombineOperator = null; return $this; } public function __get($name) { switch (strtolower($name)) { case 'or': $this->nextPredicateCombineOperator = self::OP_OR; break; case 'and': $this->nextPredicateCombineOperator = self::OP_AND; break; case 'nest': return $this->nest(); case 'unnest': return $this->unnest(); } return $this; } } } namespace Zend\Db\Sql { class Where extends Predicate\Predicate { } } namespace Zend\Db\Sql { class Having extends Predicate\Predicate { } } namespace Zend\Db\Sql\Ddl { use Zend\Db\Adapter\Platform\PlatformInterface; use Zend\Db\Adapter\Platform\Sql92 as AdapterSql92Platform; use Zend\Db\Sql\AbstractSql; class CreateTable extends AbstractSql implements SqlInterface { const COLUMNS = 'columns'; const CONSTRAINTS = 'constraints'; const TABLE = 'table'; protected $columns = array(); protected $constraints = array(); protected $isTemporary = false; protected $specifications = array( self::TABLE => 'CREATE %1$sTABLE %2$s (', self::COLUMNS => array( "\n    %1\$s" => array( array(1 => '%1$s', 'combinedby' => ",\n    ") ) ), self::CONSTRAINTS => array( "\n    %1\$s" => array( array(1 => '%1$s', 'combinedby' => ",\n    ") ) ), ); protected $table = ''; public function __construct($table = '', $isTemporary = false) { $this->table = $table; $this->setTemporary($isTemporary); } public function setTemporary($temporary) { $this->isTemporary = (bool) $temporary; return $this; } public function isTemporary() { return $this->isTemporary; } public function setTable($name) { $this->table = $name; return $this; } public function addColumn(Column\ColumnInterface $column) { $this->columns[] = $column; return $this; } public function addConstraint(Constraint\ConstraintInterface $constraint) { $this->constraints[] = $constraint; return $this; } public function getRawState($key = null) { $rawState = array( self::COLUMNS => $this->columns, self::CONSTRAINTS => $this->constraints, self::TABLE => $this->table, ); return (isset($key) && array_key_exists($key, $rawState)) ? $rawState[$key] : $rawState; } public function getSqlString(PlatformInterface $adapterPlatform = null) { $adapterPlatform = ($adapterPlatform) ?: new AdapterSql92Platform; $sqls = array(); $parameters = array(); foreach ($this->specifications as $name => $specification) { if (is_int($name)) { $sqls[] = $specification; continue; } $parameters[$name] = $this->{'process' . $name}( $adapterPlatform, null, null, $sqls, $parameters ); if ($specification && is_array($parameters[$name]) && ($parameters[$name] != array(array())) ) { $sqls[$name] = $this->createSqlFromSpecificationAndParameters( $specification, $parameters[$name] ); } if (stripos($name, 'table') === false && $parameters[$name] !== array(array()) ) { $sqls[] = ",\n"; } } if (count($sqls) > 2) { array_pop($sqls); } $sql = implode('', $sqls) . "\n)"; return $sql; } protected function processTable(PlatformInterface $adapterPlatform = null) { $ret = array(); if ($this->isTemporary) { $ret[] = 'TEMPORARY '; } else { $ret[] = ''; } $ret[] = $adapterPlatform->quoteIdentifier($this->table); return $ret; } protected function processColumns(PlatformInterface $adapterPlatform = null) { $sqls = array(); foreach ($this->columns as $column) { $sqls[] = $this->processExpression($column, $adapterPlatform)->getSql(); } return array($sqls); } protected function processConstraints(PlatformInterface $adapterPlatform = null) { $sqls = array(); foreach ($this->constraints as $constraint) { $sqls[] = $this->processExpression($constraint, $adapterPlatform)->getSql(); } return array($sqls); } } } namespace Zend\Db\Sql\Platform\Mysql\Ddl { use Zend\Db\Adapter\Platform\PlatformInterface; use Zend\Db\Sql\Ddl\CreateTable; use Zend\Db\Sql\Platform\PlatformDecoratorInterface; class CreateTableDecorator extends CreateTable implements PlatformDecoratorInterface { protected $createTable; public function setSubject($subject) { $this->createTable = $subject; } public function getSqlString(PlatformInterface $platform = null) { foreach (get_object_vars($this->createTable) as $name => $value) { $this->{$name} = $value; } return parent::getSqlString($platform); } protected function processColumns(PlatformInterface $platform = null) { $sqls = array(); foreach ($this->columns as $i => $column) { $stmtContainer = $this->processExpression($column, $platform); $sql = $stmtContainer->getSql(); $columnOptions = $column->getOptions(); foreach ($columnOptions as $coName => $coValue) { switch (strtolower(str_replace(array('-', '_', ' '), '', $coName))) { case 'identity': case 'serial': case 'autoincrement': $sql .= ' AUTO_INCREMENT'; break; case 'comment': $sql .= ' COMMENT \'' . $coValue . '\''; break; case 'columnformat': case 'format': $sql .= ' COLUMN_FORMAT ' . strtoupper($coValue); break; case 'storage': $sql .= ' STORAGE ' . strtoupper($coValue); break; } } $stmtContainer->setSql($sql); $sqls[$i] = $stmtContainer; } return array($sqls); } } } namespace Zend\Mvc\Controller\Plugin { use Zend\Stdlib\DispatchableInterface as Dispatchable; abstract class AbstractPlugin implements PluginInterface { protected $controller; public function setController(Dispatchable $controller) { $this->controller = $controller; } public function getController() { return $this->controller; } } } namespace Zend\Mvc\Controller\Plugin { use Zend\Mvc\Exception\RuntimeException; use Zend\Mvc\InjectApplicationEventInterface; class Params extends AbstractPlugin { public function __invoke($param = null, $default = null) { if ($param === null) { return $this; } return $this->fromRoute($param, $default); } public function fromFiles($name = null, $default = null) { if ($name === null) { return $this->getController()->getRequest()->getFiles($name, $default)->toArray(); } return $this->getController()->getRequest()->getFiles($name, $default); } public function fromHeader($header = null, $default = null) { if ($header === null) { return $this->getController()->getRequest()->getHeaders($header, $default)->toArray(); } return $this->getController()->getRequest()->getHeaders($header, $default); } public function fromPost($param = null, $default = null) { if ($param === null) { return $this->getController()->getRequest()->getPost($param, $default)->toArray(); } return $this->getController()->getRequest()->getPost($param, $default); } public function fromQuery($param = null, $default = null) { if ($param === null) { return $this->getController()->getRequest()->getQuery($param, $default)->toArray(); } return $this->getController()->getRequest()->getQuery($param, $default); } public function fromRoute($param = null, $default = null) { $controller = $this->getController(); if (!$controller instanceof InjectApplicationEventInterface) { throw new RuntimeException( 'Controllers must implement Zend\Mvc\InjectApplicationEventInterface to use this plugin.' ); } if ($param === null) { return $controller->getEvent()->getRouteMatch()->getParams(); } return $controller->getEvent()->getRouteMatch()->getParam($param, $default); } } } namespace Zend\Db\Sql\Predicate { class IsNull implements PredicateInterface { protected $specification = '%1$s IS NULL'; protected $identifier; public function __construct($identifier = null) { if ($identifier) { $this->setIdentifier($identifier); } } public function setIdentifier($identifier) { $this->identifier = $identifier; return $this; } public function getIdentifier() { return $this->identifier; } public function setSpecification($specification) { $this->specification = $specification; return $this; } public function getSpecification() { return $this->specification; } public function getExpressionData() { return array(array( $this->getSpecification(), array($this->identifier), array(self::TYPE_IDENTIFIER), )); } } } namespace Zend\Db\Adapter { use ArrayAccess; use Countable; use Iterator; class ParameterContainer implements Iterator, ArrayAccess, Countable { const TYPE_AUTO = 'auto'; const TYPE_NULL = 'null'; const TYPE_DOUBLE = 'double'; const TYPE_INTEGER = 'integer'; const TYPE_BINARY = 'binary'; const TYPE_STRING = 'string'; const TYPE_LOB = 'lob'; protected $data = array(); protected $positions = array(); protected $errata = array(); public function __construct(array $data = array()) { if ($data) { $this->setFromArray($data); } } public function offsetExists($name) { return (isset($this->data[$name])); } public function offsetGet($name) { return (isset($this->data[$name])) ? $this->data[$name] : null; } public function offsetSetReference($name, $from) { $this->data[$name] =& $this->data[$from]; } public function offsetSet($name, $value, $errata = null) { $position = false; if (is_int($name)) { if (isset($this->positions[$name])) { $position = $name; $name = $this->positions[$name]; } else { $name = (string) $name; } } elseif (is_string($name)) { $position = array_key_exists($name, $this->data); } elseif ($name === null) { $name = (string) count($this->data); } else { throw new Exception\InvalidArgumentException('Keys must be string, integer or null'); } if ($position === false) { $this->positions[] = $name; } $this->data[$name] = $value; if ($errata) { $this->offsetSetErrata($name, $errata); } } public function offsetUnset($name) { if (is_int($name) && isset($this->positions[$name])) { $name = $this->positions[$name]; } unset($this->data[$name]); return $this; } public function setFromArray(Array $data) { foreach ($data as $n => $v) { $this->offsetSet($n, $v); } return $this; } public function offsetSetErrata($name, $errata) { if (is_int($name)) { $name = $this->positions[$name]; } $this->errata[$name] = $errata; } public function offsetGetErrata($name) { if (is_int($name)) { $name = $this->positions[$name]; } if (!array_key_exists($name, $this->data)) { throw new Exception\InvalidArgumentException('Data does not exist for this name/position'); } return $this->errata[$name]; } public function offsetHasErrata($name) { if (is_int($name)) { $name = $this->positions[$name]; } return (isset($this->errata[$name])); } public function offsetUnsetErrata($name) { if (is_int($name)) { $name = $this->positions[$name]; } if (!array_key_exists($name, $this->errata)) { throw new Exception\InvalidArgumentException('Data does not exist for this name/position'); } $this->errata[$name] = null; } public function getErrataIterator() { return new \ArrayIterator($this->errata); } public function getNamedArray() { return $this->data; } public function getPositionalArray() { return array_values($this->data); } public function count() { return count($this->data); } public function current() { return current($this->data); } public function next() { return next($this->data); } public function key() { return key($this->data); } public function valid() { return (current($this->data) !== false); } public function rewind() { reset($this->data); } public function merge($parameters) { if (!is_array($parameters) && !$parameters instanceof ParameterContainer) { throw new Exception\InvalidArgumentException('$parameters must be an array or an instance of ParameterContainer'); } if (count($parameters) == 0) { return $this; } if ($parameters instanceof ParameterContainer) { $parameters = $parameters->getNamedArray(); } foreach ($parameters as $key => $value) { if (is_int($key)) { $key = null; } $this->offsetSet($key, $value); } return $this; } } } namespace Zend\Db\Adapter { class StatementContainer implements StatementContainerInterface { protected $sql = ''; protected $parameterContainer = null; public function __construct($sql = null, ParameterContainer $parameterContainer = null) { if ($sql) { $this->setSql($sql); } $this->parameterContainer = ($parameterContainer) ?: new ParameterContainer; } public function setSql($sql) { $this->sql = $sql; return $this; } public function getSql() { return $this->sql; } public function setParameterContainer(ParameterContainer $parameterContainer) { $this->parameterContainer = $parameterContainer; return $this; } public function getParameterContainer() { return $this->parameterContainer; } } } namespace Zend\View\Helper { use Traversable; use Zend\Mvc\ModuleRouteListener; use Zend\Mvc\Router\RouteMatch; use Zend\Mvc\Router\RouteStackInterface; use Zend\View\Exception; class Url extends AbstractHelper { protected $router; protected $routeMatch; public function __invoke($name = null, $params = array(), $options = array(), $reuseMatchedParams = false) { if (null === $this->router) { throw new Exception\RuntimeException('No RouteStackInterface instance provided'); } if (3 == func_num_args() && is_bool($options)) { $reuseMatchedParams = $options; $options = array(); } if ($name === null) { if ($this->routeMatch === null) { throw new Exception\RuntimeException('No RouteMatch instance provided'); } $name = $this->routeMatch->getMatchedRouteName(); if ($name === null) { throw new Exception\RuntimeException('RouteMatch does not contain a matched route name'); } } if (!is_array($params)) { if (!$params instanceof Traversable) { throw new Exception\InvalidArgumentException( 'Params is expected to be an array or a Traversable object' ); } $params = iterator_to_array($params); } if ($reuseMatchedParams && $this->routeMatch !== null) { $routeMatchParams = $this->routeMatch->getParams(); if (isset($routeMatchParams[ModuleRouteListener::ORIGINAL_CONTROLLER])) { $routeMatchParams['controller'] = $routeMatchParams[ModuleRouteListener::ORIGINAL_CONTROLLER]; unset($routeMatchParams[ModuleRouteListener::ORIGINAL_CONTROLLER]); } if (isset($routeMatchParams[ModuleRouteListener::MODULE_NAMESPACE])) { unset($routeMatchParams[ModuleRouteListener::MODULE_NAMESPACE]); } $params = array_merge($routeMatchParams, $params); } $options['name'] = $name; return $this->router->assemble($params, $options); } public function setRouter(RouteStackInterface $router) { $this->router = $router; return $this; } public function setRouteMatch(RouteMatch $routeMatch) { $this->routeMatch = $routeMatch; return $this; } } } namespace Zend\View\Helper\Escaper { use Zend\Escaper; use Zend\View\Exception; use Zend\View\Helper; abstract class AbstractHelper extends \Zend\View\Helper\AbstractHelper { const RECURSE_NONE = 0x00; const RECURSE_ARRAY = 0x01; const RECURSE_OBJECT = 0x02; protected $encoding = 'UTF-8'; protected $escaper = null; public function __invoke($value, $recurse = self::RECURSE_NONE) { if (is_string($value)) { return $this->escape($value); } if (is_array($value)) { if (!(self::RECURSE_ARRAY & $recurse)) { throw new Exception\InvalidArgumentException( 'Array provided to Escape helper, but flags do not allow recursion' ); } foreach ($value as $k => $v) { $value[$k] = $this->__invoke($v, $recurse); } return $value; } if (is_object($value)) { if (!(self::RECURSE_OBJECT & $recurse)) { if (method_exists($value, '__toString')) { return $this->escape((string) $value); } throw new Exception\InvalidArgumentException( 'Object provided to Escape helper, but flags do not allow recursion' ); } if (method_exists($value, 'toArray')) { return $this->__invoke($value->toArray(), $recurse | self::RECURSE_ARRAY); } return $this->__invoke((array) $value, $recurse | self::RECURSE_ARRAY); } return $value; } abstract protected function escape($value); public function setEncoding($encoding) { if (null !== $this->escaper) { throw new Exception\InvalidArgumentException( 'Character encoding settings cannot be changed once the Helper has been used or ' . ' if a Zend\Escaper\Escaper object (with preset encoding option) is set.' ); } $this->encoding = $encoding; return $this; } public function getEncoding() { return $this->encoding; } public function setEscaper(Escaper\Escaper $escaper) { $this->escaper = $escaper; $this->encoding = $escaper->getEncoding(); return $this; } public function getEscaper() { if (null === $this->escaper) { $this->setEscaper(new Escaper\Escaper($this->getEncoding())); } return $this->escaper; } } } namespace Zend\View\Helper { class EscapeHtml extends Escaper\AbstractHelper { protected function escape($value) { return $this->getEscaper()->escapeHtml($value); } } } namespace Zend\Escaper { class Escaper { protected static $htmlNamedEntityMap = array( 34 => 'quot', 38 => 'amp', 60 => 'lt', 62 => 'gt', ); protected $encoding = 'utf-8'; protected $htmlSpecialCharsFlags = ENT_QUOTES; protected $htmlAttrMatcher; protected $jsMatcher; protected $cssMatcher; protected $supportedEncodings = array( 'iso-8859-1', 'iso8859-1', 'iso-8859-5', 'iso8859-5', 'iso-8859-15', 'iso8859-15', 'utf-8', 'cp866', 'ibm866', '866', 'cp1251', 'windows-1251', 'win-1251', '1251', 'cp1252', 'windows-1252', '1252', 'koi8-r', 'koi8-ru', 'koi8r', 'big5', '950', 'gb2312', '936', 'big5-hkscs', 'shift_jis', 'sjis', 'sjis-win', 'cp932', '932', 'euc-jp', 'eucjp', 'eucjp-win', 'macroman' ); public function __construct($encoding = null) { if ($encoding !== null) { $encoding = (string) $encoding; if ($encoding === '') { throw new Exception\InvalidArgumentException( get_class($this) . ' constructor parameter does not allow a blank value' ); } $encoding = strtolower($encoding); if (!in_array($encoding, $this->supportedEncodings)) { throw new Exception\InvalidArgumentException( 'Value of \'' . $encoding . '\' passed to ' . get_class($this) . ' constructor parameter is invalid. Provide an encoding supported by htmlspecialchars()' ); } $this->encoding = $encoding; } if (defined('ENT_SUBSTITUTE')) { $this->htmlSpecialCharsFlags|= ENT_SUBSTITUTE; } $this->htmlAttrMatcher = array($this, 'htmlAttrMatcher'); $this->jsMatcher = array($this, 'jsMatcher'); $this->cssMatcher = array($this, 'cssMatcher'); } public function getEncoding() { return $this->encoding; } public function escapeHtml($string) { $result = htmlspecialchars($string, $this->htmlSpecialCharsFlags, $this->encoding); return $result; } public function escapeHtmlAttr($string) { $string = $this->toUtf8($string); if ($string === '' || ctype_digit($string)) { return $string; } $result = preg_replace_callback('/[^a-z0-9,\.\-_]/iSu', $this->htmlAttrMatcher, $string); return $this->fromUtf8($result); } public function escapeJs($string) { $string = $this->toUtf8($string); if ($string === '' || ctype_digit($string)) { return $string; } $result = preg_replace_callback('/[^a-z0-9,\._]/iSu', $this->jsMatcher, $string); return $this->fromUtf8($result); } public function escapeUrl($string) { return rawurlencode($string); } public function escapeCss($string) { $string = $this->toUtf8($string); if ($string === '' || ctype_digit($string)) { return $string; } $result = preg_replace_callback('/[^a-z0-9]/iSu', $this->cssMatcher, $string); return $this->fromUtf8($result); } protected function htmlAttrMatcher($matches) { $chr = $matches[0]; $ord = ord($chr); if (($ord <= 0x1f && $chr != "\t" && $chr != "\n" && $chr != "\r") || ($ord >= 0x7f && $ord <= 0x9f) ) { return '&#xFFFD;'; } if (strlen($chr) > 1) { $chr = $this->convertEncoding($chr, 'UTF-16BE', 'UTF-8'); } $hex = bin2hex($chr); $ord = hexdec($hex); if (isset(static::$htmlNamedEntityMap[$ord])) { return '&' . static::$htmlNamedEntityMap[$ord] . ';'; } if ($ord > 255) { return sprintf('&#x%04X;', $ord); } return sprintf('&#x%02X;', $ord); } protected function jsMatcher($matches) { $chr = $matches[0]; if (strlen($chr) == 1) { return sprintf('\\x%02X', ord($chr)); } $chr = $this->convertEncoding($chr, 'UTF-16BE', 'UTF-8'); return sprintf('\\u%04s', strtoupper(bin2hex($chr))); } protected function cssMatcher($matches) { $chr = $matches[0]; if (strlen($chr) == 1) { $ord = ord($chr); } else { $chr = $this->convertEncoding($chr, 'UTF-16BE', 'UTF-8'); $ord = hexdec(bin2hex($chr)); } return sprintf('\\%X ', $ord); } protected function toUtf8($string) { if ($this->getEncoding() === 'utf-8') { $result = $string; } else { $result = $this->convertEncoding($string, 'UTF-8', $this->getEncoding()); } if (!$this->isUtf8($result)) { throw new Exception\RuntimeException(sprintf( 'String to be escaped was not valid UTF-8 or could not be converted: %s', $result )); } return $result; } protected function fromUtf8($string) { if ($this->getEncoding() === 'utf-8') { return $string; } return $this->convertEncoding($string, $this->getEncoding(), 'UTF-8'); } protected function isUtf8($string) { return ($string === '' || preg_match('/^./su', $string)); } protected function convertEncoding($string, $to, $from) { if (function_exists('iconv')) { $result = iconv($from, $to, $string); } elseif (function_exists('mb_convert_encoding')) { $result = mb_convert_encoding($string, $to, $from); } else { throw new Exception\RuntimeException( get_class($this) . ' requires either the iconv or mbstring extension to be installed' . ' when escaping for non UTF-8 strings.' ); } if ($result === false) { return ''; } return $result; } } } namespace Zend\Filter { use Traversable; use Zend\Stdlib\StringUtils; abstract class AbstractFilter implements FilterInterface { protected $options = array(); public static function hasPcreUnicodeSupport() { return StringUtils::hasPcreUnicodeSupport(); } public function setOptions($options) { if (!is_array($options) && !$options instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( '"%s" expects an array or Traversable; received "%s"', __METHOD__, (is_object($options) ? get_class($options) : gettype($options)) )); } foreach ($options as $key => $value) { $setter = 'set' . str_replace(' ', '', ucwords(str_replace('_', ' ', $key))); if (method_exists($this, $setter)) { $this->{$setter}($value); } elseif (array_key_exists($key, $this->options)) { $this->options[$key] = $value; } else { throw new Exception\InvalidArgumentException(sprintf( 'The option "%s" does not have a matching %s setter method or options[%s] array key', $key, $setter, $key )); } } return $this; } public function getOptions() { return $this->options; } public function __invoke($value) { return $this->filter($value); } protected static function isOptions($options) { return (is_array($options) || $options instanceof Traversable); } } } namespace Zend\Filter { use Countable; use Traversable; use Zend\Stdlib\PriorityQueue; class FilterChain extends AbstractFilter implements Countable { const DEFAULT_PRIORITY = 1000; protected $plugins; protected $filters; public function __construct($options = null) { $this->filters = new PriorityQueue(); if (null !== $options) { $this->setOptions($options); } } public function setOptions($options) { if (!is_array($options) && !$options instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Expected array or Traversable; received "%s"', (is_object($options) ? get_class($options) : gettype($options)) )); } foreach ($options as $key => $value) { switch (strtolower($key)) { case 'callbacks': foreach ($value as $spec) { $callback = isset($spec['callback']) ? $spec['callback'] : false; $priority = isset($spec['priority']) ? $spec['priority'] : static::DEFAULT_PRIORITY; if ($callback) { $this->attach($callback, $priority); } } break; case 'filters': foreach ($value as $spec) { $name = isset($spec['name']) ? $spec['name'] : false; $options = isset($spec['options']) ? $spec['options'] : array(); $priority = isset($spec['priority']) ? $spec['priority'] : static::DEFAULT_PRIORITY; if ($name) { $this->attachByName($name, $options, $priority); } } break; default: break; } } return $this; } public function count() { return count($this->filters); } public function getPluginManager() { if (!$this->plugins) { $this->setPluginManager(new FilterPluginManager()); } return $this->plugins; } public function setPluginManager(FilterPluginManager $plugins) { $this->plugins = $plugins; return $this; } public function plugin($name, array $options = array()) { $plugins = $this->getPluginManager(); return $plugins->get($name, $options); } public function attach($callback, $priority = self::DEFAULT_PRIORITY) { if (!is_callable($callback)) { if (!$callback instanceof FilterInterface) { throw new Exception\InvalidArgumentException(sprintf( 'Expected a valid PHP callback; received "%s"', (is_object($callback) ? get_class($callback) : gettype($callback)) )); } $callback = array($callback, 'filter'); } $this->filters->insert($callback, $priority); return $this; } public function attachByName($name, $options = array(), $priority = self::DEFAULT_PRIORITY) { if (!is_array($options)) { $options = (array) $options; } elseif (empty($options)) { $options = null; } $filter = $this->getPluginManager()->get($name, $options); return $this->attach($filter, $priority); } public function merge(FilterChain $filterChain) { foreach ($filterChain->filters->toArray(PriorityQueue::EXTR_BOTH) as $item) { $this->attach($item['data'], $item['priority']); } return $this; } public function getFilters() { return $this->filters; } public function filter($value) { $chain = clone $this->filters; $valueFiltered = $value; foreach ($chain as $filter) { $valueFiltered = call_user_func($filter, $valueFiltered); } return $valueFiltered; } public function __clone() { $this->filters = clone $this->filters; } public function __sleep() { return array('filters'); } } } namespace Zend\View\Helper { use ArrayObject; use Zend\View\Exception; class Doctype extends AbstractHelper { const XHTML11 = 'XHTML11'; const XHTML1_STRICT = 'XHTML1_STRICT'; const XHTML1_TRANSITIONAL = 'XHTML1_TRANSITIONAL'; const XHTML1_FRAMESET = 'XHTML1_FRAMESET'; const XHTML1_RDFA = 'XHTML1_RDFA'; const XHTML1_RDFA11 = 'XHTML1_RDFA11'; const XHTML_BASIC1 = 'XHTML_BASIC1'; const XHTML5 = 'XHTML5'; const HTML4_STRICT = 'HTML4_STRICT'; const HTML4_LOOSE = 'HTML4_LOOSE'; const HTML4_FRAMESET = 'HTML4_FRAMESET'; const HTML5 = 'HTML5'; const CUSTOM_XHTML = 'CUSTOM_XHTML'; const CUSTOM = 'CUSTOM'; protected $defaultDoctype = self::HTML4_LOOSE; protected $registry; protected static $registeredDoctypes; public function __construct() { if (null === static::$registeredDoctypes) { static::registerDefaultDoctypes(); $this->setDoctype($this->defaultDoctype); } $this->registry = static::$registeredDoctypes; } public function __invoke($doctype = null) { if (null !== $doctype) { switch ($doctype) { case self::XHTML11: case self::XHTML1_STRICT: case self::XHTML1_TRANSITIONAL: case self::XHTML1_FRAMESET: case self::XHTML_BASIC1: case self::XHTML1_RDFA: case self::XHTML1_RDFA11: case self::XHTML5: case self::HTML4_STRICT: case self::HTML4_LOOSE: case self::HTML4_FRAMESET: case self::HTML5: $this->setDoctype($doctype); break; default: if (substr($doctype, 0, 9) != '<!DOCTYPE') { throw new Exception\DomainException('The specified doctype is malformed'); } if (stristr($doctype, 'xhtml')) { $type = self::CUSTOM_XHTML; } else { $type = self::CUSTOM; } $this->setDoctype($type); $this->registry['doctypes'][$type] = $doctype; break; } } return $this; } public function __toString() { $doctypes = $this->getDoctypes(); return $doctypes[$this->getDoctype()]; } protected static function registerDefaultDoctypes() { static::$registeredDoctypes = new ArrayObject(array( 'doctypes' => array( self::XHTML11 => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">', self::XHTML1_STRICT => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">', self::XHTML1_TRANSITIONAL => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">', self::XHTML1_FRAMESET => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">', self::XHTML1_RDFA => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.0//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd">', self::XHTML1_RDFA11 => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.1//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd">', self::XHTML_BASIC1 => '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd">', self::XHTML5 => '<!DOCTYPE html>', self::HTML4_STRICT => '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">', self::HTML4_LOOSE => '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">', self::HTML4_FRAMESET => '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">', self::HTML5 => '<!DOCTYPE html>', ), )); } public static function unsetDoctypeRegistry() { static::$registeredDoctypes = null; } public function setDoctype($doctype) { $this->registry['doctype'] = $doctype; return $this; } public function getDoctype() { if (!isset($this->registry['doctype'])) { $this->setDoctype($this->defaultDoctype); } return $this->registry['doctype']; } public function getDoctypes() { return $this->registry['doctypes']; } public function isXhtml() { return (stristr($this->getDoctype(), 'xhtml') ? true : false); } public function isHtml5() { return (stristr($this->__invoke(), '<!DOCTYPE html>') ? true : false); } public function isRdfa() { return ($this->isHtml5() || stristr($this->getDoctype(), 'rdfa') ? true : false); } } } namespace Zend\View\Helper\Placeholder\Container { use ArrayAccess; use Countable; use IteratorAggregate; use Zend\Escaper\Escaper; use Zend\View\Exception; use Zend\View\Helper\AbstractHelper; use Zend\View\Renderer\RendererInterface; abstract class AbstractStandalone extends AbstractHelper implements IteratorAggregate, Countable, ArrayAccess { protected $autoEscape = true; protected $container; protected $containerClass = 'Zend\View\Helper\Placeholder\Container'; protected $escapers = array(); public function __construct() { $this->setContainer($this->getContainer()); } public function __call($method, $args) { $container = $this->getContainer(); if (method_exists($container, $method)) { $return = call_user_func_array(array($container, $method), $args); if ($return === $container) { return $this; } return $return; } throw new Exception\BadMethodCallException('Method "' . $method . '" does not exist'); } public function __set($key, $value) { $container = $this->getContainer(); $container[$key] = $value; } public function __get($key) { $container = $this->getContainer(); if (isset($container[$key])) { return $container[$key]; } return null; } public function __isset($key) { $container = $this->getContainer(); return isset($container[$key]); } public function __unset($key) { $container = $this->getContainer(); if (isset($container[$key])) { unset($container[$key]); } } public function __toString() { return $this->toString(); } public function toString() { return $this->getContainer()->toString(); } protected function escape($string) { if ($this->getView() instanceof RendererInterface && method_exists($this->getView(), 'getEncoding') ) { $escaper = $this->getView()->plugin('escapeHtml'); return $escaper((string) $string); } return $this->getEscaper()->escapeHtml((string) $string); } public function setAutoEscape($autoEscape = true) { $this->autoEscape = ($autoEscape) ? true : false; return $this; } public function getAutoEscape() { return $this->autoEscape; } public function setContainer(AbstractContainer $container) { $this->container = $container; return $this; } public function getContainer() { if (!$this->container instanceof AbstractContainer) { $this->container = new $this->containerClass(); } return $this->container; } public function deleteContainer() { if (null != $this->container) { $this->container = null; return true; } return false; } public function setContainerClass($name) { if (!class_exists($name)) { throw new Exception\DomainException( sprintf('%s expects a valid container class name; received "%s", which did not resolve', __METHOD__, $name )); } if (!in_array('Zend\View\Helper\Placeholder\Container\AbstractContainer', class_parents($name))) { throw new Exception\InvalidArgumentException('Invalid Container class specified'); } $this->containerClass = $name; return $this; } public function getContainerClass() { return $this->containerClass; } public function setEscaper(Escaper $escaper) { $encoding = $escaper->getEncoding(); $this->escapers[$encoding] = $escaper; return $this; } public function getEscaper($enc = 'UTF-8') { $enc = strtolower($enc); if (!isset($this->escapers[$enc])) { $this->setEscaper(new Escaper($enc)); } return $this->escapers[$enc]; } public function count() { $container = $this->getContainer(); return count($container); } public function offsetExists($offset) { return $this->getContainer()->offsetExists($offset); } public function offsetGet($offset) { return $this->getContainer()->offsetGet($offset); } public function offsetSet($offset, $value) { return $this->getContainer()->offsetSet($offset, $value); } public function offsetUnset($offset) { return $this->getContainer()->offsetUnset($offset); } public function getIterator() { return $this->getContainer()->getIterator(); } } } namespace Zend\View\Helper { use Zend\I18n\Translator\TranslatorInterface as Translator; use Zend\I18n\Translator\TranslatorAwareInterface; use Zend\View\Exception; class HeadTitle extends Placeholder\Container\AbstractStandalone implements TranslatorAwareInterface { protected $regKey = 'Zend_View_Helper_HeadTitle'; protected $defaultAttachOrder = null; protected $translator; protected $translatorTextDomain = 'default'; protected $translatorEnabled = true; public function __invoke($title = null, $setType = null) { if (null === $setType) { $setType = (null === $this->getDefaultAttachOrder()) ? Placeholder\Container\AbstractContainer::APPEND : $this->getDefaultAttachOrder(); } $title = (string) $title; if ($title !== '') { if ($setType == Placeholder\Container\AbstractContainer::SET) { $this->set($title); } elseif ($setType == Placeholder\Container\AbstractContainer::PREPEND) { $this->prepend($title); } else { $this->append($title); } } return $this; } public function toString($indent = null) { $indent = (null !== $indent) ? $this->getWhitespace($indent) : $this->getIndent(); $output = $this->renderTitle(); return $indent . '<title>' . $output . '</title>'; } public function renderTitle() { $items = array(); if (null !== ($translator = $this->getTranslator())) { foreach ($this as $item) { $items[] = $translator->translate( $item, $this->getTranslatorTextDomain() ); } } else { foreach ($this as $item) { $items[] = $item; } } $separator = $this->getSeparator(); $output = ''; $prefix = $this->getPrefix(); if ($prefix) { $output .= $prefix; } $output .= implode($separator, $items); $postfix = $this->getPostfix(); if ($postfix) { $output .= $postfix; } $output = ($this->autoEscape) ? $this->escape($output) : $output; return $output; } public function setDefaultAttachOrder($setType) { if (!in_array($setType, array( Placeholder\Container\AbstractContainer::APPEND, Placeholder\Container\AbstractContainer::SET, Placeholder\Container\AbstractContainer::PREPEND ))) { throw new Exception\DomainException( "You must use a valid attach order: 'PREPEND', 'APPEND' or 'SET'" ); } $this->defaultAttachOrder = $setType; return $this; } public function getDefaultAttachOrder() { return $this->defaultAttachOrder; } public function setTranslator(Translator $translator = null, $textDomain = null) { $this->translator = $translator; if (null !== $textDomain) { $this->setTranslatorTextDomain($textDomain); } return $this; } public function getTranslator() { if (! $this->isTranslatorEnabled()) { return null; } return $this->translator; } public function hasTranslator() { return (bool) $this->getTranslator(); } public function setTranslatorEnabled($enabled = true) { $this->translatorEnabled = (bool) $enabled; return $this; } public function isTranslatorEnabled() { return $this->translatorEnabled; } public function setTranslatorTextDomain($textDomain = 'default') { $this->translatorTextDomain = $textDomain; return $this; } public function getTranslatorTextDomain() { return $this->translatorTextDomain; } } } namespace Zend\View\Helper\Placeholder\Container { use ArrayObject; use Zend\View\Exception; abstract class AbstractContainer extends ArrayObject { const SET = 'SET'; const APPEND = 'APPEND'; const PREPEND = 'PREPEND'; protected $captureKey; protected $captureLock = false; protected $captureType; protected $indent = ''; protected $postfix = ''; protected $prefix = ''; protected $separator = ''; public function __construct() { parent::__construct(array(), parent::ARRAY_AS_PROPS); } public function __toString() { return $this->toString(); } public function toString($indent = null) { $indent = ($indent !== null) ? $this->getWhitespace($indent) : $this->getIndent(); $items = $this->getArrayCopy(); $return = $indent . $this->getPrefix() . implode($this->getSeparator(), $items) . $this->getPostfix(); $return = preg_replace("/(\r\n?|\n)/", '$1' . $indent, $return); return $return; } public function captureStart($type = AbstractContainer::APPEND, $key = null) { if ($this->captureLock) { throw new Exception\RuntimeException( 'Cannot nest placeholder captures for the same placeholder' ); } $this->captureLock = true; $this->captureType = $type; if ((null !== $key) && is_scalar($key)) { $this->captureKey = (string) $key; } ob_start(); } public function captureEnd() { $data = ob_get_clean(); $key = null; $this->captureLock = false; if (null !== $this->captureKey) { $key = $this->captureKey; } switch ($this->captureType) { case self::SET: if (null !== $key) { $this[$key] = $data; } else { $this->exchangeArray(array($data)); } break; case self::PREPEND: if (null !== $key) { $array = array($key => $data); $values = $this->getArrayCopy(); $final = $array + $values; $this->exchangeArray($final); } else { $this->prepend($data); } break; case self::APPEND: default: if (null !== $key) { if (empty($this[$key])) { $this[$key] = $data; } else { $this[$key] .= $data; } } else { $this[$this->nextIndex()] = $data; } break; } } public function getKeys() { $array = $this->getArrayCopy(); return array_keys($array); } public function getValue() { if (1 == count($this)) { $keys = $this->getKeys(); $key = array_shift($keys); return $this[$key]; } return $this->getArrayCopy(); } public function getWhitespace($indent) { if (is_int($indent)) { $indent = str_repeat(' ', $indent); } return (string) $indent; } public function set($value) { $this->exchangeArray(array($value)); return $this; } public function prepend($value) { $values = $this->getArrayCopy(); array_unshift($values, $value); $this->exchangeArray($values); return $this; } public function append($value) { parent::append($value); return $this; } public function nextIndex() { $keys = $this->getKeys(); if (0 == count($keys)) { return 0; } return $nextIndex = max($keys) + 1; } public function setIndent($indent) { $this->indent = $this->getWhitespace($indent); return $this; } public function getIndent() { return $this->indent; } public function setPostfix($postfix) { $this->postfix = (string) $postfix; return $this; } public function getPostfix() { return $this->postfix; } public function setPrefix($prefix) { $this->prefix = (string) $prefix; return $this; } public function getPrefix() { return $this->prefix; } public function setSeparator($separator) { $this->separator = (string) $separator; return $this; } public function getSeparator() { return $this->separator; } } } namespace Zend\View\Helper\Placeholder { class Container extends Container\AbstractContainer { } } namespace Zend\I18n\Translator { use Zend\I18n\Exception; use Zend\ServiceManager\AbstractPluginManager; class LoaderPluginManager extends AbstractPluginManager { protected $invokableClasses = array( 'gettext' => 'Zend\I18n\Translator\Loader\Gettext', 'ini' => 'Zend\I18n\Translator\Loader\Ini', 'phparray' => 'Zend\I18n\Translator\Loader\PhpArray', ); public function validatePlugin($plugin) { if ($plugin instanceof Loader\FileLoaderInterface || $plugin instanceof Loader\RemoteLoaderInterface) { return; } throw new Exception\RuntimeException(sprintf( 'Plugin of type %s is invalid; must implement %s\Loader\FileLoaderInterface or %s\Loader\RemoteLoaderInterface', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } } namespace Zend\I18n\Translator\Loader { abstract class AbstractFileLoader implements FileLoaderInterface { protected $useIncludePath = false; public function setUseIncludePath($flag = true) { $this->useIncludePath = (bool) $flag; return $this; } public function useIncludePath() { return $this->useIncludePath; } protected function resolveFile($filename) { if (!is_file($filename) || !is_readable($filename)) { if (!$this->useIncludePath()) { return false; } return $this->resolveViaIncludePath($filename); } return $filename; } protected function resolveViaIncludePath($filename) { $resolvedIncludePath = stream_resolve_include_path($filename); if (!$resolvedIncludePath || !is_file($resolvedIncludePath) || !is_readable($resolvedIncludePath)) { return false; } return $resolvedIncludePath; } } } namespace Zend\I18n\Translator\Loader { use Zend\I18n\Exception; use Zend\I18n\Translator\Plural\Rule as PluralRule; use Zend\I18n\Translator\TextDomain; use Zend\Stdlib\ErrorHandler; class Gettext extends AbstractFileLoader { protected $file; protected $littleEndian; public function load($locale, $filename) { $resolvedFile = $this->resolveFile($filename); if (!$resolvedFile) { throw new Exception\InvalidArgumentException(sprintf( 'Could not find or open file %s for reading', $filename )); } $textDomain = new TextDomain(); ErrorHandler::start(); $this->file = fopen($resolvedFile, 'rb'); $error = ErrorHandler::stop(); if (false === $this->file) { throw new Exception\InvalidArgumentException(sprintf( 'Could not open file %s for reading', $filename ), 0, $error); } $magic = fread($this->file, 4); if ($magic == "\x95\x04\x12\xde") { $this->littleEndian = false; } elseif ($magic == "\xde\x12\x04\x95") { $this->littleEndian = true; } else { fclose($this->file); throw new Exception\InvalidArgumentException(sprintf( '%s is not a valid gettext file', $filename )); } $majorRevision = ($this->readInteger() >> 16); if ($majorRevision !== 0 && $majorRevision !== 1) { fclose($this->file); throw new Exception\InvalidArgumentException(sprintf( '%s has an unknown major revision', $filename )); } $numStrings = $this->readInteger(); $originalStringTableOffset = $this->readInteger(); $translationStringTableOffset = $this->readInteger(); fseek($this->file, $originalStringTableOffset); $originalStringTable = $this->readIntegerList(2 * $numStrings); fseek($this->file, $translationStringTableOffset); $translationStringTable = $this->readIntegerList(2 * $numStrings); for ($current = 0; $current < $numStrings; $current++) { $sizeKey = $current * 2 + 1; $offsetKey = $current * 2 + 2; $originalStringSize = $originalStringTable[$sizeKey]; $originalStringOffset = $originalStringTable[$offsetKey]; $translationStringSize = $translationStringTable[$sizeKey]; $translationStringOffset = $translationStringTable[$offsetKey]; $originalString = array(''); if ($originalStringSize > 0) { fseek($this->file, $originalStringOffset); $originalString = explode("\0", fread($this->file, $originalStringSize)); } if ($translationStringSize > 0) { fseek($this->file, $translationStringOffset); $translationString = explode("\0", fread($this->file, $translationStringSize)); if (count($originalString) > 1 && count($translationString) > 1) { $textDomain[$originalString[0]] = $translationString; array_shift($originalString); foreach ($originalString as $string) { $textDomain[$string] = ''; } } else { $textDomain[$originalString[0]] = $translationString[0]; } } } if (array_key_exists('', $textDomain)) { $rawHeaders = explode("\n", trim($textDomain[''])); foreach ($rawHeaders as $rawHeader) { list($header, $content) = explode(':', $rawHeader, 2); if (trim(strtolower($header)) === 'plural-forms') { $textDomain->setPluralRule(PluralRule::fromString($content)); } } unset($textDomain['']); } fclose($this->file); return $textDomain; } protected function readInteger() { if ($this->littleEndian) { $result = unpack('Vint', fread($this->file, 4)); } else { $result = unpack('Nint', fread($this->file, 4)); } return $result['int']; } protected function readIntegerList($num) { if ($this->littleEndian) { return unpack('V' . $num, fread($this->file, 4 * $num)); } return unpack('N' . $num, fread($this->file, 4 * $num)); } } } namespace Zend\I18n\Translator { use ArrayObject; use Zend\I18n\Exception; use Zend\I18n\Translator\Plural\Rule as PluralRule; class TextDomain extends ArrayObject { protected $pluralRule; protected static $defaultPluralRule; public function setPluralRule(PluralRule $rule) { $this->pluralRule = $rule; return $this; } public function getPluralRule($fallbackToDefaultRule = true) { if ($this->pluralRule === null && $fallbackToDefaultRule) { return static::getDefaultPluralRule(); } return $this->pluralRule; } public function hasPluralRule() { return ($this->pluralRule !== null); } public static function getDefaultPluralRule() { if (static::$defaultPluralRule === null) { static::$defaultPluralRule = PluralRule::fromString('nplurals=2; plural=n != 1;'); } return static::$defaultPluralRule; } public function merge(TextDomain $textDomain) { if ($this->hasPluralRule() && $textDomain->hasPluralRule()) { if ($this->getPluralRule()->getNumPlurals() !== $textDomain->getPluralRule()->getNumPlurals()) { throw new Exception\RuntimeException('Plural rule of merging text domain is not compatible with the current one'); } } elseif ($textDomain->hasPluralRule()) { $this->setPluralRule($textDomain->getPluralRule()); } $this->exchangeArray( array_replace( $this->getArrayCopy(), $textDomain->getArrayCopy() ) ); return $this; } } } namespace Zend\I18n\Translator\Loader { use Zend\I18n\Exception; use Zend\I18n\Translator\Plural\Rule as PluralRule; use Zend\I18n\Translator\TextDomain; class PhpArray extends AbstractFileLoader { public function load($locale, $filename) { $resolvedIncludePath = stream_resolve_include_path($filename); $fromIncludePath = ($resolvedIncludePath !== false) ? $resolvedIncludePath : $filename; if (!$fromIncludePath || !is_file($fromIncludePath) || !is_readable($fromIncludePath)) { throw new Exception\InvalidArgumentException(sprintf( 'Could not find or open file %s for reading', $filename )); } $messages = include $fromIncludePath; if (!is_array($messages)) { throw new Exception\InvalidArgumentException(sprintf( 'Expected an array, but received %s', gettype($messages) )); } $textDomain = new TextDomain($messages); if (array_key_exists('', $textDomain)) { if (isset($textDomain['']['plural_forms'])) { $textDomain->setPluralRule( PluralRule::fromString($textDomain['']['plural_forms']) ); } unset($textDomain['']); } return $textDomain; } } } namespace Zend\View\Helper { use stdClass; use Zend\View; use Zend\View\Exception; class HeadMeta extends Placeholder\Container\AbstractStandalone { protected $typeKeys = array('name', 'http-equiv', 'charset', 'property', 'itemprop'); protected $requiredKeys = array('content'); protected $modifierKeys = array('lang', 'scheme'); protected $regKey = 'Zend_View_Helper_HeadMeta'; public function __construct() { parent::__construct(); $this->setSeparator(PHP_EOL); } public function __invoke($content = null, $keyValue = null, $keyType = 'name', $modifiers = array(), $placement = Placeholder\Container\AbstractContainer::APPEND) { if ((null !== $content) && (null !== $keyValue)) { $item = $this->createData($keyType, $keyValue, $content, $modifiers); $action = strtolower($placement); switch ($action) { case 'append': case 'prepend': case 'set': $this->$action($item); break; default: $this->append($item); break; } } return $this; } public function __call($method, $args) { if (preg_match( '/^(?P<action>set|(pre|ap)pend|offsetSet)(?P<type>Name|HttpEquiv|Property|Itemprop)$/', $method, $matches) ) { $action = $matches['action']; $type = $this->normalizeType($matches['type']); $argc = count($args); $index = null; if ('offsetSet' == $action) { if (0 < $argc) { $index = array_shift($args); --$argc; } } if (2 > $argc) { throw new Exception\BadMethodCallException( 'Too few arguments provided; requires key value, and content' ); } if (3 > $argc) { $args[] = array(); } $item = $this->createData($type, $args[0], $args[1], $args[2]); if ('offsetSet' == $action) { return $this->offsetSet($index, $item); } $this->$action($item); return $this; } return parent::__call($method, $args); } public function toString($indent = null) { $indent = (null !== $indent) ? $this->getWhitespace($indent) : $this->getIndent(); $items = array(); $this->getContainer()->ksort(); try { foreach ($this as $item) { $items[] = $this->itemToString($item); } } catch (Exception\InvalidArgumentException $e) { trigger_error($e->getMessage(), E_USER_WARNING); return ''; } return $indent . implode($this->escape($this->getSeparator()) . $indent, $items); } public function createData($type, $typeValue, $content, array $modifiers) { $data = new stdClass; $data->type = $type; $data->$type = $typeValue; $data->content = $content; $data->modifiers = $modifiers; return $data; } public function itemToString(stdClass $item) { if (!in_array($item->type, $this->typeKeys)) { throw new Exception\InvalidArgumentException(sprintf( 'Invalid type "%s" provided for meta', $item->type )); } $type = $item->type; $modifiersString = ''; foreach ($item->modifiers as $key => $value) { if ($this->view->plugin('doctype')->isHtml5() && $key == 'scheme' ) { throw new Exception\InvalidArgumentException( 'Invalid modifier "scheme" provided; not supported by HTML5' ); } if (!in_array($key, $this->modifierKeys)) { continue; } $modifiersString .= $key . '="' . $this->escape($value) . '" '; } $modifiersString = rtrim($modifiersString); if ('' != $modifiersString) { $modifiersString = ' ' . $modifiersString; } if (method_exists($this->view, 'plugin')) { if ($this->view->plugin('doctype')->isHtml5() && $type == 'charset' ) { $tpl = ($this->view->plugin('doctype')->isXhtml()) ? '<meta %s="%s"/>' : '<meta %s="%s">'; } elseif ($this->view->plugin('doctype')->isXhtml()) { $tpl = '<meta %s="%s" content="%s"%s />'; } else { $tpl = '<meta %s="%s" content="%s"%s>'; } } else { $tpl = '<meta %s="%s" content="%s"%s />'; } $meta = sprintf( $tpl, $type, $this->escape($item->$type), $this->escape($item->content), $modifiersString ); if (isset($item->modifiers['conditional']) && !empty($item->modifiers['conditional']) && is_string($item->modifiers['conditional'])) { if (str_replace(' ', '', $item->modifiers['conditional']) === '!IE') { $meta = '<!-->' . $meta . '<!--'; } $meta = '<!--[if ' . $this->escape($item->modifiers['conditional']) . ']>' . $meta . '<![endif]-->'; } return $meta; } protected function normalizeType($type) { switch ($type) { case 'Name': return 'name'; case 'HttpEquiv': return 'http-equiv'; case 'Property': return 'property'; case 'Itemprop': return 'itemprop'; default: throw new Exception\DomainException(sprintf( 'Invalid type "%s" passed to normalizeType', $type )); } } protected function isValid($item) { if ((!$item instanceof stdClass) || !isset($item->type) || !isset($item->modifiers) ) { return false; } if (!isset($item->content) && (! $this->view->plugin('doctype')->isHtml5() || (! $this->view->plugin('doctype')->isHtml5() && $item->type !== 'charset')) ) { return false; } if (! $this->view->plugin('doctype')->isHtml5() && $item->type === 'itemprop' ) { return false; } if (!$this->view->plugin('doctype')->isRdfa() && $item->type === 'property' ) { return false; } return true; } public function append($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid value passed to append; please use appendMeta()' ); } return $this->getContainer()->append($value); } public function offsetSet($index, $value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid value passed to offsetSet; please use offsetSetName() or offsetSetHttpEquiv()' ); } return $this->getContainer()->offsetSet($index, $value); } public function offsetUnset($index) { if (!in_array($index, $this->getContainer()->getKeys())) { throw new Exception\InvalidArgumentException('Invalid index passed to offsetUnset()'); } return $this->getContainer()->offsetUnset($index); } public function prepend($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid value passed to prepend; please use prependMeta()' ); } return $this->getContainer()->prepend($value); } public function set($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException('Invalid value passed to set; please use setMeta()'); } $container = $this->getContainer(); foreach ($container->getArrayCopy() as $index => $item) { if ($item->type == $value->type && $item->{$item->type} == $value->{$value->type}) { $this->offsetUnset($index); } } return $this->append($value); } public function setCharset($charset) { $item = new stdClass; $item->type = 'charset'; $item->charset = $charset; $item->content = null; $item->modifiers = array(); $this->set($item); return $this; } } } namespace Zend\View\Helper { use Zend\View\Exception; class BasePath extends AbstractHelper { protected $basePath; public function __invoke($file = null) { if (null === $this->basePath) { throw new Exception\RuntimeException('No base path provided'); } if (null !== $file) { $file = '/' . ltrim($file, '/'); } return $this->basePath . $file; } public function setBasePath($basePath) { $this->basePath = rtrim($basePath, '/'); return $this; } } } namespace Zend\View\Helper { use stdClass; use Zend\View; use Zend\View\Exception; class HeadLink extends Placeholder\Container\AbstractStandalone { protected $itemKeys = array('charset', 'href', 'hreflang', 'id', 'media', 'rel', 'rev', 'type', 'title', 'extras'); protected $regKey = 'Zend_View_Helper_HeadLink'; public function __construct() { parent::__construct(); $this->setSeparator(PHP_EOL); } public function headLink(array $attributes = null, $placement = Placeholder\Container\AbstractContainer::APPEND) { return call_user_func_array(array($this, '__invoke'), func_get_args()); } public function __invoke(array $attributes = null, $placement = Placeholder\Container\AbstractContainer::APPEND) { if (null !== $attributes) { $item = $this->createData($attributes); switch ($placement) { case Placeholder\Container\AbstractContainer::SET: $this->set($item); break; case Placeholder\Container\AbstractContainer::PREPEND: $this->prepend($item); break; case Placeholder\Container\AbstractContainer::APPEND: default: $this->append($item); break; } } return $this; } public function __call($method, $args) { if (preg_match('/^(?P<action>set|(ap|pre)pend|offsetSet)(?P<type>Stylesheet|Alternate|Prev|Next)$/', $method, $matches)) { $argc = count($args); $action = $matches['action']; $type = $matches['type']; $index = null; if ('offsetSet' == $action) { if (0 < $argc) { $index = array_shift($args); --$argc; } } if (1 > $argc) { throw new Exception\BadMethodCallException(sprintf( '%s requires at least one argument', $method )); } if (is_array($args[0])) { $item = $this->createData($args[0]); } else { $dataMethod = 'createData' . $type; $item = $this->$dataMethod($args); } if ($item) { if ('offsetSet' == $action) { $this->offsetSet($index, $item); } else { $this->$action($item); } } return $this; } return parent::__call($method, $args); } protected function isValid($value) { if (!$value instanceof stdClass) { return false; } $vars = get_object_vars($value); $keys = array_keys($vars); $intersection = array_intersect($this->itemKeys, $keys); if (empty($intersection)) { return false; } return true; } public function append($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'append() expects a data token; please use one of the custom append*() methods' ); } return $this->getContainer()->append($value); } public function offsetSet($index, $value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'offsetSet() expects a data token; please use one of the custom offsetSet*() methods' ); } return $this->getContainer()->offsetSet($index, $value); } public function prepend($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'prepend() expects a data token; please use one of the custom prepend*() methods' ); } return $this->getContainer()->prepend($value); } public function set($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'set() expects a data token; please use one of the custom set*() methods' ); } return $this->getContainer()->set($value); } public function itemToString(stdClass $item) { $attributes = (array) $item; $link = '<link'; foreach ($this->itemKeys as $itemKey) { if (isset($attributes[$itemKey])) { if (is_array($attributes[$itemKey])) { foreach ($attributes[$itemKey] as $key => $value) { $link .= sprintf(' %s="%s"', $key, ($this->autoEscape) ? $this->escape($value) : $value); } } else { $link .= sprintf(' %s="%s"', $itemKey, ($this->autoEscape) ? $this->escape($attributes[$itemKey]) : $attributes[$itemKey]); } } } if (method_exists($this->view, 'plugin')) { $link .= ($this->view->plugin('doctype')->isXhtml()) ? ' />' : '>'; } else { $link .= ' />'; } if (($link == '<link />') || ($link == '<link>')) { return ''; } if (isset($attributes['conditionalStylesheet']) && !empty($attributes['conditionalStylesheet']) && is_string($attributes['conditionalStylesheet'])) { if (str_replace(' ', '', $attributes['conditionalStylesheet']) === '!IE') { $link = '<!-->' . $link . '<!--'; } $link = '<!--[if ' . $attributes['conditionalStylesheet'] . ']>' . $link . '<![endif]-->'; } return $link; } public function toString($indent = null) { $indent = (null !== $indent) ? $this->getWhitespace($indent) : $this->getIndent(); $items = array(); $this->getContainer()->ksort(); foreach ($this as $item) { $items[] = $this->itemToString($item); } return $indent . implode($this->escape($this->getSeparator()) . $indent, $items); } public function createData(array $attributes) { return (object) $attributes; } public function createDataStylesheet(array $args) { $rel = 'stylesheet'; $type = 'text/css'; $media = 'screen'; $conditionalStylesheet = false; $href = array_shift($args); if ($this->isDuplicateStylesheet($href)) { return false; } if (0 < count($args)) { $media = array_shift($args); if (is_array($media)) { $media = implode(',', $media); } else { $media = (string) $media; } } if (0 < count($args)) { $conditionalStylesheet = array_shift($args); if (!empty($conditionalStylesheet) && is_string($conditionalStylesheet)) { $conditionalStylesheet = (string) $conditionalStylesheet; } else { $conditionalStylesheet = null; } } if (0 < count($args) && is_array($args[0])) { $extras = array_shift($args); $extras = (array) $extras; } $attributes = compact('rel', 'type', 'href', 'media', 'conditionalStylesheet', 'extras'); return $this->createData($attributes); } protected function isDuplicateStylesheet($uri) { foreach ($this->getContainer() as $item) { if (($item->rel == 'stylesheet') && ($item->href == $uri)) { return true; } } return false; } public function createDataAlternate(array $args) { if (3 > count($args)) { throw new Exception\InvalidArgumentException(sprintf( 'Alternate tags require 3 arguments; %s provided', count($args) )); } $rel = 'alternate'; $href = array_shift($args); $type = array_shift($args); $title = array_shift($args); if (0 < count($args) && is_array($args[0])) { $extras = array_shift($args); $extras = (array) $extras; if (isset($extras['media']) && is_array($extras['media'])) { $extras['media'] = implode(',', $extras['media']); } } $href = (string) $href; $type = (string) $type; $title = (string) $title; $attributes = compact('rel', 'href', 'type', 'title', 'extras'); return $this->createData($attributes); } public function createDataPrev(array $args) { $rel = 'prev'; $href = (string) array_shift($args); $attributes = compact('rel', 'href'); return $this->createData($attributes); } public function createDataNext(array $args) { $rel = 'next'; $href = (string) array_shift($args); $attributes = compact('rel', 'href'); return $this->createData($attributes); } } } namespace Zend\View\Helper { use stdClass; use Zend\View; use Zend\View\Exception; class HeadScript extends Placeholder\Container\AbstractStandalone { const FILE = 'FILE'; const SCRIPT = 'SCRIPT'; protected $regKey = 'Zend_View_Helper_HeadScript'; protected $arbitraryAttributes = false; protected $captureLock; protected $captureScriptType; protected $captureScriptAttrs = null; protected $captureType; protected $optionalAttributes = array('charset', 'defer', 'language', 'src'); protected $requiredAttributes = array('type'); public $useCdata = false; public function __construct() { parent::__construct(); $this->setSeparator(PHP_EOL); } public function __invoke($mode = self::FILE, $spec = null, $placement = 'APPEND', array $attrs = array(), $type = 'text/javascript') { if ((null !== $spec) && is_string($spec)) { $action = ucfirst(strtolower($mode)); $placement = strtolower($placement); switch ($placement) { case 'set': case 'prepend': case 'append': $action = $placement . $action; break; default: $action = 'append' . $action; break; } $this->$action($spec, $type, $attrs); } return $this; } public function __call($method, $args) { if (preg_match('/^(?P<action>set|(ap|pre)pend|offsetSet)(?P<mode>File|Script)$/', $method, $matches)) { if (1 > count($args)) { throw new Exception\BadMethodCallException(sprintf( 'Method "%s" requires at least one argument', $method )); } $action = $matches['action']; $mode = strtolower($matches['mode']); $type = 'text/javascript'; $attrs = array(); if ('offsetSet' == $action) { $index = array_shift($args); if (1 > count($args)) { throw new Exception\BadMethodCallException(sprintf( 'Method "%s" requires at least two arguments, an index and source', $method )); } } $content = $args[0]; if (isset($args[1])) { $type = (string) $args[1]; } if (isset($args[2])) { $attrs = (array) $args[2]; } switch ($mode) { case 'script': $item = $this->createData($type, $attrs, $content); if ('offsetSet' == $action) { $this->offsetSet($index, $item); } else { $this->$action($item); } break; case 'file': default: if (!$this->isDuplicate($content)) { $attrs['src'] = $content; $item = $this->createData($type, $attrs); if ('offsetSet' == $action) { $this->offsetSet($index, $item); } else { $this->$action($item); } } break; } return $this; } return parent::__call($method, $args); } public function toString($indent = null) { $indent = (null !== $indent) ? $this->getWhitespace($indent) : $this->getIndent(); if ($this->view) { $useCdata = $this->view->plugin('doctype')->isXhtml() ? true : false; } else { $useCdata = $this->useCdata ? true : false; } $escapeStart = ($useCdata) ? '//<![CDATA[' : '//<!--'; $escapeEnd = ($useCdata) ? '//]]>' : '//-->'; $items = array(); $this->getContainer()->ksort(); foreach ($this as $item) { if (!$this->isValid($item)) { continue; } $items[] = $this->itemToString($item, $indent, $escapeStart, $escapeEnd); } return implode($this->getSeparator(), $items); } public function captureStart($captureType = Placeholder\Container\AbstractContainer::APPEND, $type = 'text/javascript', $attrs = array()) { if ($this->captureLock) { throw new Exception\RuntimeException('Cannot nest headScript captures'); } $this->captureLock = true; $this->captureType = $captureType; $this->captureScriptType = $type; $this->captureScriptAttrs = $attrs; ob_start(); } public function captureEnd() { $content = ob_get_clean(); $type = $this->captureScriptType; $attrs = $this->captureScriptAttrs; $this->captureScriptType = null; $this->captureScriptAttrs = null; $this->captureLock = false; switch ($this->captureType) { case Placeholder\Container\AbstractContainer::SET: case Placeholder\Container\AbstractContainer::PREPEND: case Placeholder\Container\AbstractContainer::APPEND: $action = strtolower($this->captureType) . 'Script'; break; default: $action = 'appendScript'; break; } $this->$action($content, $type, $attrs); } public function createData($type, array $attributes, $content = null) { $data = new stdClass(); $data->type = $type; $data->attributes = $attributes; $data->source = $content; return $data; } protected function isDuplicate($file) { foreach ($this->getContainer() as $item) { if (($item->source === null) && array_key_exists('src', $item->attributes) && ($file == $item->attributes['src'])) { return true; } } return false; } protected function isValid($value) { if ((!$value instanceof stdClass) || !isset($value->type) || (!isset($value->source) && !isset($value->attributes))) { return false; } return true; } public function itemToString($item, $indent, $escapeStart, $escapeEnd) { $attrString = ''; if (!empty($item->attributes)) { foreach ($item->attributes as $key => $value) { if ((!$this->arbitraryAttributesAllowed() && !in_array($key, $this->optionalAttributes)) || in_array($key, array('conditional', 'noescape'))) { continue; } if ('defer' == $key) { $value = 'defer'; } $attrString .= sprintf(' %s="%s"', $key, ($this->autoEscape) ? $this->escape($value) : $value); } } $addScriptEscape = !(isset($item->attributes['noescape']) && filter_var($item->attributes['noescape'], FILTER_VALIDATE_BOOLEAN)); $type = ($this->autoEscape) ? $this->escape($item->type) : $item->type; $html = '<script type="' . $type . '"' . $attrString . '>'; if (!empty($item->source)) { $html .= PHP_EOL; if ($addScriptEscape) { $html .= $indent . '    ' . $escapeStart . PHP_EOL; } $html .= $indent . '    ' . $item->source; if ($addScriptEscape) { $html .= PHP_EOL . $indent . '    ' . $escapeEnd; } $html .= PHP_EOL . $indent; } $html .= '</script>'; if (isset($item->attributes['conditional']) && !empty($item->attributes['conditional']) && is_string($item->attributes['conditional'])) { if (str_replace(' ', '', $item->attributes['conditional']) === '!IE') { $html = '<!-->' . $html . '<!--'; } $html = $indent . '<!--[if ' . $item->attributes['conditional'] . ']>' . $html . '<![endif]-->'; } else { $html = $indent . $html; } return $html; } public function append($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid argument passed to append(); please use one of the helper methods, appendScript() or appendFile()' ); } return $this->getContainer()->append($value); } public function prepend($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid argument passed to prepend(); please use one of the helper methods, prependScript() or prependFile()' ); } return $this->getContainer()->prepend($value); } public function set($value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid argument passed to set(); please use one of the helper methods, setScript() or setFile()' ); } return $this->getContainer()->set($value); } public function offsetSet($index, $value) { if (!$this->isValid($value)) { throw new Exception\InvalidArgumentException( 'Invalid argument passed to offsetSet(); please use one of the helper methods, offsetSetScript() or offsetSetFile()' ); } return $this->getContainer()->offsetSet($index, $value); } public function setAllowArbitraryAttributes($flag) { $this->arbitraryAttributes = (bool) $flag; return $this; } public function arbitraryAttributesAllowed() { return $this->arbitraryAttributes; } } } namespace Zend\Authentication { class AuthenticationService implements AuthenticationServiceInterface { protected $storage = null; protected $adapter = null; public function __construct(Storage\StorageInterface $storage = null, Adapter\AdapterInterface $adapter = null) { if (null !== $storage) { $this->setStorage($storage); } if (null !== $adapter) { $this->setAdapter($adapter); } } public function getAdapter() { return $this->adapter; } public function setAdapter(Adapter\AdapterInterface $adapter) { $this->adapter = $adapter; return $this; } public function getStorage() { if (null === $this->storage) { $this->setStorage(new Storage\Session()); } return $this->storage; } public function setStorage(Storage\StorageInterface $storage) { $this->storage = $storage; return $this; } public function authenticate(Adapter\AdapterInterface $adapter = null) { if (!$adapter) { if (!$adapter = $this->getAdapter()) { throw new Exception\RuntimeException('An adapter must be set or passed prior to calling authenticate()'); } } $result = $adapter->authenticate(); if ($this->hasIdentity()) { $this->clearIdentity(); } if ($result->isValid()) { $this->getStorage()->write($result->getIdentity()); } return $result; } public function hasIdentity() { return !$this->getStorage()->isEmpty(); } public function getIdentity() { $storage = $this->getStorage(); if ($storage->isEmpty()) { return null; } return $storage->read(); } public function clearIdentity() { $this->getStorage()->clear(); } } } namespace Zend\Authentication\Storage { use Zend\Session\Container as SessionContainer; use Zend\Session\ManagerInterface as SessionManager; class Session implements StorageInterface { const NAMESPACE_DEFAULT = 'Zend_Auth'; const MEMBER_DEFAULT = 'storage'; protected $session; protected $namespace = self::NAMESPACE_DEFAULT; protected $member = self::MEMBER_DEFAULT; public function __construct($namespace = null, $member = null, SessionManager $manager = null) { if ($namespace !== null) { $this->namespace = $namespace; } if ($member !== null) { $this->member = $member; } $this->session = new SessionContainer($this->namespace, $manager); } public function getNamespace() { return $this->namespace; } public function getMember() { return $this->member; } public function isEmpty() { return !isset($this->session->{$this->member}); } public function read() { return $this->session->{$this->member}; } public function write($contents) { $this->session->{$this->member} = $contents; } public function clear() { unset($this->session->{$this->member}); } } } namespace Zend\Session { use ArrayIterator; use Iterator; use Traversable; use Zend\Session\ManagerInterface as Manager; use Zend\Session\Storage\StorageInterface as Storage; use Zend\Stdlib\ArrayObject; abstract class AbstractContainer extends ArrayObject { protected $name; protected $manager; protected static $managerDefaultClass = 'Zend\\Session\\SessionManager'; protected static $defaultManager; public function __construct($name = 'Default', Manager $manager = null) { if (!preg_match('/^[a-z][a-z0-9_\\\]+$/i', $name)) { throw new Exception\InvalidArgumentException( 'Name passed to container is invalid; must consist of alphanumerics, backslashes and underscores only' ); } $this->name = $name; $this->setManager($manager); parent::__construct(array(), ArrayObject::ARRAY_AS_PROPS); $this->getManager()->start(); } public static function setDefaultManager(Manager $manager = null) { static::$defaultManager = $manager; } public static function getDefaultManager() { if (null === static::$defaultManager) { $manager = new static::$managerDefaultClass(); if (!$manager instanceof Manager) { throw new Exception\InvalidArgumentException( 'Invalid default manager type provided; must implement ManagerInterface' ); } static::$defaultManager = $manager; } return static::$defaultManager; } public function getName() { return $this->name; } protected function setManager(Manager $manager = null) { if (null === $manager) { $manager = static::getDefaultManager(); if (!$manager instanceof Manager) { throw new Exception\InvalidArgumentException( 'Manager provided is invalid; must implement ManagerInterface' ); } } $this->manager = $manager; return $this; } public function getManager() { return $this->manager; } protected function getStorage() { return $this->getManager()->getStorage(); } protected function createContainer() { return new ArrayObject(array(), ArrayObject::ARRAY_AS_PROPS); } protected function verifyNamespace($createContainer = true) { $storage = $this->getStorage(); $name = $this->getName(); if (!isset($storage[$name])) { if (!$createContainer) { return; } $storage[$name] = $this->createContainer(); } if (!is_array($storage[$name]) && !$storage[$name] instanceof Traversable) { throw new Exception\RuntimeException('Container cannot write to storage due to type mismatch'); } return $storage; } protected function expireKeys($key = null) { $storage = $this->verifyNamespace(); $name = $this->getName(); if ((null !== $key) && !isset($storage[$name][$key])) { return true; } if ($this->expireByExpiryTime($storage, $name, $key)) { return true; } if ($this->expireByHops($storage, $name, $key)) { return true; } return false; } protected function expireByExpiryTime(Storage $storage, $name, $key) { $metadata = $storage->getMetadata($name); if (is_array($metadata) && isset($metadata['EXPIRE']) && ($_SERVER['REQUEST_TIME'] > $metadata['EXPIRE']) ) { unset($metadata['EXPIRE']); $storage->setMetadata($name, $metadata, true); $storage[$name] = $this->createContainer(); return true; } if ((null !== $key) && is_array($metadata) && isset($metadata['EXPIRE_KEYS']) && isset($metadata['EXPIRE_KEYS'][$key]) && ($_SERVER['REQUEST_TIME'] > $metadata['EXPIRE_KEYS'][$key]) ) { unset($metadata['EXPIRE_KEYS'][$key]); $storage->setMetadata($name, $metadata, true); unset($storage[$name][$key]); return true; } if ((null === $key) && is_array($metadata) && isset($metadata['EXPIRE_KEYS']) ) { foreach (array_keys($metadata['EXPIRE_KEYS']) as $key) { if ($_SERVER['REQUEST_TIME'] > $metadata['EXPIRE_KEYS'][$key]) { unset($metadata['EXPIRE_KEYS'][$key]); if (isset($storage[$name][$key])) { unset($storage[$name][$key]); } } } $storage->setMetadata($name, $metadata, true); return true; } return false; } protected function expireByHops(Storage $storage, $name, $key) { $ts = $storage->getRequestAccessTime(); $metadata = $storage->getMetadata($name); if (is_array($metadata) && isset($metadata['EXPIRE_HOPS']) && ($ts > $metadata['EXPIRE_HOPS']['ts']) ) { $metadata['EXPIRE_HOPS']['hops']--; if (-1 === $metadata['EXPIRE_HOPS']['hops']) { unset($metadata['EXPIRE_HOPS']); $storage->setMetadata($name, $metadata, true); $storage[$name] = $this->createContainer(); return true; } $metadata['EXPIRE_HOPS']['ts'] = $ts; $storage->setMetadata($name, $metadata, true); return false; } if ((null !== $key) && is_array($metadata) && isset($metadata['EXPIRE_HOPS_KEYS']) && isset($metadata['EXPIRE_HOPS_KEYS'][$key]) && ($ts > $metadata['EXPIRE_HOPS_KEYS'][$key]['ts']) ) { $metadata['EXPIRE_HOPS_KEYS'][$key]['hops']--; if (-1 === $metadata['EXPIRE_HOPS_KEYS'][$key]['hops']) { unset($metadata['EXPIRE_HOPS_KEYS'][$key]); $storage->setMetadata($name, $metadata, true); unset($storage[$name][$key]); return true; } $metadata['EXPIRE_HOPS_KEYS'][$key]['ts'] = $ts; $storage->setMetadata($name, $metadata, true); return false; } if ((null === $key) && is_array($metadata) && isset($metadata['EXPIRE_HOPS_KEYS']) ) { foreach (array_keys($metadata['EXPIRE_HOPS_KEYS']) as $key) { if ($ts > $metadata['EXPIRE_HOPS_KEYS'][$key]['ts']) { $metadata['EXPIRE_HOPS_KEYS'][$key]['hops']--; if (-1 === $metadata['EXPIRE_HOPS_KEYS'][$key]['hops']) { unset($metadata['EXPIRE_HOPS_KEYS'][$key]); $storage->setMetadata($name, $metadata, true); unset($storage[$name][$key]); continue; } $metadata['EXPIRE_HOPS_KEYS'][$key]['ts'] = $ts; } } $storage->setMetadata($name, $metadata, true); return false; } return false; } public function offsetSet($key, $value) { $this->expireKeys($key); $storage = $this->verifyNamespace(); $name = $this->getName(); $storage[$name][$key] = $value; } public function offsetExists($key) { if (null === ($storage = $this->verifyNamespace(false))) { return false; } $name = $this->getName(); if (!isset($storage[$name][$key])) { return false; } $expired = $this->expireKeys($key); return !$expired; } public function offsetGet($key) { if (!$this->offsetExists($key)) { return null; } $storage = $this->getStorage(); $name = $this->getName(); return $storage[$name][$key]; } public function offsetUnset($key) { if (!$this->offsetExists($key)) { return; } $storage = $this->getStorage(); $name = $this->getName(); unset($storage[$name][$key]); } public function exchangeArray($input) { if (is_object($input) && ($input instanceof ArrayObject || $input instanceof \ArrayObject)) { $input = $input->getArrayCopy(); } if (!is_array($input)) { $input = (array) $input; } $storage = $this->verifyNamespace(); $name = $this->getName(); $old = $storage[$name]; $storage[$name] = $input; if ($old instanceof ArrayObject) { return $old->getArrayCopy(); } return $old; } public function getIterator() { $this->expireKeys(); $storage = $this->getStorage(); $container = $storage[$this->getName()]; if ($container instanceof Traversable) { return $container; } return new ArrayIterator($container); } public function setExpirationSeconds($ttl, $vars = null) { $storage = $this->getStorage(); $ts = $_SERVER['REQUEST_TIME'] + $ttl; if (is_scalar($vars) && null !== $vars) { $vars = (array) $vars; } if (null === $vars) { $this->expireKeys(); $data = array('EXPIRE' => $ts); } elseif (is_array($vars)) { $container = $this; $expires = array_filter($vars, function ($value) use ($container) { return $container->offsetExists($value); }); $expires = array_flip($expires); $expires = array_map(function ($value) use ($ts) { return $ts; }, $expires); $data = array('EXPIRE_KEYS' => $expires); } else { throw new Exception\InvalidArgumentException( 'Unknown data provided as second argument to ' . __METHOD__ ); } $storage->setMetadata( $this->getName(), $data ); return $this; } public function setExpirationHops($hops, $vars = null) { $storage = $this->getStorage(); $ts = $storage->getRequestAccessTime(); if (is_scalar($vars) && (null !== $vars)) { $vars = (array) $vars; } if (null === $vars) { $this->expireKeys(); $data = array('EXPIRE_HOPS' => array('hops' => $hops, 'ts' => $ts)); } elseif (is_array($vars)) { $container = $this; $expires = array_filter($vars, function ($value) use ($container) { return $container->offsetExists($value); }); $expires = array_flip($expires); $expires = array_map(function ($value) use ($hops, $ts) { return array('hops' => $hops, 'ts' => $ts); }, $expires); $data = array('EXPIRE_HOPS_KEYS' => $expires); } else { throw new Exception\InvalidArgumentException( 'Unknown data provided as second argument to ' . __METHOD__ ); } $storage->setMetadata( $this->getName(), $data ); return $this; } public function getArrayCopy() { $storage = $this->verifyNamespace(); $container = $storage[$this->getName()]; return $container instanceof ArrayObject ? $container->getArrayCopy() : $container; } } } namespace Zend\Session { class Container extends AbstractContainer { public function &offsetGet($key) { $ret = null; if (!$this->offsetExists($key)) { return $ret; } $storage = $this->getStorage(); $name = $this->getName(); $ret =& $storage[$name][$key]; return $ret; } } } namespace Zend\Session { use Zend\Session\Config\ConfigInterface as Config; use Zend\Session\ManagerInterface as Manager; use Zend\Session\SaveHandler\SaveHandlerInterface as SaveHandler; use Zend\Session\Storage\StorageInterface as Storage; abstract class AbstractManager implements Manager { protected $config; protected $defaultConfigClass = 'Zend\Session\Config\SessionConfig'; protected $storage; protected $defaultStorageClass = 'Zend\Session\Storage\SessionArrayStorage'; protected $saveHandler; public function __construct(Config $config = null, Storage $storage = null, SaveHandler $saveHandler = null) { if ($config === null) { if (!class_exists($this->defaultConfigClass)) { throw new Exception\RuntimeException(sprintf( 'Unable to locate config class "%s"; class does not exist', $this->defaultConfigClass )); } $config = new $this->defaultConfigClass(); if (!$config instanceof Config) { throw new Exception\RuntimeException(sprintf( 'Default config class %s is invalid; must implement %s\Config\ConfigInterface', $this->defaultConfigClass, __NAMESPACE__ )); } } $this->config = $config; if ($storage === null) { if (!class_exists($this->defaultStorageClass)) { throw new Exception\RuntimeException(sprintf( 'Unable to locate storage class "%s"; class does not exist', $this->defaultStorageClass )); } $storage = new $this->defaultStorageClass(); if (!$storage instanceof Storage) { throw new Exception\RuntimeException(sprintf( 'Default storage class %s is invalid; must implement %s\Storage\StorageInterface', $this->defaultConfigClass, __NAMESPACE__ )); } } $this->storage = $storage; if ($saveHandler !== null) { $this->saveHandler = $saveHandler; } } public function setConfig(Config $config) { $this->config = $config; return $this; } public function getConfig() { return $this->config; } public function setStorage(Storage $storage) { $this->storage = $storage; return $this; } public function getStorage() { return $this->storage; } public function setSaveHandler(SaveHandler $saveHandler) { $this->saveHandler = $saveHandler; return $this; } public function getSaveHandler() { return $this->saveHandler; } } } namespace Zend\Session { use Zend\EventManager\EventManagerInterface; class SessionManager extends AbstractManager { protected $defaultDestroyOptions = array( 'send_expire_cookie' => true, 'clear_storage' => false, ); protected $name; protected $validatorChain; public function __construct(Config\ConfigInterface $config = null, Storage\StorageInterface $storage = null, SaveHandler\SaveHandlerInterface $saveHandler = null) { parent::__construct($config, $storage, $saveHandler); register_shutdown_function(array($this, 'writeClose')); } public function sessionExists() { $sid = defined('SID') ? constant('SID') : false; if ($sid !== false && $this->getId()) { return true; } if (headers_sent()) { return true; } return false; } public function start($preserveStorage = false) { if ($this->sessionExists()) { return; } $saveHandler = $this->getSaveHandler(); if ($saveHandler instanceof SaveHandler\SaveHandlerInterface) { $this->registerSaveHandler($saveHandler); } session_start(); $storage = $this->getStorage(); if ($storage instanceof Storage\SessionStorage && $_SESSION !== $storage) { if (!$preserveStorage) { $storage->fromArray($_SESSION); } $_SESSION = $storage; } elseif ($storage instanceof Storage\StorageInitializationInterface) { $storage->init($_SESSION); } if (!$this->isValid()) { throw new Exception\RuntimeException('Session validation failed'); } } public function destroy(array $options = null) { if (!$this->sessionExists()) { return; } if (null === $options) { $options = $this->defaultDestroyOptions; } else { $options = array_merge($this->defaultDestroyOptions, $options); } session_destroy(); if ($options['send_expire_cookie']) { $this->expireSessionCookie(); } if ($options['clear_storage']) { $this->getStorage()->clear(); } } public function writeClose() { $storage = $this->getStorage(); if (!$storage->isImmutable()) { $_SESSION = $storage->toArray(true); session_write_close(); $storage->fromArray($_SESSION); $storage->markImmutable(); } } public function setName($name) { if ($this->sessionExists()) { throw new Exception\InvalidArgumentException( 'Cannot set session name after a session has already started' ); } if (!preg_match('/^[a-zA-Z0-9]+$/', $name)) { throw new Exception\InvalidArgumentException( 'Name provided contains invalid characters; must be alphanumeric only' ); } $this->name = $name; session_name($name); return $this; } public function getName() { if (null === $this->name) { $this->name = session_name(); } return $this->name; } public function setId($id) { if ($this->sessionExists()) { throw new Exception\RuntimeException('Session has already been started, to change the session ID call regenerateId()'); } session_id($id); return $this; } public function getId() { return session_id(); } public function regenerateId($deleteOldSession = true) { session_regenerate_id((bool) $deleteOldSession); return $this; } public function rememberMe($ttl = null) { if (null === $ttl) { $ttl = $this->getConfig()->getRememberMeSeconds(); } $this->setSessionCookieLifetime($ttl); return $this; } public function forgetMe() { $this->setSessionCookieLifetime(0); return $this; } public function setValidatorChain(EventManagerInterface $chain) { $this->validatorChain = $chain; return $this; } public function getValidatorChain() { if (null === $this->validatorChain) { $this->setValidatorChain(new ValidatorChain($this->getStorage())); } return $this->validatorChain; } public function isValid() { $validator = $this->getValidatorChain(); $responses = $validator->triggerUntil('session.validate', $this, array($this), function ($test) { return false === $test; }); if ($responses->stopped()) { return false; } return true; } public function expireSessionCookie() { $config = $this->getConfig(); if (!$config->getUseCookies()) { return; } setcookie( $this->getName(), '', $_SERVER['REQUEST_TIME'] - 42000, $config->getCookiePath(), $config->getCookieDomain(), $config->getCookieSecure(), $config->getCookieHttpOnly() ); } protected function setSessionCookieLifetime($ttl) { $config = $this->getConfig(); if (!$config->getUseCookies()) { return; } $config->setCookieLifetime($ttl); if ($this->sessionExists()) { $this->regenerateId(); } } protected function registerSaveHandler(SaveHandler\SaveHandlerInterface $saveHandler) { return session_set_save_handler( array($saveHandler, 'open'), array($saveHandler, 'close'), array($saveHandler, 'read'), array($saveHandler, 'write'), array($saveHandler, 'destroy'), array($saveHandler, 'gc') ); } } } namespace Zend\Session\Config { use Traversable; use Zend\Session\Exception; use Zend\Validator\Hostname as HostnameValidator; class StandardConfig implements ConfigInterface { protected $name; protected $savePath; protected $cookieLifetime; protected $cookiePath; protected $cookieDomain; protected $cookieSecure; protected $cookieHttpOnly; protected $rememberMeSeconds; protected $useCookies; protected $options = array(); public function setOptions($options) { if (!is_array($options) && !$options instanceof Traversable) { throw new Exception\InvalidArgumentException(sprintf( 'Parameter provided to %s must be an array or Traversable', __METHOD__ )); } foreach ($options as $key => $value) { $setter = 'set' . str_replace(' ', '', ucwords(str_replace('_', ' ', $key))); if (method_exists($this, $setter)) { $this->{$setter}($value); } else { $this->setOption($key, $value); } } return $this; } public function getOptions() { return $this->options; } public function setOption($option, $value) { $option = strtolower($option); $this->options[$option] = $value; $this->setStorageOption($option, $value); return $this; } public function getOption($option) { $option = strtolower($option); if (array_key_exists($option, $this->options)) { return $this->options[$option]; } $value = $this->getStorageOption($option); if (null !== $value) { $this->setOption($option, $value); return $value; } return null; } public function hasOption($option) { $option = strtolower($option); return array_key_exists($option, $this->options); } public function setStorageOption($storageName, $storageValue) { return $this; } public function getStorageOption($storageOption) { return null; } public function setSavePath($savePath) { if (!is_dir($savePath)) { throw new Exception\InvalidArgumentException('Invalid save_path provided; not a directory'); } if (!is_writable($savePath)) { throw new Exception\InvalidArgumentException('Invalid save_path provided; not writable'); } $this->savePath = $savePath; $this->setStorageOption('save_path', $savePath); return $this; } public function getSavePath() { if (null === $this->savePath) { $this->savePath = $this->getStorageOption('save_path'); } return $this->savePath; } public function setName($name) { $this->name = (string) $name; if (empty($this->name)) { throw new Exception\InvalidArgumentException('Invalid session name; cannot be empty'); } $this->setStorageOption('name', $this->name); return $this; } public function getName() { if (null === $this->name) { $this->name = $this->getStorageOption('name'); } return $this->name; } public function setGcProbability($gcProbability) { if (!is_numeric($gcProbability)) { throw new Exception\InvalidArgumentException('Invalid gc_probability; must be numeric'); } $gcProbability = (int) $gcProbability; if (0 > $gcProbability || 100 < $gcProbability) { throw new Exception\InvalidArgumentException('Invalid gc_probability; must be a percentage'); } $this->setOption('gc_probability', $gcProbability); $this->setStorageOption('gc_probability', $gcProbability); return $this; } public function getGcProbability() { if (!isset($this->options['gc_probability'])) { $this->options['gc_probability'] = $this->getStorageOption('gc_probability'); } return $this->options['gc_probability']; } public function setGcDivisor($gcDivisor) { if (!is_numeric($gcDivisor)) { throw new Exception\InvalidArgumentException('Invalid gc_divisor; must be numeric'); } $gcDivisor = (int) $gcDivisor; if (1 > $gcDivisor) { throw new Exception\InvalidArgumentException('Invalid gc_divisor; must be a positive integer'); } $this->setOption('gc_divisor', $gcDivisor); $this->setStorageOption('gc_divisor', $gcDivisor); return $this; } public function getGcDivisor() { if (!isset($this->options['gc_divisor'])) { $this->options['gc_divisor'] = $this->getStorageOption('gc_divisor'); } return $this->options['gc_divisor']; } public function setGcMaxlifetime($gcMaxlifetime) { if (!is_numeric($gcMaxlifetime)) { throw new Exception\InvalidArgumentException('Invalid gc_maxlifetime; must be numeric'); } $gcMaxlifetime = (int) $gcMaxlifetime; if (1 > $gcMaxlifetime) { throw new Exception\InvalidArgumentException('Invalid gc_maxlifetime; must be a positive integer'); } $this->setOption('gc_maxlifetime', $gcMaxlifetime); $this->setStorageOption('gc_maxlifetime', $gcMaxlifetime); return $this; } public function getGcMaxlifetime() { if (!isset($this->options['gc_maxlifetime'])) { $this->options['gc_maxlifetime'] = $this->getStorageOption('gc_maxlifetime'); } return $this->options['gc_maxlifetime']; } public function setCookieLifetime($cookieLifetime) { if (!is_numeric($cookieLifetime)) { throw new Exception\InvalidArgumentException('Invalid cookie_lifetime; must be numeric'); } if (0 > $cookieLifetime) { throw new Exception\InvalidArgumentException( 'Invalid cookie_lifetime; must be a positive integer or zero' ); } $this->cookieLifetime = (int) $cookieLifetime; $this->setStorageOption('cookie_lifetime', $this->cookieLifetime); return $this; } public function getCookieLifetime() { if (null === $this->cookieLifetime) { $this->cookieLifetime = $this->getStorageOption('cookie_lifetime'); } return $this->cookieLifetime; } public function setCookiePath($cookiePath) { $cookiePath = (string) $cookiePath; $test = parse_url($cookiePath, PHP_URL_PATH); if ($test != $cookiePath || '/' != $test[0]) { throw new Exception\InvalidArgumentException('Invalid cookie path'); } $this->cookiePath = $cookiePath; $this->setStorageOption('cookie_path', $cookiePath); return $this; } public function getCookiePath() { if (null === $this->cookiePath) { $this->cookiePath = $this->getStorageOption('cookie_path'); } return $this->cookiePath; } public function setCookieDomain($cookieDomain) { if (!is_string($cookieDomain)) { throw new Exception\InvalidArgumentException('Invalid cookie domain: must be a string'); } $validator = new HostnameValidator(HostnameValidator::ALLOW_ALL); if (!empty($cookieDomain) && !$validator->isValid($cookieDomain)) { throw new Exception\InvalidArgumentException( 'Invalid cookie domain: ' . implode('; ', $validator->getMessages()) ); } $this->cookieDomain = $cookieDomain; $this->setStorageOption('cookie_domain', $cookieDomain); return $this; } public function getCookieDomain() { if (null === $this->cookieDomain) { $this->cookieDomain = $this->getStorageOption('cookie_domain'); } return $this->cookieDomain; } public function setCookieSecure($cookieSecure) { $this->cookieSecure = (bool) $cookieSecure; $this->setStorageOption('cookie_secure', $this->cookieSecure); return $this; } public function getCookieSecure() { if (null === $this->cookieSecure) { $this->cookieSecure = $this->getStorageOption('cookie_secure'); } return $this->cookieSecure; } public function setCookieHttpOnly($cookieHttpOnly) { $this->cookieHttpOnly = (bool) $cookieHttpOnly; $this->setStorageOption('cookie_httponly', $this->cookieHttpOnly); return $this; } public function getCookieHttpOnly() { if (null === $this->cookieHttpOnly) { $this->cookieHttpOnly = $this->getStorageOption('cookie_httponly'); } return $this->cookieHttpOnly; } public function setUseCookies($useCookies) { $this->useCookies = (bool) $useCookies; $this->setStorageOption('use_cookies', $this->useCookies); return $this; } public function getUseCookies() { if (null === $this->useCookies) { $this->useCookies = $this->getStorageOption('use_cookies'); } return $this->useCookies; } public function setEntropyFile($entropyFile) { if (!is_readable($entropyFile)) { throw new Exception\InvalidArgumentException(sprintf( "Invalid entropy_file provided: '%s'; doesn't exist or not readable", $entropyFile )); } $this->setOption('entropy_file', $entropyFile); $this->setStorageOption('entropy_file', $entropyFile); return $this; } public function getEntropyFile() { if (!isset($this->options['entropy_file'])) { $this->options['entropy_file'] = $this->getStorageOption('entropy_file'); } return $this->options['entropy_file']; } public function setEntropyLength($entropyLength) { if (!is_numeric($entropyLength)) { throw new Exception\InvalidArgumentException('Invalid entropy_length; must be numeric'); } if (0 > $entropyLength) { throw new Exception\InvalidArgumentException('Invalid entropy_length; must be a positive integer or zero'); } $this->setOption('entropy_length', $entropyLength); $this->setStorageOption('entropy_length', $entropyLength); return $this; } public function getEntropyLength() { if (!isset($this->options['entropy_length'])) { $this->options['entropy_length'] = $this->getStorageOption('entropy_length'); } return $this->options['entropy_length']; } public function setCacheExpire($cacheExpire) { if (!is_numeric($cacheExpire)) { throw new Exception\InvalidArgumentException('Invalid cache_expire; must be numeric'); } $cacheExpire = (int) $cacheExpire; if (1 > $cacheExpire) { throw new Exception\InvalidArgumentException('Invalid cache_expire; must be a positive integer'); } $this->setOption('cache_expire', $cacheExpire); $this->setStorageOption('cache_expire', $cacheExpire); return $this; } public function getCacheExpire() { if (!isset($this->options['cache_expire'])) { $this->options['cache_expire'] = $this->getStorageOption('cache_expire'); } return $this->options['cache_expire']; } public function setHashBitsPerCharacter($hashBitsPerCharacter) { if (!is_numeric($hashBitsPerCharacter)) { throw new Exception\InvalidArgumentException('Invalid hash bits per character provided'); } $hashBitsPerCharacter = (int) $hashBitsPerCharacter; $this->setOption('hash_bits_per_character', $hashBitsPerCharacter); $this->setStorageOption('hash_bits_per_character', $hashBitsPerCharacter); return $this; } public function getHashBitsPerCharacter() { if (!isset($this->options['hash_bits_per_character'])) { $this->options['hash_bits_per_character'] = $this->getStorageOption('hash_bits_per_character'); } return $this->options['hash_bits_per_character']; } public function setRememberMeSeconds($rememberMeSeconds) { if (!is_numeric($rememberMeSeconds)) { throw new Exception\InvalidArgumentException('Invalid remember_me_seconds; must be numeric'); } $rememberMeSeconds = (int) $rememberMeSeconds; if (1 > $rememberMeSeconds) { throw new Exception\InvalidArgumentException('Invalid remember_me_seconds; must be a positive integer'); } $this->rememberMeSeconds = $rememberMeSeconds; $this->setStorageOption('remember_me_seconds', $rememberMeSeconds); return $this; } public function getRememberMeSeconds() { if (null === $this->rememberMeSeconds) { $this->rememberMeSeconds = $this->getStorageOption('remember_me_seconds'); } return $this->rememberMeSeconds; } public function toArray() { $extraOpts = array( 'cookie_domain' => $this->getCookieDomain(), 'cookie_httponly' => $this->getCookieHttpOnly(), 'cookie_lifetime' => $this->getCookieLifetime(), 'cookie_path' => $this->getCookiePath(), 'cookie_secure' => $this->getCookieSecure(), 'name' => $this->getName(), 'remember_me_seconds' => $this->getRememberMeSeconds(), 'save_path' => $this->getSavePath(), 'use_cookies' => $this->getUseCookies(), ); return array_merge($this->options, $extraOpts); } public function __call($method, $args) { $prefix = substr($method, 0, 3); $option = substr($method, 3); $key = strtolower(preg_replace('#(?<=[a-z])([A-Z])#', '_\1', $option)); if ($prefix === 'set') { $value = array_shift($args); return $this->setOption($key, $value); } elseif ($prefix === 'get') { return $this->getOption($key); } else { throw new Exception\BadMethodCallException(sprintf( 'Method "%s" does not exist in %s', $method, get_class($this) )); } } } } namespace Zend\Session\Config { use Zend\Session\Exception; class SessionConfig extends StandardConfig { protected $phpErrorCode = false; protected $phpErrorMessage = false; protected $rememberMeSeconds = 1209600; protected $serializeHandler; protected $validCacheLimiters = array( '', 'nocache', 'public', 'private', 'private_no_expire', ); protected $validHashBitsPerCharacters = array( 4, 5, 6, ); protected $validHashFunctions; public function setStorageOption($storageName, $storageValue) { switch ($storageName) { case 'remember_me_seconds': return; case 'url_rewriter_tags': $key = 'url_rewriter.tags'; break; default: $key = 'session.' . $storageName; break; } $result = ini_set($key, $storageValue); if (FALSE === $result) { throw new Exception\InvalidArgumentException("'" . $key . "' is not a valid sessions-related ini setting."); } return $this; } public function getStorageOption($storageOption) { switch ($storageOption) { case 'remember_me_seconds': return $this->rememberMeSeconds; case 'url_rewriter_tags': return ini_get('url_rewriter.tags'); case 'use_cookies': case 'use_only_cookies': case 'use_trans_sid': case 'cookie_httponly': return (bool) ini_get('session.' . $storageOption); default: return ini_get('session.' . $storageOption); } } public function setPhpSaveHandler($phpSaveHandler) { $phpSaveHandler = (string) $phpSaveHandler; set_error_handler(array($this, 'handleError')); ini_set('session.save_handler', $phpSaveHandler); restore_error_handler(); if ($this->phpErrorCode >= E_WARNING) { throw new Exception\InvalidArgumentException( 'Invalid save handler specified: ' . $this->phpErrorMessage ); } $this->setOption('save_handler', $phpSaveHandler); return $this; } public function setSavePath($savePath) { if ($this->getOption('save_handler') == 'files') { parent::setSavePath($savePath); } $this->savePath = $savePath; $this->setOption('save_path', $savePath); return $this; } public function setSerializeHandler($serializeHandler) { $serializeHandler = (string) $serializeHandler; set_error_handler(array($this, 'handleError')); ini_set('session.serialize_handler', $serializeHandler); restore_error_handler(); if ($this->phpErrorCode >= E_WARNING) { throw new Exception\InvalidArgumentException('Invalid serialize handler specified'); } $this->serializeHandler = (string) $serializeHandler; return $this; } public function setCacheLimiter($cacheLimiter) { $cacheLimiter = (string) $cacheLimiter; if (!in_array($cacheLimiter, $this->validCacheLimiters)) { throw new Exception\InvalidArgumentException('Invalid cache limiter provided'); } $this->setOption('cache_limiter', $cacheLimiter); ini_set('session.cache_limiter', $cacheLimiter); return $this; } public function setHashFunction($hashFunction) { $hashFunction = (string) $hashFunction; $validHashFunctions = $this->getHashFunctions(); if (!in_array($hashFunction, $validHashFunctions, true)) { throw new Exception\InvalidArgumentException('Invalid hash function provided'); } $this->setOption('hash_function', $hashFunction); ini_set('session.hash_function', $hashFunction); return $this; } public function setHashBitsPerCharacter($hashBitsPerCharacter) { if (!is_numeric($hashBitsPerCharacter) || !in_array($hashBitsPerCharacter, $this->validHashBitsPerCharacters) ) { throw new Exception\InvalidArgumentException('Invalid hash bits per character provided'); } $hashBitsPerCharacter = (int) $hashBitsPerCharacter; $this->setOption('hash_bits_per_character', $hashBitsPerCharacter); ini_set('session.hash_bits_per_character', $hashBitsPerCharacter); return $this; } protected function getHashFunctions() { if (empty($this->validHashFunctions)) { $this->validHashFunctions = array('0', '1') + hash_algos(); } return $this->validHashFunctions; } protected function handleError($code, $message) { $this->phpErrorCode = $code; $this->phpErrorMessage = $message; } } } namespace Zend\Session\Storage { use ArrayIterator; use IteratorAggregate; use Zend\Session\Exception; abstract class AbstractSessionArrayStorage implements IteratorAggregate, StorageInterface, StorageInitializationInterface { public function __construct($input = null) { $this->init($input); } public function init($input = null) { if ((null === $input) && isset($_SESSION)) { $input = $_SESSION; if (is_object($input) && !$_SESSION instanceof \ArrayObject) { $input = (array) $input; } } elseif (null === $input) { $input = array(); } $_SESSION = $input; $this->setRequestAccessTime(microtime(true)); } public function __get($key) { return $this->offsetGet($key); } public function __set($key, $value) { return $this->offsetSet($key, $value); } public function __isset($key) { return $this->offsetExists($key); } public function __unset($key) { return $this->offsetUnset($key); } public function __destruct() { return ; } public function offsetExists($key) { return isset($_SESSION[$key]); } public function offsetGet($key) { if (isset($_SESSION[$key])) { return $_SESSION[$key]; } return null; } public function offsetSet($key, $value) { $_SESSION[$key] = $value; } public function offsetUnset($key) { unset($_SESSION[$key]); } public function count() { return count($_SESSION); } public function serialize() { return serialize($_SESSION); } public function unserialize($session) { return unserialize($session); } public function getIterator() { return new ArrayIterator($_SESSION); } public function fromArray(array $array) { $ts = $this->getRequestAccessTime(); $_SESSION = $array; $this->setRequestAccessTime($ts); return $this; } public function markImmutable() { $_SESSION['_IMMUTABLE'] = true; return $this; } public function isImmutable() { return (isset($_SESSION['_IMMUTABLE']) && $_SESSION['_IMMUTABLE']); } public function lock($key = null) { if (null === $key) { $this->setMetadata('_READONLY', true); return $this; } if (isset($_SESSION[$key])) { $this->setMetadata('_LOCKS', array($key => true)); } return $this; } public function isLocked($key = null) { if ($this->isImmutable()) { return true; } if (null === $key) { return $this->getMetadata('_READONLY'); } $locks = $this->getMetadata('_LOCKS'); $readOnly = $this->getMetadata('_READONLY'); if ($readOnly && !$locks) { return true; } if ($readOnly && $locks) { return array_key_exists($key, $locks); } if (!$locks) { return false; } return array_key_exists($key, $locks); } public function unlock($key = null) { if (null === $key) { $this->setMetadata('_READONLY', false); $this->setMetadata('_LOCKS', false); return $this; } $locks = $this->getMetadata('_LOCKS'); if (!$locks) { if (!$this->getMetadata('_READONLY')) { return $this; } $array = $this->toArray(); $keys = array_keys($array); $locks = array_flip($keys); unset($array, $keys); } if (array_key_exists($key, $locks)) { unset($locks[$key]); $this->setMetadata('_LOCKS', $locks, true); } return $this; } public function setMetadata($key, $value, $overwriteArray = false) { if ($this->isImmutable()) { throw new Exception\RuntimeException(sprintf( 'Cannot set key "%s" as storage is marked isImmutable', $key )); } if (!isset($_SESSION['__ZF'])) { $_SESSION['__ZF'] = array(); } if (isset($_SESSION['__ZF'][$key]) && is_array($value)) { if ($overwriteArray) { $_SESSION['__ZF'][$key] = $value; } else { $_SESSION['__ZF'][$key] = array_replace_recursive($_SESSION['__ZF'][$key], $value); } } else { if ((null === $value) && isset($_SESSION['__ZF'][$key])) { $array = $_SESSION['__ZF']; unset($array[$key]); $_SESSION['__ZF'] = $array; unset($array); } elseif (null !== $value) { $_SESSION['__ZF'][$key] = $value; } } return $this; } public function getMetadata($key = null) { if (!isset($_SESSION['__ZF'])) { return false; } if (null === $key) { return $_SESSION['__ZF']; } if (!array_key_exists($key, $_SESSION['__ZF'])) { return false; } return $_SESSION['__ZF'][$key]; } public function clear($key = null) { if ($this->isImmutable()) { throw new Exception\RuntimeException('Cannot clear storage as it is marked immutable'); } if (null === $key) { $this->fromArray(array()); return $this; } if (!isset($_SESSION[$key])) { return $this; } unset($_SESSION[$key]); $this->setMetadata($key, null) ->unlock($key); return $this; } public function getRequestAccessTime() { return $this->getMetadata('_REQUEST_ACCESS_TIME'); } protected function setRequestAccessTime($time) { $this->setMetadata('_REQUEST_ACCESS_TIME', $time); return $this; } public function toArray($metaData = false) { if (isset($_SESSION)) { $values = $_SESSION; } else { $values = array(); } if ($metaData) { return $values; } if (isset($values['__ZF'])) { unset($values['__ZF']); } return $values; } } } namespace Zend\Session\Storage { class SessionArrayStorage extends AbstractSessionArrayStorage { public function &__get($key) { return $_SESSION[$key]; } public function &offsetGet($key) { return $_SESSION[$key]; } } } namespace Zend\Session { use Zend\EventManager\EventManager; use Zend\Session\Storage\StorageInterface as Storage; use Zend\Session\Validator\ValidatorInterface as Validator; class ValidatorChain extends EventManager { protected $storage; public function __construct(Storage $storage) { $this->storage = $storage; $validators = $storage->getMetadata('_VALID'); if ($validators) { foreach ($validators as $validator => $data) { $this->attach('session.validate', array(new $validator($data), 'isValid')); } } } public function attach($event, $callback = null, $priority = 1) { $context = null; if ($callback instanceof Validator) { $context = $callback; } elseif (is_array($callback)) { $test = array_shift($callback); if ($test instanceof Validator) { $context = $test; } array_unshift($callback, $test); } if ($context instanceof Validator) { $data = $context->getData(); $name = $context->getName(); $this->getStorage()->setMetadata('_VALID', array($name => $data)); } $listener = parent::attach($event, $callback, $priority); return $listener; } public function getStorage() { return $this->storage; } } } namespace Zend\Stdlib\Hydrator { use ArrayObject; use Zend\Stdlib\Exception; use Zend\Stdlib\Hydrator\Filter\FilterComposite; use Zend\Stdlib\Hydrator\NamingStrategy\NamingStrategyInterface; use Zend\Stdlib\Hydrator\Strategy\StrategyInterface; abstract class AbstractHydrator implements HydratorInterface, StrategyEnabledInterface, FilterEnabledInterface, NamingStrategyEnabledInterface { protected $strategies; protected $namingStrategy; protected $filterComposite; public function __construct() { $this->strategies = new ArrayObject(); $this->filterComposite = new FilterComposite(); } public function getStrategy($name) { if (isset($this->strategies[$name])) { return $this->strategies[$name]; } if (!isset($this->strategies['*'])) { throw new Exception\InvalidArgumentException(sprintf( '%s: no strategy by name of "%s", and no wildcard strategy present', __METHOD__, $name )); } return $this->strategies['*']; } public function hasStrategy($name) { return array_key_exists($name, $this->strategies) || array_key_exists('*', $this->strategies); } public function addStrategy($name, StrategyInterface $strategy) { $this->strategies[$name] = $strategy; return $this; } public function removeStrategy($name) { unset($this->strategies[$name]); return $this; } public function extractValue($name, $value, $object = null) { if ($this->hasStrategy($name)) { $strategy = $this->getStrategy($name); $value = $strategy->extract($value, $object); } return $value; } public function hydrateValue($name, $value, $data = null) { if ($this->hasStrategy($name)) { $strategy = $this->getStrategy($name); $value = $strategy->hydrate($value, $data); } return $value; } public function extractName($name, $object = null) { if ($this->hasNamingStrategy()) { $name = $this->getNamingStrategy()->extract($name, $object); } return $name; } public function hydrateName($name, $data = null) { if ($this->hasNamingStrategy()) { $name = $this->getNamingStrategy()->hydrate($name, $data); } return $name; } public function getFilter() { return $this->filterComposite; } public function addFilter($name, $filter, $condition = FilterComposite::CONDITION_OR) { return $this->filterComposite->addFilter($name, $filter, $condition); } public function hasFilter($name) { return $this->filterComposite->hasFilter($name); } public function removeFilter($name) { return $this->filterComposite->removeFilter($name); } public function setNamingStrategy(NamingStrategyInterface $strategy) { $this->namingStrategy = $strategy; return $this; } public function getNamingStrategy() { return $this->namingStrategy; } public function hasNamingStrategy() { return isset($this->namingStrategy); } public function removeNamingStrategy() { $this->namingStrategy = null; return $this; } } } namespace Zend\Stdlib\Hydrator { use Traversable; use Zend\Stdlib\Exception; use Zend\Stdlib\ArrayUtils; use Zend\Stdlib\Hydrator\Filter\FilterComposite; use Zend\Stdlib\Hydrator\Filter\FilterProviderInterface; use Zend\Stdlib\Hydrator\Filter\GetFilter; use Zend\Stdlib\Hydrator\Filter\HasFilter; use Zend\Stdlib\Hydrator\Filter\IsFilter; use Zend\Stdlib\Hydrator\Filter\MethodMatchFilter; use Zend\Stdlib\Hydrator\Filter\OptionalParametersFilter; use Zend\Stdlib\Hydrator\NamingStrategy\UnderscoreNamingStrategy; class ClassMethods extends AbstractHydrator implements HydratorOptionsInterface { protected $underscoreSeparatedKeys = true; private $callableMethodFilter; public function __construct($underscoreSeparatedKeys = true) { parent::__construct(); $this->setUnderscoreSeparatedKeys($underscoreSeparatedKeys); $this->callableMethodFilter = new OptionalParametersFilter(); $this->filterComposite->addFilter("is", new IsFilter()); $this->filterComposite->addFilter("has", new HasFilter()); $this->filterComposite->addFilter("get", new GetFilter()); $this->filterComposite->addFilter("parameter", new OptionalParametersFilter(), FilterComposite::CONDITION_AND); } public function setOptions($options) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } elseif (!is_array($options)) { throw new Exception\InvalidArgumentException( 'The options parameter must be an array or a Traversable' ); } if (isset($options['underscoreSeparatedKeys'])) { $this->setUnderscoreSeparatedKeys($options['underscoreSeparatedKeys']); } return $this; } public function setUnderscoreSeparatedKeys($underscoreSeparatedKeys) { $this->underscoreSeparatedKeys = (bool) $underscoreSeparatedKeys; if ($this->underscoreSeparatedKeys) { $this->setNamingStrategy(new UnderscoreNamingStrategy); } elseif ($this->getNamingStrategy() instanceof UnderscoreNamingStrategy) { $this->removeNamingStrategy(); } return $this; } public function getUnderscoreSeparatedKeys() { return $this->underscoreSeparatedKeys; } public function extract($object) { if (!is_object($object)) { throw new Exception\BadMethodCallException(sprintf( '%s expects the provided $object to be a PHP object)', __METHOD__ )); } $filter = null; if ($object instanceof FilterProviderInterface) { $filter = new FilterComposite( array($object->getFilter()), array(new MethodMatchFilter("getFilter")) ); } else { $filter = $this->filterComposite; } $attributes = array(); $methods = get_class_methods($object); foreach ($methods as $method) { if ( !$filter->filter( get_class($object) . '::' . $method ) ) { continue; } if (!$this->callableMethodFilter->filter(get_class($object) . '::' . $method)) { continue; } $attribute = $method; if (preg_match('/^get/', $method)) { $attribute = substr($method, 3); if (!property_exists($object, $attribute)) { $attribute = lcfirst($attribute); } } $attribute = $this->extractName($attribute, $object); $attributes[$attribute] = $this->extractValue($attribute, $object->$method(), $object); } return $attributes; } public function hydrate(array $data, $object) { if (!is_object($object)) { throw new Exception\BadMethodCallException(sprintf( '%s expects the provided $object to be a PHP object)', __METHOD__ )); } foreach ($data as $property => $value) { $method = 'set' . ucfirst($this->hydrateName($property, $data)); if (is_callable(array($object, $method))) { $value = $this->hydrateValue($property, $value, $data); $object->$method($value); } } return $object; } } } namespace Zend\Stdlib\Hydrator\Filter { use ArrayObject; use Zend\Stdlib\Exception\InvalidArgumentException; class FilterComposite implements FilterInterface { protected $orFilter; protected $andFilter; const CONDITION_OR = 1; const CONDITION_AND = 2; public function __construct($orFilter = array(), $andFilter = array()) { array_walk($orFilter, function ($value, $key) { if ( !is_callable($value) && !$value instanceof FilterInterface ) { throw new InvalidArgumentException( 'The value of ' . $key . ' should be either a callable or ' . 'an instance of Zend\Stdlib\Hydrator\Filter\FilterInterface' ); } } ); array_walk($andFilter, function ($value, $key) { if ( !is_callable($value) && !$value instanceof FilterInterface ) { throw new InvalidArgumentException( 'The value of ' . $key . '  should be either a callable or ' . 'an instance of Zend\Stdlib\Hydrator\Filter\FilterInterface' ); } } ); $this->orFilter = new ArrayObject($orFilter); $this->andFilter = new ArrayObject($andFilter); } public function addFilter($name, $filter, $condition = self::CONDITION_OR) { if (!is_callable($filter) && !($filter instanceof FilterInterface)) { throw new InvalidArgumentException( 'The value of ' . $name . ' should be either a callable or ' . 'an instance of Zend\Stdlib\Hydrator\Filter\FilterInterface' ); } if ($condition === self::CONDITION_OR) { $this->orFilter[$name] = $filter; } elseif ($condition === self::CONDITION_AND) { $this->andFilter[$name] = $filter; } return $this; } public function removeFilter($name) { if (isset($this->orFilter[$name])) { unset($this->orFilter[$name]); } if (isset($this->andFilter[$name])) { unset($this->andFilter[$name]); } return $this; } public function hasFilter($name) { return isset($this->orFilter[$name]) || isset($this->andFilter[$name]); } public function filter($property) { $andCount = count($this->andFilter); $orCount = count($this->orFilter); if ($orCount === 0 && $andCount === 0) { return true; } elseif ($orCount === 0 && $andCount !== 0) { $returnValue = true; } else { $returnValue = false; } foreach ($this->orFilter as $filter) { if (is_callable($filter)) { if ($filter($property) === true) { $returnValue = true; break; } continue; } else { if ($filter->filter($property) === true) { $returnValue = true; break; } } } foreach ($this->andFilter as $filter) { if (is_callable($filter)) { if ($filter($property) === false) { return false; } continue; } else { if ($filter->filter($property) === false) { return false; } } } return $returnValue; } } } namespace Zend\Stdlib\Hydrator\NamingStrategy { use Zend\Filter\FilterChain; class UnderscoreNamingStrategy implements NamingStrategyInterface { protected static $camelCaseToUnderscoreFilter; protected static $underscoreToCamelCaseFilter; public function hydrate($name) { return lcfirst($this->getUnderscoreToCamelCaseFilter()->filter($name)); } public function extract($name) { return $this->getCamelCaseToUnderscoreFilter()->filter($name); } protected function getUnderscoreToCamelCaseFilter() { if (static::$underscoreToCamelCaseFilter instanceof FilterChain) { return static::$underscoreToCamelCaseFilter; } $filter = new FilterChain(); $filter->attachByName('WordUnderscoreToCamelCase'); static::$underscoreToCamelCaseFilter = $filter; return $filter; } protected function getCamelCaseToUnderscoreFilter() { if (static::$camelCaseToUnderscoreFilter instanceof FilterChain) { return static::$camelCaseToUnderscoreFilter; } $filter = new FilterChain(); $filter->attachByName('WordCamelCaseToUnderscore'); $filter->attachByName('StringToLower'); static::$camelCaseToUnderscoreFilter = $filter; return $filter; } } } namespace Zend\Stdlib\Hydrator\Filter { use InvalidArgumentException; use ReflectionException; use ReflectionMethod; use ReflectionParameter; class OptionalParametersFilter implements FilterInterface { protected static $propertiesCache = array(); public function filter($property) { if (isset(static::$propertiesCache[$property])) { return static::$propertiesCache[$property]; } try { $reflectionMethod = new ReflectionMethod($property); } catch (ReflectionException $exception) { throw new InvalidArgumentException(sprintf('Method %s doesn\'t exist', $property)); } $mandatoryParameters = array_filter( $reflectionMethod->getParameters(), function (ReflectionParameter $parameter) { return ! $parameter->isOptional(); } ); return static::$propertiesCache[$property] = empty($mandatoryParameters); } } } namespace Zend\Stdlib\Hydrator\Filter { class IsFilter implements FilterInterface { public function filter($property) { $pos = strpos($property, '::'); if ($pos !== false) { $pos += 2; } else { $pos = 0; } if (substr($property, $pos, 2) === 'is') { return true; } return false; } } } namespace Zend\Stdlib\Hydrator\Filter { class HasFilter implements FilterInterface { public function filter($property) { $pos = strpos($property, '::'); if ($pos !== false) { $pos += 2; } else { $pos = 0; } if (substr($property, $pos, 3) === 'has') { return true; } return false; } } } namespace Zend\Stdlib\Hydrator\Filter { class GetFilter implements FilterInterface { public function filter($property) { $pos = strpos($property, '::'); if ($pos !== false) { $pos += 2; } else { $pos = 0; } if (substr($property, $pos, 3) === 'get') { return true; } return false; } } } namespace Zend\Db\Sql\Predicate { use Zend\Db\Sql\Exception; class Operator implements PredicateInterface { const OPERATOR_EQUAL_TO = '='; const OP_EQ = '='; const OPERATOR_NOT_EQUAL_TO = '!='; const OP_NE = '!='; const OPERATOR_LESS_THAN = '<'; const OP_LT = '<'; const OPERATOR_LESS_THAN_OR_EQUAL_TO = '<='; const OP_LTE = '<='; const OPERATOR_GREATER_THAN = '>'; const OP_GT = '>'; const OPERATOR_GREATER_THAN_OR_EQUAL_TO = '>='; const OP_GTE = '>='; protected $allowedTypes = array( self::TYPE_IDENTIFIER, self::TYPE_VALUE, ); protected $left = null; protected $leftType = self::TYPE_IDENTIFIER; protected $operator = self::OPERATOR_EQUAL_TO; protected $right = null; protected $rightType = self::TYPE_VALUE; public function __construct($left = null, $operator = self::OPERATOR_EQUAL_TO, $right = null, $leftType = self::TYPE_IDENTIFIER, $rightType = self::TYPE_VALUE) { if ($left !== null) { $this->setLeft($left); } if ($operator !== self::OPERATOR_EQUAL_TO) { $this->setOperator($operator); } if ($right !== null) { $this->setRight($right); } if ($leftType !== self::TYPE_IDENTIFIER) { $this->setLeftType($leftType); } if ($rightType !== self::TYPE_VALUE) { $this->setRightType($rightType); } } public function setLeft($left) { $this->left = $left; return $this; } public function getLeft() { return $this->left; } public function setLeftType($type) { if (!in_array($type, $this->allowedTypes)) { throw new Exception\InvalidArgumentException(sprintf( 'Invalid type "%s" provided; must be of type "%s" or "%s"', $type, __CLASS__ . '::TYPE_IDENTIFIER', __CLASS__ . '::TYPE_VALUE' )); } $this->leftType = $type; return $this; } public function getLeftType() { return $this->leftType; } public function setOperator($operator) { $this->operator = $operator; return $this; } public function getOperator() { return $this->operator; } public function setRight($value) { $this->right = $value; return $this; } public function getRight() { return $this->right; } public function setRightType($type) { if (!in_array($type, $this->allowedTypes)) { throw new Exception\InvalidArgumentException(sprintf( 'Invalid type "%s" provided; must be of type "%s" or "%s"', $type, __CLASS__ . '::TYPE_IDENTIFIER', __CLASS__ . '::TYPE_VALUE' )); } $this->rightType = $type; return $this; } public function getRightType() { return $this->rightType; } public function getExpressionData() { return array(array( '%s ' . $this->operator . ' %s', array($this->left, $this->right), array($this->leftType, $this->rightType) )); } } } namespace Zend\Db\ResultSet { use ArrayObject; use Zend\Stdlib\Hydrator\ArraySerializable; use Zend\Stdlib\Hydrator\HydratorInterface; class HydratingResultSet extends AbstractResultSet { protected $hydrator = null; protected $objectPrototype = null; public function __construct(HydratorInterface $hydrator = null, $objectPrototype = null) { $this->setHydrator(($hydrator) ?: new ArraySerializable); $this->setObjectPrototype(($objectPrototype) ?: new ArrayObject); } public function setObjectPrototype($objectPrototype) { if (!is_object($objectPrototype)) { throw new Exception\InvalidArgumentException( 'An object must be set as the object prototype, a ' . gettype($objectPrototype) . ' was provided.' ); } $this->objectPrototype = $objectPrototype; return $this; } public function setHydrator(HydratorInterface $hydrator) { $this->hydrator = $hydrator; return $this; } public function getHydrator() { return $this->hydrator; } public function current() { if ($this->buffer === null) { $this->buffer = -2; } elseif (is_array($this->buffer) && isset($this->buffer[$this->position])) { return $this->buffer[$this->position]; } $data = $this->dataSource->current(); $object = is_array($data) ? $this->hydrator->hydrate($data, clone $this->objectPrototype) : false; if (is_array($this->buffer)) { $this->buffer[$this->position] = $object; } return $object; } public function toArray() { $return = array(); foreach ($this as $row) { $return[] = $this->getHydrator()->extract($row); } return $return; } } } namespace Zend\Filter\Word { use Zend\Filter\AbstractFilter; use Zend\Filter\Exception; abstract class AbstractSeparator extends AbstractFilter { protected $separator = ' '; public function __construct($separator = ' ') { if (is_array($separator)) { $temp = ' '; if (isset($separator['separator']) && is_string($separator['separator'])) { $temp = $separator['separator']; } $separator = $temp; } $this->setSeparator($separator); } public function setSeparator($separator) { if (!is_string($separator)) { throw new Exception\InvalidArgumentException('"' . $separator . '" is not a valid separator.'); } $this->separator = $separator; return $this; } public function getSeparator() { return $this->separator; } } } namespace Zend\Filter\Word { use Zend\Stdlib\StringUtils; class SeparatorToCamelCase extends AbstractSeparator { public function filter($value) { if (!is_scalar($value) && !is_array($value)) { return $value; } $pregQuotedSeparator = preg_quote($this->separator, '#'); if (StringUtils::hasPcreUnicodeSupport()) { $patterns = array( '#(' . $pregQuotedSeparator.')(\p{L}{1})#u', '#(^\p{Ll}{1})#u', ); if (!extension_loaded('mbstring')) { $replacements = array( function ($matches) { return strtoupper($matches[2]); }, function ($matches) { return strtoupper($matches[1]); }, ); } else { $replacements = array( function ($matches) { return mb_strtoupper($matches[2], 'UTF-8'); }, function ($matches) { return mb_strtoupper($matches[1], 'UTF-8'); }, ); } } else { $patterns = array( '#(' . $pregQuotedSeparator.')([A-Za-z]{1})#', '#(^[A-Za-z]{1})#', ); $replacements = array( function ($matches) { return strtoupper($matches[2]); }, function ($matches) { return strtoupper($matches[1]); }, ); } $filtered = $value; foreach ($patterns as $index => $pattern) { $filtered = preg_replace_callback($pattern, $replacements[$index], $filtered); } return $filtered; } } } namespace Zend\Filter\Word { class UnderscoreToCamelCase extends SeparatorToCamelCase { public function __construct() { parent::__construct('_'); } } } namespace Zend\I18n\View\Helper { use Zend\I18n\Translator\TranslatorInterface as Translator; use Zend\I18n\Translator\TranslatorAwareInterface; use Zend\View\Helper\AbstractHelper; abstract class AbstractTranslatorHelper extends AbstractHelper implements TranslatorAwareInterface { protected $translator; protected $translatorTextDomain = 'default'; protected $translatorEnabled = true; public function setTranslator(Translator $translator = null, $textDomain = null) { $this->translator = $translator; if (null !== $textDomain) { $this->setTranslatorTextDomain($textDomain); } return $this; } public function getTranslator() { if (! $this->isTranslatorEnabled()) { return null; } return $this->translator; } public function hasTranslator() { return (bool) $this->getTranslator(); } public function setTranslatorEnabled($enabled = true) { $this->translatorEnabled = (bool) $enabled; return $this; } public function isTranslatorEnabled() { return $this->translatorEnabled; } public function setTranslatorTextDomain($textDomain = 'default') { $this->translatorTextDomain = $textDomain; return $this; } public function getTranslatorTextDomain() { return $this->translatorTextDomain; } } } namespace Zend\I18n\View\Helper { use Zend\I18n\Exception; class Translate extends AbstractTranslatorHelper { public function __invoke($message, $textDomain = null, $locale = null) { $translator = $this->getTranslator(); if (null === $translator) { throw new Exception\RuntimeException('Translator has not been set'); } if (null === $textDomain) { $textDomain = $this->getTranslatorTextDomain(); } return $translator->translate($message, $textDomain, $locale); } } } namespace Zend\View\Helper { abstract class AbstractHtmlElement extends AbstractHelper { const EOL = PHP_EOL; protected $closingBracket = null; public function getClosingBracket() { if (!$this->closingBracket) { if ($this->isXhtml()) { $this->closingBracket = ' />'; } else { $this->closingBracket = '>'; } } return $this->closingBracket; } protected function isXhtml() { return $this->getView()->plugin('doctype')->isXhtml(); } protected function htmlAttribs($attribs) { $xhtml = ''; $escaper = $this->getView()->plugin('escapehtml'); $escapeHtmlAttr = $this->getView()->plugin('escapehtmlattr'); foreach ((array) $attribs as $key => $val) { $key = $escaper($key); if (('on' == substr($key, 0, 2)) || ('constraints' == $key)) { if (!is_scalar($val)) { $val = \Zend\Json\Json::encode($val); } } else { if (is_array($val)) { $val = implode(' ', $val); } } $val = $escapeHtmlAttr($val); if ('id' == $key) { $val = $this->normalizeId($val); } if (strpos($val, '"') !== false) { $xhtml .= " $key='$val'"; } else { $xhtml .= " $key=\"$val\""; } } return $xhtml; } protected function normalizeId($value) { if (strstr($value, '[')) { if ('[]' == substr($value, -2)) { $value = substr($value, 0, strlen($value) - 2); } $value = trim($value, ']'); $value = str_replace('][', '-', $value); $value = str_replace('[', '-', $value); } return $value; } } } namespace Zend\View\Helper\Navigation { use RecursiveIteratorIterator; use Zend\EventManager\EventManager; use Zend\EventManager\EventManagerAwareInterface; use Zend\EventManager\EventManagerInterface; use Zend\I18n\Translator\TranslatorInterface as Translator; use Zend\I18n\Translator\TranslatorAwareInterface; use Zend\Navigation; use Zend\Navigation\Page\AbstractPage; use Zend\Permissions\Acl; use Zend\ServiceManager\ServiceLocatorAwareInterface; use Zend\ServiceManager\ServiceLocatorInterface; use Zend\View; use Zend\View\Exception; abstract class AbstractHelper extends \Zend\View\Helper\AbstractHtmlElement implements EventManagerAwareInterface, HelperInterface, ServiceLocatorAwareInterface, TranslatorAwareInterface { protected $events; protected $serviceLocator; protected $container; protected $minDepth; protected $maxDepth; protected $indent = ''; protected $acl; protected $renderInvisible = false; protected $role; protected $useAcl = true; protected $translator; protected $translatorTextDomain = 'default'; protected $translatorEnabled = true; protected static $defaultAcl; protected static $defaultRole; public function __call($method, array $arguments = array()) { return call_user_func_array( array($this->getContainer(), $method), $arguments); } public function __toString() { try { return $this->render(); } catch (\Exception $e) { $msg = get_class($e) . ': ' . $e->getMessage(); trigger_error($msg, E_USER_ERROR); return ''; } } public function findActive($container, $minDepth = null, $maxDepth = -1) { $this->parseContainer($container); if (!is_int($minDepth)) { $minDepth = $this->getMinDepth(); } if ((!is_int($maxDepth) || $maxDepth < 0) && null !== $maxDepth) { $maxDepth = $this->getMaxDepth(); } $found = null; $foundDepth = -1; $iterator = new RecursiveIteratorIterator( $container, RecursiveIteratorIterator::CHILD_FIRST ); foreach ($iterator as $page) { $currDepth = $iterator->getDepth(); if ($currDepth < $minDepth || !$this->accept($page)) { continue; } if ($page->isActive(false) && $currDepth > $foundDepth) { $found = $page; $foundDepth = $currDepth; } } if (is_int($maxDepth) && $foundDepth > $maxDepth) { while ($foundDepth > $maxDepth) { if (--$foundDepth < $minDepth) { $found = null; break; } $found = $found->getParent(); if (!$found instanceof AbstractPage) { $found = null; break; } } } if ($found) { return array('page' => $found, 'depth' => $foundDepth); } return array(); } protected function parseContainer(&$container = null) { if (null === $container) { return; } if (is_string($container)) { if (!$this->getServiceLocator()) { throw new Exception\InvalidArgumentException(sprintf( 'Attempted to set container with alias "%s" but no ServiceLocator was set', $container )); } $sl = $this->getServiceLocator(); if ($sl instanceof View\HelperPluginManager) { $sl = $sl->getServiceLocator(); } $container = $sl->get($container); return; } if (!$container instanceof Navigation\AbstractContainer) { throw new Exception\InvalidArgumentException( 'Container must be a string alias or an instance of ' . 'Zend\Navigation\AbstractContainer' ); } } public function accept(AbstractPage $page, $recursive = true) { $accept = true; if (!$page->isVisible(false) && !$this->getRenderInvisible()) { $accept = false; } elseif ($this->getUseAcl()) { $acl = $this->getAcl(); $role = $this->getRole(); $params = array('acl' => $acl, 'page' => $page, 'role' => $role); $accept = $this->isAllowed($params); } if ($accept && $recursive) { $parent = $page->getParent(); if ($parent instanceof AbstractPage) { $accept = $this->accept($parent, true); } } return $accept; } protected function isAllowed($params) { $results = $this->getEventManager()->trigger(__FUNCTION__, $this, $params); return $results->last(); } protected function getWhitespace($indent) { if (is_int($indent)) { $indent = str_repeat(' ', $indent); } return (string) $indent; } protected function htmlAttribs($attribs) { foreach ($attribs as $key => $value) { if ($value === null || (is_string($value) && !strlen($value))) { unset($attribs[$key]); } } return parent::htmlAttribs($attribs); } public function htmlify(AbstractPage $page) { $label = $this->translate($page->getLabel(), $page->getTextDomain()); $title = $this->translate($page->getTitle(), $page->getTextDomain()); $attribs = array( 'id' => $page->getId(), 'title' => $title, 'class' => $page->getClass(), 'href' => $page->getHref(), 'target' => $page->getTarget() ); $escaper = $this->view->plugin('escapeHtml'); $label = $escaper($label); return '<a' . $this->htmlAttribs($attribs) . '>' . $label . '</a>'; } protected function translate($message, $textDomain = null) { if (is_string($message) && !empty($message)) { if (null !== ($translator = $this->getTranslator())) { if (null === $textDomain) { $textDomain = $this->getTranslatorTextDomain(); } return $translator->translate($message, $textDomain); } } return $message; } protected function normalizeId($value) { $prefix = get_class($this); $prefix = strtolower(trim(substr($prefix, strrpos($prefix, '\\')), '\\')); return $prefix . '-' . $value; } public function setAcl(Acl\AclInterface $acl = null) { $this->acl = $acl; return $this; } public function getAcl() { if ($this->acl === null && static::$defaultAcl !== null) { return static::$defaultAcl; } return $this->acl; } public function hasAcl() { if ($this->acl instanceof Acl\Acl || static::$defaultAcl instanceof Acl\Acl ) { return true; } return false; } public function setEventManager(EventManagerInterface $events) { $events->setIdentifiers(array( __CLASS__, get_called_class(), )); $this->events = $events; $this->setDefaultListeners(); return $this; } public function getEventManager() { if (null === $this->events) { $this->setEventManager(new EventManager()); } return $this->events; } public function setContainer($container = null) { $this->parseContainer($container); $this->container = $container; return $this; } public function getContainer() { if (null === $this->container) { $this->container = new Navigation\Navigation(); } return $this->container; } public function hasContainer() { return null !== $this->container; } public function setIndent($indent) { $this->indent = $this->getWhitespace($indent); return $this; } public function getIndent() { return $this->indent; } public function setMaxDepth($maxDepth = null) { if (null === $maxDepth || is_int($maxDepth)) { $this->maxDepth = $maxDepth; } else { $this->maxDepth = (int) $maxDepth; } return $this; } public function getMaxDepth() { return $this->maxDepth; } public function setMinDepth($minDepth = null) { if (null === $minDepth || is_int($minDepth)) { $this->minDepth = $minDepth; } else { $this->minDepth = (int) $minDepth; } return $this; } public function getMinDepth() { if (!is_int($this->minDepth) || $this->minDepth < 0) { return 0; } return $this->minDepth; } public function setRenderInvisible($renderInvisible = true) { $this->renderInvisible = (bool) $renderInvisible; return $this; } public function getRenderInvisible() { return $this->renderInvisible; } public function setRole($role = null) { if (null === $role || is_string($role) || $role instanceof Acl\Role\RoleInterface ) { $this->role = $role; } else { throw new Exception\InvalidArgumentException(sprintf( '$role must be a string, null, or an instance of ' . 'Zend\Permissions\Role\RoleInterface; %s given', (is_object($role) ? get_class($role) : gettype($role)) )); } return $this; } public function getRole() { if ($this->role === null && static::$defaultRole !== null) { return static::$defaultRole; } return $this->role; } public function hasRole() { if ($this->role instanceof Acl\Role\RoleInterface || is_string($this->role) || static::$defaultRole instanceof Acl\Role\RoleInterface || is_string(static::$defaultRole) ) { return true; } return false; } public function setServiceLocator(ServiceLocatorInterface $serviceLocator) { $this->serviceLocator = $serviceLocator; return $this; } public function getServiceLocator() { return $this->serviceLocator; } public function setTranslator(Translator $translator = null, $textDomain = null) { $this->translator = $translator; if (null !== $textDomain) { $this->setTranslatorTextDomain($textDomain); } return $this; } public function getTranslator() { if (! $this->isTranslatorEnabled()) { return null; } return $this->translator; } public function hasTranslator() { return (bool) $this->getTranslator(); } public function setTranslatorEnabled($enabled = true) { $this->translatorEnabled = (bool) $enabled; return $this; } public function isTranslatorEnabled() { return $this->translatorEnabled; } public function setTranslatorTextDomain($textDomain = 'default') { $this->translatorTextDomain = $textDomain; return $this; } public function getTranslatorTextDomain() { return $this->translatorTextDomain; } public function setUseAcl($useAcl = true) { $this->useAcl = (bool) $useAcl; return $this; } public function getUseAcl() { return $this->useAcl; } public static function setDefaultAcl(Acl\AclInterface $acl = null) { static::$defaultAcl = $acl; } public static function setDefaultRole($role = null) { if (null === $role || is_string($role) || $role instanceof Acl\Role\RoleInterface ) { static::$defaultRole = $role; } else { throw new Exception\InvalidArgumentException(sprintf( '$role must be null|string|Zend\Permissions\Role\RoleInterface; received "%s"', (is_object($role) ? get_class($role) : gettype($role)) )); } } protected function setDefaultListeners() { if (!$this->getUseAcl()) { return; } $this->getEventManager()->getSharedManager()->attach( 'Zend\View\Helper\Navigation\AbstractHelper', 'isAllowed', array('Zend\View\Helper\Navigation\Listener\AclListener', 'accept') ); } } } namespace Zend\View\Helper { use Zend\Navigation\AbstractContainer; use Zend\ServiceManager\ServiceLocatorAwareInterface; use Zend\View\Exception; use Zend\View\Helper\Navigation\AbstractHelper as AbstractNavigationHelper; use Zend\View\Helper\Navigation\HelperInterface as NavigationHelper; use Zend\View\Renderer\RendererInterface as Renderer; class Navigation extends AbstractNavigationHelper { const NS = 'Zend\View\Helper\Navigation'; protected $defaultProxy = 'menu'; protected $injected = array(); protected $injectAcl = true; protected $injectContainer = true; protected $injectTranslator = true; protected $plugins; public function __invoke($container = null) { if (null !== $container) { $this->setContainer($container); } return $this; } public function __call($method, array $arguments = array()) { $helper = $this->findHelper($method, false); if ($helper) { if ($helper instanceof ServiceLocatorAwareInterface && $this->getServiceLocator()) { $helper->setServiceLocator($this->getServiceLocator()); } return call_user_func_array($helper, $arguments); } return parent::__call($method, $arguments); } public function render($container = null) { return $this->findHelper($this->getDefaultProxy())->render($container); } public function findHelper($proxy, $strict = true) { $plugins = $this->getPluginManager(); if (!$plugins->has($proxy)) { if ($strict) { throw new Exception\RuntimeException(sprintf( 'Failed to find plugin for %s', $proxy )); } return false; } $helper = $plugins->get($proxy); $container = $this->getContainer(); $hash = spl_object_hash($container) . spl_object_hash($helper); if (!isset($this->injected[$hash])) { $helper->setContainer(); $this->inject($helper); $this->injected[$hash] = true; } else { if ($this->getInjectContainer()) { $helper->setContainer($container); } } return $helper; } protected function inject(NavigationHelper $helper) { if ($this->getInjectContainer() && !$helper->hasContainer()) { $helper->setContainer($this->getContainer()); } if ($this->getInjectAcl()) { if (!$helper->hasAcl()) { $helper->setAcl($this->getAcl()); } if (!$helper->hasRole()) { $helper->setRole($this->getRole()); } } if ($this->getInjectTranslator() && !$helper->hasTranslator()) { $helper->setTranslator( $this->getTranslator(), $this->getTranslatorTextDomain() ); } } public function setDefaultProxy($proxy) { $this->defaultProxy = (string) $proxy; return $this; } public function getDefaultProxy() { return $this->defaultProxy; } public function setInjectContainer($injectContainer = true) { $this->injectContainer = (bool) $injectContainer; return $this; } public function getInjectContainer() { return $this->injectContainer; } public function setInjectAcl($injectAcl = true) { $this->injectAcl = (bool) $injectAcl; return $this; } public function getInjectAcl() { return $this->injectAcl; } public function setInjectTranslator($injectTranslator = true) { $this->injectTranslator = (bool) $injectTranslator; return $this; } public function getInjectTranslator() { return $this->injectTranslator; } public function setPluginManager(Navigation\PluginManager $plugins) { $renderer = $this->getView(); if ($renderer) { $plugins->setRenderer($renderer); } $this->plugins = $plugins; return $this; } public function getPluginManager() { if (null === $this->plugins) { $this->setPluginManager(new Navigation\PluginManager()); } return $this->plugins; } public function setView(Renderer $view) { parent::setView($view); if ($view && $this->plugins) { $this->plugins->setRenderer($view); } return $this; } } } namespace Zend\Navigation\Service { use Zend\Config; use Zend\Http\Request; use Zend\Mvc\Router\RouteMatch; use Zend\Mvc\Router\RouteStackInterface as Router; use Zend\Navigation\Exception; use Zend\Navigation\Navigation; use Zend\ServiceManager\FactoryInterface; use Zend\ServiceManager\ServiceLocatorInterface; abstract class AbstractNavigationFactory implements FactoryInterface { protected $pages; public function createService(ServiceLocatorInterface $serviceLocator) { $pages = $this->getPages($serviceLocator); return new Navigation($pages); } abstract protected function getName(); protected function getPages(ServiceLocatorInterface $serviceLocator) { if (null === $this->pages) { $configuration = $serviceLocator->get('Config'); if (!isset($configuration['navigation'])) { throw new Exception\InvalidArgumentException('Could not find navigation configuration key'); } if (!isset($configuration['navigation'][$this->getName()])) { throw new Exception\InvalidArgumentException(sprintf( 'Failed to find a navigation container by the name "%s"', $this->getName() )); } $pages = $this->getPagesFromConfig($configuration['navigation'][$this->getName()]); $this->pages = $this->preparePages($serviceLocator, $pages); } return $this->pages; } protected function preparePages(ServiceLocatorInterface $serviceLocator, $pages) { $application = $serviceLocator->get('Application'); $routeMatch = $application->getMvcEvent()->getRouteMatch(); $router = $application->getMvcEvent()->getRouter(); $request = $application->getMvcEvent()->getRequest(); if (!$request instanceof Request) { $request = null; } return $this->injectComponents($pages, $routeMatch, $router, $request); } protected function getPagesFromConfig($config = null) { if (is_string($config)) { if (file_exists($config)) { $config = Config\Factory::fromFile($config); } else { throw new Exception\InvalidArgumentException(sprintf( 'Config was a string but file "%s" does not exist', $config )); } } elseif ($config instanceof Config\Config) { $config = $config->toArray(); } elseif (!is_array($config)) { throw new Exception\InvalidArgumentException( 'Invalid input, expected array, filename, or Zend\Config object' ); } return $config; } protected function injectComponents(array $pages, RouteMatch $routeMatch = null, Router $router = null, $request = null) { foreach ($pages as &$page) { $hasUri = isset($page['uri']); $hasMvc = isset($page['action']) || isset($page['controller']) || isset($page['route']); if ($hasMvc) { if (!isset($page['routeMatch']) && $routeMatch) { $page['routeMatch'] = $routeMatch; } if (!isset($page['router'])) { $page['router'] = $router; } } elseif ($hasUri) { if (!isset($page['request'])) { $page['request'] = $request; } } if (isset($page['pages'])) { $page['pages'] = $this->injectComponents($page['pages'], $routeMatch, $router, $request); } } return $pages; } } } namespace Zend\Navigation\Service { class DefaultNavigationFactory extends AbstractNavigationFactory { protected function getName() { return 'default'; } } } namespace Zend\Navigation { use Countable; use RecursiveIterator; use RecursiveIteratorIterator; use Traversable; use Zend\Stdlib\ErrorHandler; abstract class AbstractContainer implements Countable, RecursiveIterator { protected $pages = array(); protected $index = array(); protected $dirtyIndex = false; protected function sort() { if (!$this->dirtyIndex) { return; } $newIndex = array(); $index = 0; foreach ($this->pages as $hash => $page) { $order = $page->getOrder(); if ($order === null) { $newIndex[$hash] = $index; $index++; } else { $newIndex[$hash] = $order; } } asort($newIndex); $this->index = $newIndex; $this->dirtyIndex = false; } public function notifyOrderUpdated() { $this->dirtyIndex = true; } public function addPage($page) { if ($page === $this) { throw new Exception\InvalidArgumentException( 'A page cannot have itself as a parent' ); } if (!$page instanceof Page\AbstractPage) { if (!is_array($page) && !$page instanceof Traversable) { throw new Exception\InvalidArgumentException( 'Invalid argument: $page must be an instance of ' . 'Zend\Navigation\Page\AbstractPage or Traversable, or an array' ); } $page = Page\AbstractPage::factory($page); } $hash = $page->hashCode(); if (array_key_exists($hash, $this->index)) { return $this; } $this->pages[$hash] = $page; $this->index[$hash] = $page->getOrder(); $this->dirtyIndex = true; $page->setParent($this); return $this; } public function addPages($pages) { if (!is_array($pages) && !$pages instanceof Traversable) { throw new Exception\InvalidArgumentException( 'Invalid argument: $pages must be an array, an ' . 'instance of Traversable or an instance of ' . 'Zend\Navigation\AbstractContainer' ); } if ($pages instanceof AbstractContainer) { $pages = iterator_to_array($pages); } foreach ($pages as $page) { if (null === $page) { continue; } $this->addPage($page); } return $this; } public function setPages(array $pages) { $this->removePages(); return $this->addPages($pages); } public function getPages() { return $this->pages; } public function removePage($page, $recursive = false) { if ($page instanceof Page\AbstractPage) { $hash = $page->hashCode(); } elseif (is_int($page)) { $this->sort(); if (!$hash = array_search($page, $this->index)) { return false; } } else { return false; } if (isset($this->pages[$hash])) { unset($this->pages[$hash]); unset($this->index[$hash]); $this->dirtyIndex = true; return true; } if ($recursive) { foreach ($this->pages as $childPage) { if ($childPage->hasPage($page, true)) { $childPage->removePage($page, true); return true; } } } return false; } public function removePages() { $this->pages = array(); $this->index = array(); return $this; } public function hasPage(Page\AbstractPage $page, $recursive = false) { if (array_key_exists($page->hashCode(), $this->index)) { return true; } elseif ($recursive) { foreach ($this->pages as $childPage) { if ($childPage->hasPage($page, true)) { return true; } } } return false; } public function hasPages($onlyVisible = false) { if ($onlyVisible) { foreach ($this->pages as $page) { if ($page->isVisible()) { return true; } } return false; } return count($this->index) > 0; } public function findOneBy($property, $value) { $iterator = new RecursiveIteratorIterator($this, RecursiveIteratorIterator::SELF_FIRST); foreach ($iterator as $page) { if ($page->get($property) == $value) { return $page; } } return null; } public function findAllBy($property, $value) { $found = array(); $iterator = new RecursiveIteratorIterator($this, RecursiveIteratorIterator::SELF_FIRST); foreach ($iterator as $page) { if ($page->get($property) == $value) { $found[] = $page; } } return $found; } public function findBy($property, $value, $all = false) { if ($all) { return $this->findAllBy($property, $value); } return $this->findOneBy($property, $value); } public function __call($method, $arguments) { ErrorHandler::start(E_WARNING); $result = preg_match('/(find(?:One|All)?By)(.+)/', $method, $match); $error = ErrorHandler::stop(); if (!$result) { throw new Exception\BadMethodCallException(sprintf( 'Bad method call: Unknown method %s::%s', get_class($this), $method ), 0, $error); } return $this->{$match[1]}($match[2], $arguments[0]); } public function toArray() { $this->sort(); $pages = array(); $indexes = array_keys($this->index); foreach ($indexes as $hash) { $pages[] = $this->pages[$hash]->toArray(); } return $pages; } public function current() { $this->sort(); current($this->index); $hash = key($this->index); if (!isset($this->pages[$hash])) { throw new Exception\OutOfBoundsException( 'Corruption detected in container; ' . 'invalid key found in internal iterator' ); } return $this->pages[$hash]; } public function key() { $this->sort(); return key($this->index); } public function next() { $this->sort(); next($this->index); } public function rewind() { $this->sort(); reset($this->index); } public function valid() { $this->sort(); return current($this->index) !== false; } public function hasChildren() { return $this->hasPages(); } public function getChildren() { $hash = key($this->index); if (isset($this->pages[$hash])) { return $this->pages[$hash]; } return null; } public function count() { return count($this->index); } } } namespace Zend\Navigation { use Traversable; class Navigation extends AbstractContainer { public function __construct($pages = null) { if ($pages && (!is_array($pages) && !$pages instanceof Traversable)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $pages must be an array, an ' . 'instance of Traversable, or null' ); } if ($pages) { $this->addPages($pages); } } } } namespace Zend\Navigation\Page { use Traversable; use Zend\Navigation\AbstractContainer; use Zend\Navigation\Exception; use Zend\Permissions\Acl\Resource\ResourceInterface as AclResource; use Zend\Stdlib\ArrayUtils; abstract class AbstractPage extends AbstractContainer { protected $label; protected $fragment; protected $id; protected $class; protected $title; protected $target; protected $rel = array(); protected $rev = array(); protected $order; protected $resource; protected $privilege; protected $permission; protected $textDomain; protected $active = false; protected $visible = true; protected $parent; protected $properties = array(); protected static $factories = array(); public static function factory($options) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } if (!is_array($options)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $options must be an array or Traversable' ); } if (isset($options['type'])) { $type = $options['type']; if (is_string($type) && !empty($type)) { switch (strtolower($type)) { case 'mvc': $type = 'Zend\Navigation\Page\Mvc'; break; case 'uri': $type = 'Zend\Navigation\Page\Uri'; break; } if (!class_exists($type, true)) { throw new Exception\InvalidArgumentException( 'Cannot find class ' . $type ); } $page = new $type($options); if (!$page instanceof self) { throw new Exception\InvalidArgumentException( sprintf( 'Invalid argument: Detected type "%s", which ' . 'is not an instance of Zend\Navigation\Page', $type ) ); } return $page; } } if (static::$factories) { foreach (static::$factories as $factoryCallBack) { if (($page = call_user_func($factoryCallBack, $options))) { return $page; } } } $hasUri = isset($options['uri']); $hasMvc = isset($options['action']) || isset($options['controller']) || isset($options['route']); if ($hasMvc) { return new Mvc($options); } elseif ($hasUri) { return new Uri($options); } else { throw new Exception\InvalidArgumentException( 'Invalid argument: Unable to determine class to instantiate' ); } } public static function addFactory($callback) { static::$factories[] = $callback; } public function __construct($options = null) { if ($options instanceof Traversable) { $options = ArrayUtils::iteratorToArray($options); } if (is_array($options)) { $this->setOptions($options); } $this->init(); } protected function init() { } public function setOptions(array $options) { foreach ($options as $key => $value) { $this->set($key, $value); } return $this; } public function setLabel($label) { if (null !== $label && !is_string($label)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $label must be a string or null' ); } $this->label = $label; return $this; } public function getLabel() { return $this->label; } public function setFragment($fragment) { if (null !== $fragment && !is_string($fragment)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $fragment must be a string or null' ); } $this->fragment = $fragment; return $this; } public function getFragment() { return $this->fragment; } public function setId($id = null) { if (null !== $id && !is_string($id) && !is_numeric($id)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $id must be a string, number or null' ); } $this->id = null === $id ? $id : (string) $id; return $this; } public function getId() { return $this->id; } public function setClass($class = null) { if (null !== $class && !is_string($class)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $class must be a string or null' ); } $this->class = $class; return $this; } public function getClass() { return $this->class; } public function setTitle($title = null) { if (null !== $title && !is_string($title)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $title must be a non-empty string' ); } $this->title = $title; return $this; } public function getTitle() { return $this->title; } public function setTarget($target = null) { if (null !== $target && !is_string($target)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $target must be a string or null' ); } $this->target = $target; return $this; } public function getTarget() { return $this->target; } public function setRel($relations = null) { $this->rel = array(); if (null !== $relations) { if ($relations instanceof Traversable) { $relations = ArrayUtils::iteratorToArray($relations); } if (!is_array($relations)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $relations must be an ' . 'array or an instance of Traversable' ); } foreach ($relations as $name => $relation) { if (is_string($name)) { $this->rel[$name] = $relation; } } } return $this; } public function getRel($relation = null) { if (null !== $relation) { return isset($this->rel[$relation]) ? $this->rel[$relation] : null; } return $this->rel; } public function setRev($relations = null) { $this->rev = array(); if (null !== $relations) { if ($relations instanceof Traversable) { $relations = ArrayUtils::iteratorToArray($relations); } if (!is_array($relations)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $relations must be an ' . 'array or an instance of Traversable' ); } foreach ($relations as $name => $relation) { if (is_string($name)) { $this->rev[$name] = $relation; } } } return $this; } public function getRev($relation = null) { if (null !== $relation) { return isset($this->rev[$relation]) ? $this->rev[$relation] : null; } return $this->rev; } public function setOrder($order = null) { if (is_string($order)) { $temp = (int) $order; if ($temp < 0 || $temp > 0 || $order == '0') { $order = $temp; } } if (null !== $order && !is_int($order)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $order must be an integer or null, ' . 'or a string that casts to an integer' ); } $this->order = $order; if (isset($this->parent)) { $this->parent->notifyOrderUpdated(); } return $this; } public function getOrder() { return $this->order; } public function setResource($resource = null) { if (null === $resource || is_string($resource) || $resource instanceof AclResource ) { $this->resource = $resource; } else { throw new Exception\InvalidArgumentException( 'Invalid argument: $resource must be null, a string, ' . 'or an instance of Zend\Permissions\Acl\Resource\ResourceInterface' ); } return $this; } public function getResource() { return $this->resource; } public function setPrivilege($privilege = null) { $this->privilege = is_string($privilege) ? $privilege : null; return $this; } public function getPrivilege() { return $this->privilege; } public function setPermission($permission = null) { $this->permission = $permission; return $this; } public function getPermission() { return $this->permission; } public function setTextDomain($textDomain = null) { if (null !== $textDomain) { $this->textDomain = $textDomain; } return $this; } public function getTextDomain() { return $this->textDomain; } public function setActive($active = true) { $this->active = (bool) $active; return $this; } public function isActive($recursive = false) { if (!$this->active && $recursive) { foreach ($this->pages as $page) { if ($page->isActive(true)) { return true; } } return false; } return $this->active; } public function getActive($recursive = false) { return $this->isActive($recursive); } public function setVisible($visible = true) { if (is_string($visible) && 'false' == strtolower($visible)) { $visible = false; } $this->visible = (bool) $visible; return $this; } public function isVisible($recursive = false) { if ($recursive && isset($this->parent) && $this->parent instanceof self ) { if (!$this->parent->isVisible(true)) { return false; } } return $this->visible; } public function getVisible($recursive = false) { return $this->isVisible($recursive); } public function setParent(AbstractContainer $parent = null) { if ($parent === $this) { throw new Exception\InvalidArgumentException( 'A page cannot have itself as a parent' ); } if ($parent === $this->parent) { return $this; } if (null !== $this->parent) { $this->parent->removePage($this); } $this->parent = $parent; if (null !== $this->parent && !$this->parent->hasPage($this, false)) { $this->parent->addPage($this); } return $this; } public function getParent() { return $this->parent; } public function set($property, $value) { if (!is_string($property) || empty($property)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $property must be a non-empty string' ); } $method = 'set' . static::normalizePropertyName($property); if ($method != 'setOptions' && method_exists($this, $method) ) { $this->$method($value); } else { $this->properties[$property] = $value; } return $this; } public function get($property) { if (!is_string($property) || empty($property)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $property must be a non-empty string' ); } $method = 'get' . static::normalizePropertyName($property); if (method_exists($this, $method)) { return $this->$method(); } elseif (isset($this->properties[$property])) { return $this->properties[$property]; } return null; } public function __set($name, $value) { $this->set($name, $value); } public function __get($name) { return $this->get($name); } public function __isset($name) { $method = 'get' . static::normalizePropertyName($name); if (method_exists($this, $method)) { return true; } return isset($this->properties[$name]); } public function __unset($name) { $method = 'set' . static::normalizePropertyName($name); if (method_exists($this, $method)) { throw new Exception\InvalidArgumentException( sprintf( 'Unsetting native property "%s" is not allowed', $name ) ); } if (isset($this->properties[$name])) { unset($this->properties[$name]); } } public function __toString() { return $this->label; } public function addRel($relation, $value) { if (is_string($relation)) { $this->rel[$relation] = $value; } return $this; } public function addRev($relation, $value) { if (is_string($relation)) { $this->rev[$relation] = $value; } return $this; } public function removeRel($relation) { if (isset($this->rel[$relation])) { unset($this->rel[$relation]); } return $this; } public function removeRev($relation) { if (isset($this->rev[$relation])) { unset($this->rev[$relation]); } return $this; } public function getDefinedRel() { return array_keys($this->rel); } public function getDefinedRev() { return array_keys($this->rev); } public function getCustomProperties() { return $this->properties; } final public function hashCode() { return spl_object_hash($this); } public function toArray() { return array_merge($this->getCustomProperties(), array( 'label' => $this->getLabel(), 'fragment' => $this->getFragment(), 'id' => $this->getId(), 'class' => $this->getClass(), 'title' => $this->getTitle(), 'target' => $this->getTarget(), 'rel' => $this->getRel(), 'rev' => $this->getRev(), 'order' => $this->getOrder(), 'resource' => $this->getResource(), 'privilege' => $this->getPrivilege(), 'permission' => $this->getPermission(), 'active' => $this->isActive(), 'visible' => $this->isVisible(), 'type' => get_class($this), 'pages' => parent::toArray(), )); } protected static function normalizePropertyName($property) { return str_replace(' ', '', ucwords(str_replace('_', ' ', $property))); } abstract public function getHref(); } } namespace Zend\Navigation\Page { use Zend\Mvc\ModuleRouteListener; use Zend\Mvc\Router\RouteMatch; use Zend\Mvc\Router\RouteStackInterface; use Zend\Navigation\Exception; class Mvc extends AbstractPage { protected $action; protected $controller; protected $query; protected $params = array(); protected $route; protected $hrefCache; protected $routeMatch; protected $useRouteMatch = false; protected $router = null; protected static $defaultRouter = null; protected static $defaultRoute = null; public function isActive($recursive = false) { if (!$this->active) { $reqParams = array(); if ($this->routeMatch instanceof RouteMatch) { $reqParams = $this->routeMatch->getParams(); if (isset($reqParams[ModuleRouteListener::ORIGINAL_CONTROLLER])) { $reqParams['controller'] = $reqParams[ModuleRouteListener::ORIGINAL_CONTROLLER]; } $myParams = $this->params; if (null !== $this->controller) { $myParams['controller'] = $this->controller; } if (null !== $this->action) { $myParams['action'] = $this->action; } if (null !== $this->getRoute()) { if ( $this->routeMatch->getMatchedRouteName() === $this->getRoute() && (count(array_intersect_assoc($reqParams, $myParams)) == count($myParams)) ) { $this->active = true; return $this->active; } else { return parent::isActive($recursive); } } } $myParams = $this->params; if (null !== $this->controller) { $myParams['controller'] = $this->controller; } else { $myParams['controller'] = 'index'; } if (null !== $this->action) { $myParams['action'] = $this->action; } else { $myParams['action'] = 'index'; } if (count(array_intersect_assoc($reqParams, $myParams)) == count($myParams)) { $this->active = true; return true; } } return parent::isActive($recursive); } public function getHref() { if ($this->hrefCache) { return $this->hrefCache; } $router = $this->router; if (null === $router) { $router = static::$defaultRouter; } if (!$router instanceof RouteStackInterface) { throw new Exception\DomainException( __METHOD__ . ' cannot execute as no Zend\Mvc\Router\RouteStackInterface instance is composed' ); } if ($this->useRouteMatch() && $this->getRouteMatch()) { $rmParams = $this->getRouteMatch()->getParams(); if (isset($rmParams[ModuleRouteListener::ORIGINAL_CONTROLLER])) { $rmParams['controller'] = $rmParams[ModuleRouteListener::ORIGINAL_CONTROLLER]; unset($rmParams[ModuleRouteListener::ORIGINAL_CONTROLLER]); } if (isset($rmParams[ModuleRouteListener::MODULE_NAMESPACE])) { unset($rmParams[ModuleRouteListener::MODULE_NAMESPACE]); } $params = array_merge($rmParams, $this->getParams()); } else { $params = $this->getParams(); } if (($param = $this->getController()) != null) { $params['controller'] = $param; } if (($param = $this->getAction()) != null) { $params['action'] = $param; } switch (true) { case ($this->getRoute() !== null || static::getDefaultRoute() !== null): $name = ($this->getRoute() !== null) ? $this->getRoute() : static::getDefaultRoute(); break; case ($this->getRouteMatch() !== null): $name = $this->getRouteMatch()->getMatchedRouteName(); break; default: throw new Exception\DomainException('No route name could be found'); } $options = array('name' => $name); $fragment = $this->getFragment(); if (null !== $fragment) { $options['fragment'] = $fragment; } if (null !== ($query = $this->getQuery())) { $options['query'] = $query; } $url = $router->assemble($params, $options); return $this->hrefCache = $url; } public function setAction($action) { if (null !== $action && !is_string($action)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $action must be a string or null' ); } $this->action = $action; $this->hrefCache = null; return $this; } public function getAction() { return $this->action; } public function setController($controller) { if (null !== $controller && !is_string($controller)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $controller must be a string or null' ); } $this->controller = $controller; $this->hrefCache = null; return $this; } public function getController() { return $this->controller; } public function setQuery($query) { $this->query = $query; $this->hrefCache = null; return $this; } public function getQuery() { return $this->query; } public function setParams(array $params = null) { $this->params = empty($params) ? array() : $params; $this->hrefCache = null; return $this; } public function getParams() { return $this->params; } public function setRoute($route) { if (null !== $route && (!is_string($route) || strlen($route) < 1)) { throw new Exception\InvalidArgumentException( 'Invalid argument: $route must be a non-empty string or null' ); } $this->route = $route; $this->hrefCache = null; return $this; } public function getRoute() { return $this->route; } public function getRouteMatch() { return $this->routeMatch; } public function setRouteMatch(RouteMatch $matches) { $this->routeMatch = $matches; return $this; } public function useRouteMatch() { return $this->useRouteMatch; } public function setUseRouteMatch($useRouteMatch = true) { $this->useRouteMatch = (bool) $useRouteMatch; $this->hrefCache = null; return $this; } public function getRouter() { return $this->router; } public function setRouter(RouteStackInterface $router) { $this->router = $router; return $this; } public static function setDefaultRouter($router) { static::$defaultRouter = $router; } public static function getDefaultRouter() { return static::$defaultRouter; } public static function setDefaultRoute($route) { static::$defaultRoute = $route; } public static function getDefaultRoute() { return static::$defaultRoute; } public function toArray() { return array_merge( parent::toArray(), array( 'action' => $this->getAction(), 'controller' => $this->getController(), 'params' => $this->getParams(), 'route' => $this->getRoute(), 'router' => $this->getRouter(), 'route_match' => $this->getRouteMatch(), ) ); } } } namespace Zend\View\Helper\Navigation { use Zend\View\Exception; use Zend\View\HelperPluginManager; class PluginManager extends HelperPluginManager { protected $invokableClasses = array( 'breadcrumbs' => 'Zend\View\Helper\Navigation\Breadcrumbs', 'links' => 'Zend\View\Helper\Navigation\Links', 'menu' => 'Zend\View\Helper\Navigation\Menu', 'sitemap' => 'Zend\View\Helper\Navigation\Sitemap', ); public function validatePlugin($plugin) { if ($plugin instanceof AbstractHelper) { return; } throw new Exception\InvalidArgumentException(sprintf( 'Plugin of type %s is invalid; must implement %s\AbstractHelper', (is_object($plugin) ? get_class($plugin) : gettype($plugin)), __NAMESPACE__ )); } } } namespace Zend\View\Helper\Navigation { use RecursiveIteratorIterator; use Zend\Navigation\AbstractContainer; use Zend\Navigation\Page\AbstractPage; use Zend\View; use Zend\View\Exception; class Menu extends AbstractHelper { protected $addClassToListItem = false; protected $escapeLabels = true; protected $onlyActiveBranch = false; protected $partial = null; protected $renderParents = true; protected $ulClass = 'navigation'; protected $liActiveClass = 'active'; public function __invoke($container = null) { if (null !== $container) { $this->setContainer($container); } return $this; } public function render($container = null) { $partial = $this->getPartial(); if ($partial) { return $this->renderPartial($container, $partial); } return $this->renderMenu($container); } protected function renderDeepestMenu( AbstractContainer $container, $ulClass, $indent, $minDepth, $maxDepth, $escapeLabels, $addClassToListItem, $liActiveClass ) { if (!$active = $this->findActive($container, $minDepth - 1, $maxDepth)) { return ''; } if ($active['depth'] < $minDepth) { if (!$active['page']->hasPages(!$this->renderInvisible)) { return ''; } } elseif (!$active['page']->hasPages(!$this->renderInvisible)) { $active['page'] = $active['page']->getParent(); } elseif (is_int($maxDepth) && $active['depth'] +1 > $maxDepth) { $active['page'] = $active['page']->getParent(); } $escaper = $this->view->plugin('escapeHtmlAttr'); $ulClass = $ulClass ? ' class="' . $escaper($ulClass) . '"' : ''; $html = $indent . '<ul' . $ulClass . '>' . PHP_EOL; foreach ($active['page'] as $subPage) { if (!$this->accept($subPage)) { continue; } $liClasses = array(); if ($subPage->isActive(true)) { $liClasses[] = $liActiveClass; } if ($addClassToListItem && $subPage->getClass()) { $liClasses[] = $subPage->getClass(); } $liClass = empty($liClasses) ? '' : ' class="' . $escaper(implode(' ', $liClasses)) . '"'; $html .= $indent . '    <li' . $liClass . '>' . PHP_EOL; $html .= $indent . '        ' . $this->htmlify($subPage, $escapeLabels, $addClassToListItem) . PHP_EOL; $html .= $indent . '    </li>' . PHP_EOL; } $html .= $indent . '</ul>'; return $html; } public function renderMenu($container = null, array $options = array()) { $this->parseContainer($container); if (null === $container) { $container = $this->getContainer(); } $options = $this->normalizeOptions($options); if ($options['onlyActiveBranch'] && !$options['renderParents']) { $html = $this->renderDeepestMenu($container, $options['ulClass'], $options['indent'], $options['minDepth'], $options['maxDepth'], $options['escapeLabels'], $options['addClassToListItem'], $options['liActiveClass'] ); } else { $html = $this->renderNormalMenu($container, $options['ulClass'], $options['indent'], $options['minDepth'], $options['maxDepth'], $options['onlyActiveBranch'], $options['escapeLabels'], $options['addClassToListItem'], $options['liActiveClass'] ); } return $html; } protected function renderNormalMenu( AbstractContainer $container, $ulClass, $indent, $minDepth, $maxDepth, $onlyActive, $escapeLabels, $addClassToListItem, $liActiveClass ) { $html = ''; $found = $this->findActive($container, $minDepth, $maxDepth); $escaper = $this->view->plugin('escapeHtmlAttr'); if ($found) { $foundPage = $found['page']; $foundDepth = $found['depth']; } else { $foundPage = null; } $iterator = new RecursiveIteratorIterator($container, RecursiveIteratorIterator::SELF_FIRST); if (is_int($maxDepth)) { $iterator->setMaxDepth($maxDepth); } $prevDepth = -1; foreach ($iterator as $page) { $depth = $iterator->getDepth(); $isActive = $page->isActive(true); if ($depth < $minDepth || !$this->accept($page)) { continue; } elseif ($onlyActive && !$isActive) { $accept = false; if ($foundPage) { if ($foundPage->hasPage($page)) { $accept = true; } elseif ($foundPage->getParent()->hasPage($page)) { if (!$foundPage->hasPages(!$this->renderInvisible) || is_int($maxDepth) && $foundDepth + 1 > $maxDepth) { $accept = true; } } } if (!$accept) { continue; } } $depth -= $minDepth; $myIndent = $indent . str_repeat('        ', $depth); if ($depth > $prevDepth) { if ($ulClass && $depth == 0) { $ulClass = ' class="' . $escaper($ulClass) . '"'; } else { $ulClass = ''; } $html .= $myIndent . '<ul' . $ulClass . '>' . PHP_EOL; } elseif ($prevDepth > $depth) { for ($i = $prevDepth; $i > $depth; $i--) { $ind = $indent . str_repeat('        ', $i); $html .= $ind . '    </li>' . PHP_EOL; $html .= $ind . '</ul>' . PHP_EOL; } $html .= $myIndent . '    </li>' . PHP_EOL; } else { $html .= $myIndent . '    </li>' . PHP_EOL; } $liClasses = array(); if ($isActive) { $liClasses[] = $liActiveClass; } if ($addClassToListItem && $page->getClass()) { $liClasses[] = $page->getClass(); } $liClass = empty($liClasses) ? '' : ' class="' . $escaper(implode(' ', $liClasses)) . '"'; $html .= $myIndent . '    <li' . $liClass . '>' . PHP_EOL . $myIndent . '        ' . $this->htmlify($page, $escapeLabels, $addClassToListItem) . PHP_EOL; $prevDepth = $depth; } if ($html) { for ($i = $prevDepth+1; $i > 0; $i--) { $myIndent = $indent . str_repeat('        ', $i-1); $html .= $myIndent . '    </li>' . PHP_EOL . $myIndent . '</ul>' . PHP_EOL; } $html = rtrim($html, PHP_EOL); } return $html; } public function renderPartial($container = null, $partial = null) { $this->parseContainer($container); if (null === $container) { $container = $this->getContainer(); } if (null === $partial) { $partial = $this->getPartial(); } if (empty($partial)) { throw new Exception\RuntimeException( 'Unable to render menu: No partial view script provided' ); } $model = array( 'container' => $container ); $partialHelper = $this->view->plugin('partial'); if (is_array($partial)) { if (count($partial) != 2) { throw new Exception\InvalidArgumentException( 'Unable to render menu: A view partial supplied as ' . 'an array must contain two values: partial view ' . 'script and module where script can be found' ); } return $partialHelper($partial[0], $model); } return $partialHelper($partial, $model); } public function renderSubMenu( AbstractContainer $container = null, $ulClass = null, $indent = null, $liActiveClass = null ) { return $this->renderMenu($container, array( 'indent' => $indent, 'ulClass' => $ulClass, 'minDepth' => null, 'maxDepth' => null, 'onlyActiveBranch' => true, 'renderParents' => false, 'escapeLabels' => true, 'addClassToListItem' => false, 'liActiveClass' => $liActiveClass )); } public function htmlify(AbstractPage $page, $escapeLabel = true, $addClassToListItem = false) { $attribs = array( 'id' => $page->getId(), 'title' => $this->translate($page->getTitle(), $page->getTextDomain()), ); if ($addClassToListItem === false) { $attribs['class'] = $page->getClass(); } $href = $page->getHref(); if ($href) { $element = 'a'; $attribs['href'] = $href; $attribs['target'] = $page->getTarget(); } else { $element = 'span'; } $html = '<' . $element . $this->htmlAttribs($attribs) . '>'; $label = $this->translate($page->getLabel(), $page->getTextDomain()); if ($escapeLabel === true) { $escaper = $this->view->plugin('escapeHtml'); $html .= $escaper($label); } else { $html .= $label; } $html .= '</' . $element . '>'; return $html; } protected function normalizeOptions(array $options = array()) { if (isset($options['indent'])) { $options['indent'] = $this->getWhitespace($options['indent']); } else { $options['indent'] = $this->getIndent(); } if (isset($options['ulClass']) && $options['ulClass'] !== null) { $options['ulClass'] = (string) $options['ulClass']; } else { $options['ulClass'] = $this->getUlClass(); } if (array_key_exists('minDepth', $options)) { if (null !== $options['minDepth']) { $options['minDepth'] = (int) $options['minDepth']; } } else { $options['minDepth'] = $this->getMinDepth(); } if ($options['minDepth'] < 0 || $options['minDepth'] === null) { $options['minDepth'] = 0; } if (array_key_exists('maxDepth', $options)) { if (null !== $options['maxDepth']) { $options['maxDepth'] = (int) $options['maxDepth']; } } else { $options['maxDepth'] = $this->getMaxDepth(); } if (!isset($options['onlyActiveBranch'])) { $options['onlyActiveBranch'] = $this->getOnlyActiveBranch(); } if (!isset($options['escapeLabels'])) { $options['escapeLabels'] = $this->escapeLabels; } if (!isset($options['renderParents'])) { $options['renderParents'] = $this->getRenderParents(); } if (!isset($options['addClassToListItem'])) { $options['addClassToListItem'] = $this->getAddClassToListItem(); } if (isset($options['liActiveClass']) && $options['liActiveClass'] !== null) { $options['liActiveClass'] = (string) $options['liActiveClass']; } else { $options['liActiveClass'] = $this->getLiActiveClass(); } return $options; } public function escapeLabels($flag = true) { $this->escapeLabels = (bool) $flag; return $this; } public function setAddClassToListItem($flag = true) { $this->addClassToListItem = (bool) $flag; return $this; } public function getAddClassToListItem() { return $this->addClassToListItem; } public function setOnlyActiveBranch($flag = true) { $this->onlyActiveBranch = (bool) $flag; return $this; } public function getOnlyActiveBranch() { return $this->onlyActiveBranch; } public function setPartial($partial) { if (null === $partial || is_string($partial) || is_array($partial)) { $this->partial = $partial; } return $this; } public function getPartial() { return $this->partial; } public function setRenderParents($flag = true) { $this->renderParents = (bool) $flag; return $this; } public function getRenderParents() { return $this->renderParents; } public function setUlClass($ulClass) { if (is_string($ulClass)) { $this->ulClass = $ulClass; } return $this; } public function getUlClass() { return $this->ulClass; } public function setLiActiveClass($liActiveClass) { if (is_string($liActiveClass)) { $this->liActiveClass = $liActiveClass; } return $this; } public function getLiActiveClass() { return $this->liActiveClass; } } } namespace Zend\View\Helper\Navigation\Listener { use Zend\EventManager\Event; class AclListener { public static function accept(Event $event) { $accepted = true; $params = $event->getParams(); $acl = $params['acl']; $page = $params['page']; $role = $params['role']; if (!$acl) { return $accepted; } $resource = $page->getResource(); $privilege = $page->getPrivilege(); if ($resource || $privilege) { $accepted = $acl->hasResource($resource) && $acl->isAllowed($role, $resource, $privilege); } return $accepted; } } } namespace Zend\Mvc { use Zend\EventManager\EventManagerInterface; use Zend\EventManager\ListenerAggregateInterface; class ModuleRouteListener implements ListenerAggregateInterface { const MODULE_NAMESPACE = '__NAMESPACE__'; const ORIGINAL_CONTROLLER = '__CONTROLLER__'; protected $listeners = array(); public function attach(EventManagerInterface $events, $priority = 1) { $this->listeners[] = $events->attach(MvcEvent::EVENT_ROUTE, array($this, 'onRoute'), $priority); } public function detach(EventManagerInterface $events) { foreach ($this->listeners as $index => $listener) { if ($events->detach($listener)) { unset($this->listeners[$index]); } } } public function onRoute(MvcEvent $e) { $matches = $e->getRouteMatch(); if (!$matches instanceof Router\RouteMatch) { return; } $module = $matches->getParam(self::MODULE_NAMESPACE, false); if (!$module) { return; } $controller = $matches->getParam('controller', false); if (!$controller) { return; } if (0 === strpos($controller, $module)) { return; } $matches->setParam(self::ORIGINAL_CONTROLLER, $controller); $controller = $module . '\\' . str_replace(' ', '', ucwords(str_replace('-', ' ', $controller))); $matches->setParam('controller', $controller); } } } namespace Zend\View\Helper { class EscapeHtmlAttr extends Escaper\AbstractHelper { protected function escape($value) { return $this->getEscaper()->escapeHtmlAttr($value); } } } namespace Zend\View\Helper { class InlineScript extends HeadScript { protected $regKey = 'Zend_View_Helper_InlineScript'; public function __invoke($mode = self::FILE, $spec = null, $placement = 'APPEND', array $attrs = array(), $type = 'text/javascript') { return parent::__invoke($mode, $spec, $placement, $attrs, $type); } } } namespace Zend\Code\Scanner { interface ScannerInterface { } } namespace Zend\Db\Sql { class Expression implements ExpressionInterface { const PLACEHOLDER = '?'; protected $expression = ''; protected $parameters = array(); protected $types = array(); public function __construct($expression = '', $parameters = null, array $types = array()) { if ($expression) { $this->setExpression($expression); } if ($parameters) { $this->setParameters($parameters); } if ($types) { $this->setTypes($types); } } public function setExpression($expression) { if (!is_string($expression) || $expression == '') { throw new Exception\InvalidArgumentException('Supplied expression must be a string.'); } $this->expression = $expression; return $this; } public function getExpression() { return $this->expression; } public function setParameters($parameters) { if (!is_scalar($parameters) && !is_array($parameters)) { throw new Exception\InvalidArgumentException('Expression parameters must be a scalar or array.'); } $this->parameters = $parameters; return $this; } public function getParameters() { return $this->parameters; } public function setTypes(array $types) { $this->types = $types; return $this; } public function getTypes() { return $this->types; } public function getExpressionData() { $parameters = (is_scalar($this->parameters)) ? array($this->parameters) : $this->parameters; $types = array(); $parametersCount = count($parameters); if ($parametersCount == 0 && strpos($this->expression, self::PLACEHOLDER) !== false) { $parametersCount = substr_count($this->expression, self::PLACEHOLDER); $parameters = array_fill(0, $parametersCount, null); } for ($i = 0; $i < $parametersCount; $i++) { $types[$i] = (isset($this->types[$i]) && ($this->types[$i] == self::TYPE_IDENTIFIER || $this->types[$i] == self::TYPE_LITERAL)) ? $this->types[$i] : self::TYPE_VALUE; } $expression = str_replace('%', '%%', $this->expression); if ($parametersCount > 0) { $count = 0; $expression = str_replace(self::PLACEHOLDER, '%s', $expression, $count); if ($count !== $parametersCount) { throw new Exception\RuntimeException('The number of replacements in the expression does not match the number of parameters'); } } return array(array( $expression, $parameters, $types )); } } } namespace Zend\Code\Scanner { use Zend\Code\Annotation\AnnotationManager; use Zend\Code\Exception; use Zend\Code\NameInformation; class TokenArrayScanner implements ScannerInterface { protected $isScanned = false; protected $tokens = array(); protected $docComment = null; protected $nameInformation = null; protected $infos = array(); protected $annotationManager = null; public function __construct($tokens, AnnotationManager $annotationManager = null) { $this->tokens = $tokens; $this->annotationManager = $annotationManager; } public function getAnnotationManager() { return $this->annotationManager; } public function getDocComment() { foreach ($this->tokens as $token) { $type = $token[0]; $value = $token[1]; if (($type == T_OPEN_TAG) || ($type == T_WHITESPACE)) { continue; } elseif ($type == T_DOC_COMMENT) { $this->docComment = $value; return $this->docComment; } else { return; } } } public function getNamespaces() { $this->scan(); $namespaces = array(); foreach ($this->infos as $info) { if ($info['type'] == 'namespace') { $namespaces[] = $info['namespace']; } } return $namespaces; } public function getUses($namespace = null) { $this->scan(); return $this->getUsesNoScan($namespace); } public function getIncludes() { $this->scan(); } public function getClassNames() { $this->scan(); $return = array(); foreach ($this->infos as $info) { if ($info['type'] != 'class') { continue; } $return[] = $info['name']; } return $return; } public function getClasses() { $this->scan(); $return = array(); foreach ($this->infos as $info) { if ($info['type'] != 'class') { continue; } $return[] = $this->getClass($info['name']); } return $return; } public function getClass($name) { $this->scan(); if (is_int($name)) { $info = $this->infos[$name]; if ($info['type'] != 'class') { throw new Exception\InvalidArgumentException('Index of info offset is not about a class'); } } elseif (is_string($name)) { $classFound = false; foreach ($this->infos as $info) { if ($info['type'] === 'class' && $info['name'] === $name) { $classFound = true; break; } } if (!$classFound) { return false; } } return new ClassScanner( array_slice( $this->tokens, $info['tokenStart'], ($info['tokenEnd'] - $info['tokenStart'] + 1) ), new NameInformation($info['namespace'], $info['uses']) ); } public function getClassNameInformation($className) { $this->scan(); $classFound = false; foreach ($this->infos as $info) { if ($info['type'] === 'class' && $info['name'] === $className) { $classFound = true; break; } } if (!$classFound) { return false; } if (!isset($info)) { return null; } return new NameInformation($info['namespace'], $info['uses']); } public function getFunctionNames() { $this->scan(); $functionNames = array(); foreach ($this->infos as $info) { if ($info['type'] == 'function') { $functionNames[] = $info['name']; } } return $functionNames; } public function getFunctions() { $this->scan(); $functions = array(); foreach ($this->infos as $info) { if ($info['type'] == 'function') { } } return $functions; } public static function export($tokens) { } public function __toString() { } protected function scan() { if ($this->isScanned) { return; } if (!$this->tokens) { throw new Exception\RuntimeException('No tokens were provided'); } if (!defined('T_TRAIT')) { define('T_TRAIT', 42001); } $tokens = &$this->tokens; $infos = &$this->infos; $tokenIndex = null; $token = null; $tokenType = null; $tokenContent = null; $tokenLine = null; $namespace = null; $docCommentIndex = false; $infoIndex = 0; $MACRO_TOKEN_ADVANCE = function () use (&$tokens, &$tokenIndex, &$token, &$tokenType, &$tokenContent, &$tokenLine) { $tokenIndex = ($tokenIndex === null) ? 0 : $tokenIndex + 1; if (!isset($tokens[$tokenIndex])) { $token = false; $tokenContent = false; $tokenType = false; $tokenLine = false; return false; } if (is_string($tokens[$tokenIndex]) && $tokens[$tokenIndex] === '"') { do { $tokenIndex++; } while (!(is_string($tokens[$tokenIndex]) && $tokens[$tokenIndex] === '"')); } $token = $tokens[$tokenIndex]; if (is_array($token)) { list($tokenType, $tokenContent, $tokenLine) = $token; } else { $tokenType = null; $tokenContent = $token; } return $tokenIndex; }; $MACRO_TOKEN_LOGICAL_START_INDEX = function () use (&$tokenIndex, &$docCommentIndex) { return ($docCommentIndex === false) ? $tokenIndex : $docCommentIndex; }; $MACRO_DOC_COMMENT_START = function () use (&$tokenIndex, &$docCommentIndex) { $docCommentIndex = $tokenIndex; return $docCommentIndex; }; $MACRO_DOC_COMMENT_VALIDATE = function () use (&$tokenType, &$docCommentIndex) { static $validTrailingTokens = null; if ($validTrailingTokens === null) { $validTrailingTokens = array(T_WHITESPACE, T_FINAL, T_ABSTRACT, T_INTERFACE, T_CLASS, T_FUNCTION); } if ($docCommentIndex !== false && !in_array($tokenType, $validTrailingTokens)) { $docCommentIndex = false; } return $docCommentIndex; }; $MACRO_INFO_ADVANCE = function () use (&$infoIndex, &$infos, &$tokenIndex, &$tokenLine) { $infos[$infoIndex]['tokenEnd'] = $tokenIndex; $infos[$infoIndex]['lineEnd'] = $tokenLine; $infoIndex++; return $infoIndex; }; $MACRO_TOKEN_ADVANCE(); SCANNER_TOP: if ($token === false) { goto SCANNER_END; } $MACRO_DOC_COMMENT_VALIDATE(); switch ($tokenType) { case T_DOC_COMMENT: $MACRO_DOC_COMMENT_START(); goto SCANNER_CONTINUE; case T_NAMESPACE: $infos[$infoIndex] = array( 'type' => 'namespace', 'tokenStart' => $MACRO_TOKEN_LOGICAL_START_INDEX(), 'tokenEnd' => null, 'lineStart' => $token[2], 'lineEnd' => null, 'namespace' => null, ); if ($MACRO_TOKEN_ADVANCE() === false) { goto SCANNER_END; } SCANNER_NAMESPACE_TOP: if ($tokenType === null && $tokenContent === ';' || $tokenContent === '{') { goto SCANNER_NAMESPACE_END; } if ($tokenType === T_WHITESPACE) { goto SCANNER_NAMESPACE_CONTINUE; } if ($tokenType === T_NS_SEPARATOR || $tokenType === T_STRING) { $infos[$infoIndex]['namespace'] .= $tokenContent; } SCANNER_NAMESPACE_CONTINUE: if ($MACRO_TOKEN_ADVANCE() === false) { goto SCANNER_END; } goto SCANNER_NAMESPACE_TOP; SCANNER_NAMESPACE_END: $namespace = $infos[$infoIndex]['namespace']; $MACRO_INFO_ADVANCE(); goto SCANNER_CONTINUE; case T_USE: $infos[$infoIndex] = array( 'type' => 'use', 'tokenStart' => $MACRO_TOKEN_LOGICAL_START_INDEX(), 'tokenEnd' => null, 'lineStart' => $tokens[$tokenIndex][2], 'lineEnd' => null, 'namespace' => $namespace, 'statements' => array(0 => array('use' => null, 'as' => null)), ); $useStatementIndex = 0; $useAsContext = false; if ($MACRO_TOKEN_ADVANCE() === false) { goto SCANNER_END; } SCANNER_USE_TOP: if ($tokenType === null) { if ($tokenContent === ';') { goto SCANNER_USE_END; } elseif ($tokenContent === ',') { $useAsContext = false; $useStatementIndex++; $infos[$infoIndex]['statements'][$useStatementIndex] = array('use' => null, 'as' => null); } } if ($tokenType !== null) { if ($tokenType == T_AS) { $useAsContext = true; goto SCANNER_USE_CONTINUE; } if ($tokenType == T_NS_SEPARATOR || $tokenType == T_STRING) { if ($useAsContext == false) { $infos[$infoIndex]['statements'][$useStatementIndex]['use'] .= $tokenContent; } else { $infos[$infoIndex]['statements'][$useStatementIndex]['as'] = $tokenContent; } } } SCANNER_USE_CONTINUE: if ($MACRO_TOKEN_ADVANCE() === false) { goto SCANNER_END; } goto SCANNER_USE_TOP; SCANNER_USE_END: $MACRO_INFO_ADVANCE(); goto SCANNER_CONTINUE; case T_INCLUDE: case T_INCLUDE_ONCE: case T_REQUIRE: case T_REQUIRE_ONCE: static $includeTypes = array( T_INCLUDE => 'include', T_INCLUDE_ONCE => 'include_once', T_REQUIRE => 'require', T_REQUIRE_ONCE => 'require_once' ); $infos[$infoIndex] = array( 'type' => 'include', 'tokenStart' => $MACRO_TOKEN_LOGICAL_START_INDEX(), 'tokenEnd' => null, 'lineStart' => $tokens[$tokenIndex][2], 'lineEnd' => null, 'includeType' => $includeTypes[$tokens[$tokenIndex][0]], 'path' => '', ); if ($MACRO_TOKEN_ADVANCE() === false) { goto SCANNER_END; } SCANNER_INCLUDE_TOP: if ($tokenType === null && $tokenContent === ';') { goto SCANNER_INCLUDE_END; } $infos[$infoIndex]['path'] .= $tokenContent; SCANNER_INCLUDE_CONTINUE: if ($MACRO_TOKEN_ADVANCE() === false) { goto SCANNER_END; } goto SCANNER_INCLUDE_TOP; SCANNER_INCLUDE_END: $MACRO_INFO_ADVANCE(); goto SCANNER_CONTINUE; case T_FUNCTION: case T_FINAL: case T_ABSTRACT: case T_CLASS: case T_INTERFACE: case T_TRAIT: $infos[$infoIndex] = array( 'type' => ($tokenType === T_FUNCTION) ? 'function' : 'class', 'tokenStart' => $MACRO_TOKEN_LOGICAL_START_INDEX(), 'tokenEnd' => null, 'lineStart' => $tokens[$tokenIndex][2], 'lineEnd' => null, 'namespace' => $namespace, 'uses' => $this->getUsesNoScan($namespace), 'name' => null, 'shortName' => null, ); $classBraceCount = 0; SCANNER_CLASS_TOP: if ($infos[$infoIndex]['shortName'] == '' && (($tokenType === T_CLASS || $tokenType === T_INTERFACE || $tokenType === T_TRAIT) && $infos[$infoIndex]['type'] === 'class' || ($tokenType === T_FUNCTION && $infos[$infoIndex]['type'] === 'function')) ) { $infos[$infoIndex]['shortName'] = $tokens[$tokenIndex + 2][1]; $infos[$infoIndex]['name'] = (($namespace != null) ? $namespace . '\\' : '') . $infos[$infoIndex]['shortName']; } if ($tokenType === null) { if ($tokenContent == '{') { $classBraceCount++; } if ($tokenContent == '}') { $classBraceCount--; if ($classBraceCount === 0) { goto SCANNER_CLASS_END; } } } SCANNER_CLASS_CONTINUE: if ($MACRO_TOKEN_ADVANCE() === false) { goto SCANNER_END; } goto SCANNER_CLASS_TOP; SCANNER_CLASS_END: $MACRO_INFO_ADVANCE(); goto SCANNER_CONTINUE; } SCANNER_CONTINUE: if ($MACRO_TOKEN_ADVANCE() === false) { goto SCANNER_END; } goto SCANNER_TOP; SCANNER_END: $this->isScanned = true; } public function hasNamespace($namespace) { $this->scan(); foreach ($this->infos as $info) { if ($info['type'] == 'namespace' && $info['namespace'] == $namespace) { return true; } } return false; } protected function getUsesNoScan($namespace) { $namespaces = array(); foreach ($this->infos as $info) { if ($info['type'] == 'namespace') { $namespaces[] = $info['namespace']; } } if ($namespace === null) { $namespace = array_shift($namespaces); } elseif (!is_string($namespace)) { throw new Exception\InvalidArgumentException('Invalid namespace provided'); } elseif (!in_array($namespace, $namespaces)) { return null; } $uses = array(); foreach ($this->infos as $info) { if ($info['type'] !== 'use') { continue; } foreach ($info['statements'] as $statement) { if ($info['namespace'] == $namespace) { $uses[] = $statement; } } } return $uses; } } } namespace Zend\Code\Scanner { use Zend\Code\Annotation\AnnotationManager; use Zend\Code\Exception; class FileScanner extends TokenArrayScanner { protected $file = null; public function __construct($file, AnnotationManager $annotationManager = null) { $this->file = $file; if (!file_exists($file)) { throw new Exception\InvalidArgumentException(sprintf( 'File "%s" not found', $file )); } parent::__construct(token_get_all(file_get_contents($file)), $annotationManager); } public function getFile() { return $this->file; } } } namespace Zend\Db\Sql { use Zend\Db\Adapter\AdapterInterface; use Zend\Db\Adapter\ParameterContainer; use Zend\Db\Adapter\Platform\PlatformInterface; use Zend\Db\Adapter\Platform\Sql92; use Zend\Db\Adapter\StatementContainerInterface; use Zend\Stdlib\PriorityList; class Update extends AbstractSql implements SqlInterface, PreparableSqlInterface { const SPECIFICATION_UPDATE = 'update'; const SPECIFICATION_WHERE = 'where'; const VALUES_MERGE = 'merge'; const VALUES_SET = 'set'; protected $specifications = array( self::SPECIFICATION_UPDATE => 'UPDATE %1$s SET %2$s', self::SPECIFICATION_WHERE => 'WHERE %1$s' ); protected $table = ''; protected $emptyWhereProtection = true; protected $set; protected $where = null; public function __construct($table = null) { if ($table) { $this->table($table); } $this->where = new Where(); $this->set = new PriorityList(); $this->set->isLIFO(false); } public function table($table) { $this->table = $table; return $this; } public function set(array $values, $flag = self::VALUES_SET) { if ($values == null) { throw new Exception\InvalidArgumentException('set() expects an array of values'); } if ($flag == self::VALUES_SET) { $this->set->clear(); } $priority = is_numeric($flag) ? $flag : 0; foreach ($values as $k => $v) { if (!is_string($k)) { throw new Exception\InvalidArgumentException('set() expects a string for the value key'); } $this->set->insert($k, $v, $priority); } return $this; } public function where($predicate, $combination = Predicate\PredicateSet::OP_AND) { if ($predicate instanceof Where) { $this->where = $predicate; } else { $this->where->addPredicates($predicate, $combination); } return $this; } public function getRawState($key = null) { $rawState = array( 'emptyWhereProtection' => $this->emptyWhereProtection, 'table' => $this->table, 'set' => $this->set->toArray(), 'where' => $this->where ); return (isset($key) && array_key_exists($key, $rawState)) ? $rawState[$key] : $rawState; } public function prepareStatement(AdapterInterface $adapter, StatementContainerInterface $statementContainer) { $driver = $adapter->getDriver(); $platform = $adapter->getPlatform(); $parameterContainer = $statementContainer->getParameterContainer(); if (!$parameterContainer instanceof ParameterContainer) { $parameterContainer = new ParameterContainer(); $statementContainer->setParameterContainer($parameterContainer); } $table = $this->table; $schema = null; if ($table instanceof TableIdentifier) { list($table, $schema) = $table->getTableAndSchema(); } $table = $platform->quoteIdentifier($table); if ($schema) { $table = $platform->quoteIdentifier($schema) . $platform->getIdentifierSeparator() . $table; } $setSql = array(); foreach ($this->set as $column => $value) { if ($value instanceof Expression) { $exprData = $this->processExpression($value, $platform, $driver); $setSql[] = $platform->quoteIdentifier($column) . ' = ' . $exprData->getSql(); $parameterContainer->merge($exprData->getParameterContainer()); } else { $setSql[] = $platform->quoteIdentifier($column) . ' = ' . $driver->formatParameterName($column); $parameterContainer->offsetSet($column, $value); } } $set = implode(', ', $setSql); $sql = sprintf($this->specifications[static::SPECIFICATION_UPDATE], $table, $set); if ($this->where->count() > 0) { $whereParts = $this->processExpression($this->where, $platform, $driver, 'where'); $parameterContainer->merge($whereParts->getParameterContainer()); $sql .= ' ' . sprintf($this->specifications[static::SPECIFICATION_WHERE], $whereParts->getSql()); } $statementContainer->setSql($sql); } public function getSqlString(PlatformInterface $adapterPlatform = null) { $adapterPlatform = ($adapterPlatform) ?: new Sql92; $table = $this->table; $schema = null; if ($table instanceof TableIdentifier) { list($table, $schema) = $table->getTableAndSchema(); } $table = $adapterPlatform->quoteIdentifier($table); if ($schema) { $table = $adapterPlatform->quoteIdentifier($schema) . $adapterPlatform->getIdentifierSeparator() . $table; } $setSql = array(); foreach ($this->set as $column => $value) { if ($value instanceof ExpressionInterface) { $exprData = $this->processExpression($value, $adapterPlatform); $setSql[] = $adapterPlatform->quoteIdentifier($column) . ' = ' . $exprData->getSql(); } elseif ($value === null) { $setSql[] = $adapterPlatform->quoteIdentifier($column) . ' = NULL'; } else { $setSql[] = $adapterPlatform->quoteIdentifier($column) . ' = ' . $adapterPlatform->quoteValue($value); } } $set = implode(', ', $setSql); $sql = sprintf($this->specifications[static::SPECIFICATION_UPDATE], $table, $set); if ($this->where->count() > 0) { $whereParts = $this->processExpression($this->where, $adapterPlatform, null, 'where'); $sql .= ' ' . sprintf($this->specifications[static::SPECIFICATION_WHERE], $whereParts->getSql()); } return $sql; } public function __get($name) { switch (strtolower($name)) { case 'where': return $this->where; } } public function __clone() { $this->where = clone $this->where; $this->set = clone $this->set; } } } namespace Zend\Http\Response { use Zend\Http\Exception; use Zend\Http\Response; use Zend\Stdlib\ErrorHandler; class Stream extends Response { protected $contentLength = null; protected $contentStreamed = 0; protected $stream; protected $streamName; protected $cleanup; public function setContentLength($contentLength = null) { $this->contentLength = $contentLength; } public function getContentLength() { return $this->contentLength; } public function getStream() { return $this->stream; } public function setStream($stream) { $this->stream = $stream; return $this; } public function getCleanup() { return $this->cleanup; } public function setCleanup($cleanup = true) { $this->cleanup = $cleanup; } public function getStreamName() { return $this->streamName; } public function setStreamName($streamName) { $this->streamName = $streamName; return $this; } public static function fromStream($responseString, $stream) { if (!is_resource($stream) || get_resource_type($stream) !== 'stream') { throw new Exception\InvalidArgumentException('A valid stream is required'); } $headerComplete = false; $headersString = ''; $responseArray = array(); if ($responseString) { $responseArray = explode("\n", $responseString); } while (count($responseArray)) { $nextLine = array_shift($responseArray); $headersString .= $nextLine."\n"; $nextLineTrimmed = trim($nextLine); if ($nextLineTrimmed == '') { $headerComplete = true; break; } } if (!$headerComplete) { while (false !== ($nextLine = fgets($stream))) { $headersString .= trim($nextLine)."\r\n"; if ($nextLine == "\r\n" || $nextLine == "\n") { $headerComplete = true; break; } } } if (!$headerComplete) { throw new Exception\OutOfRangeException('End of header not found'); } $response = static::fromString($headersString); if (is_resource($stream)) { $response->setStream($stream); } if (count($responseArray)) { $response->content = implode("\n", $responseArray); } $headers = $response->getHeaders(); foreach ($headers as $header) { if ($header instanceof \Zend\Http\Header\ContentLength) { $response->setContentLength((int) $header->getFieldValue()); $contentLength = $response->getContentLength(); if (strlen($response->content) > $contentLength) { throw new Exception\OutOfRangeException(sprintf( 'Too much content was extracted from the stream (%d instead of %d bytes)', strlen($response->content), $contentLength )); } break; } } return $response; } public function getBody() { if ($this->stream != null) { $this->readStream(); } return parent::getBody(); } public function getRawBody() { if ($this->stream) { $this->readStream(); } return $this->content; } protected function readStream() { $contentLength = $this->getContentLength(); if (null !== $contentLength) { $bytes = $contentLength - $this->contentStreamed; } else { $bytes = -1; } if (!is_resource($this->stream) || $bytes == 0) { return ''; } $this->content .= stream_get_contents($this->stream, $bytes); $this->contentStreamed += strlen($this->content); if ($this->getContentLength() == $this->contentStreamed) { $this->stream = null; } } public function __destruct() { if (is_resource($this->stream)) { $this->stream = null; } if ($this->cleanup) { ErrorHandler::start(E_WARNING); unlink($this->streamName); ErrorHandler::stop(); } } } } 

